<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>WPlace UltraBOT</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
  <style>
    :root { color-scheme: dark light; }
    body {
      margin: 0;
      min-height: 100vh;
      background-color: #ffffff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      color: #e5e7eb;
    }
    #c {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      
      display: block;
      background: #ffffff;
      cursor: grab;
      z-index: 0;
    }
    body.dragging #c { cursor: grabbing; }
    .panel {
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(17, 20, 24, 0.85);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      padding: 12px 16px;
      display: flex;
      gap: 8px;
      align-items: center;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      z-index: 1000;
    }
    label { font-size: 14px; }
    input {
      width: 100px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.25);
      color: #e5e7eb;
      outline: none;
    }
    button {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.35);
      color: #e5e7eb;
      cursor: pointer;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      font: inherit;
      line-height: 1.2;
      display: inline-flex;
      align-items: center;
      transition: background-color 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }
    button:hover { background: rgba(255,255,255,0.08); }
    /* Match Fetch button's hover visuals for all primary buttons */
    .panel .app-btn:hover,
    #btn-accounts:hover,
    #btn-ready:hover,
    #btn-auto-select-accounts:hover,
    #start:hover,
    #btn-auto-select:hover,
    #btn-upload-sign:hover {
      border-color: rgba(34,211,238,0.45);
      box-shadow: inset 0 0 0 1px rgba(34,211,238,0.35), 0 0 0 2px rgba(34,211,238,0.15);
    }
    .app-btn {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.35);
      color: #e5e7eb;
      cursor: pointer;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      font: inherit;
      line-height: 1.2;
      display: inline-flex;
      align-items: center;
      max-width: 100%;
      white-space: normal;
      text-align: center;
      transition: background-color 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }
    .app-btn:hover { background: rgba(255,255,255,0.08); }
    .app-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    #btn-account-cancel.app-btn, #btn-account-save.app-btn {
      padding-left: 30px;
      padding-right: 30px;
    }
    .url {
      position: fixed;
      bottom: 12px; left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.45);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      word-break: break-all;
      z-index: 1000;
    }
    #sign {
      position: fixed;
      left: 0;
      top: 0;
      z-index: 500;
      user-select: none;
      pointer-events: auto;
      image-rendering: pixelated;
      background: rgba(0,0,0,0.0);
      transform-origin: top left;
      will-change: transform;
    }
    #sign[hidden] { display: none; }
    #sign-outline {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      border: 2px dashed #22d3ee;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.7);
    }
    #sign-outline[hidden] { display: none; }
    #sign-layer { position: fixed; left: 0; top: 0; z-index: 600; pointer-events: none; }
    .pixel-marker {
      position: fixed;
      left: 0;
      top: 0;
      width: 10px;
      height: 10px;
      image-rendering: pixelated;
      pointer-events: none;
      z-index: 1300;
    }
    .pixel-marker[hidden] { display: none; }
    #selection-overlay { position: fixed; left: 0; top: 0; z-index: 700; pointer-events: none; image-rendering: pixelated; }
    body.dragging-sign #sign { cursor: grabbing; }
    /* CSS for range-overlay */
   #range-overlay {
       position: absolute;
       border: 2px dashed #22d3ee; /* Màu xanh neon */
       background: rgba(34, 211, 238, 0.2); /* Nền trong suốt với màu xanh */
       z-index: 1000;
       pointer-events: none;
   }
   #range-overlay.saved-overlay {
       background: none; /* Bỏ màu nền khi đã lưu */
       border: 2px solid #22d3ee; /* Viền liền khi đã lưu */
   }

    #overlay-section {
        width: 100%;
        margin-top: 8px;
        border-top: 1px solid rgba(255,255,255,0.1);
        padding-top: 8px;
    }
    .overlay-list {
        max-height: 120px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 8px;
        padding: 6px;
        background: rgba(0,0,0,0.2);
        border-radius: 6px;
    }
    .overlay-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 4px 8px;
        background: rgba(255,255,255,0.05);
        border-radius: 4px;
        font-size: 12px;
    }
    .overlay-item.selected {
        background: rgba(34, 211, 238, 0.25);
    }
    .overlay-item-actions button {
        padding: 2px 5px;
        font-size: 10px;
    }
    
    #sidebar {
      position: fixed;
      top: 12px;
      left: 12px;
      bottom: 12px;
      width: 140px;
      background: rgba(17, 20, 24, 0.85);
      border-right: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      padding: 36px 8px 8px 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 900;
      overflow-y: auto;
    }
    #thumb-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .thumb-item {
      position: relative;
      width: 100%;
      height: 84px;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      background: rgba(0,0,0,0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      cursor: pointer;
    }
    .thumb-item img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      image-rendering: pixelated;
      pointer-events: none;
      user-select: none;
    }
    .thumb-item.selected {
      border-color: #22d3ee;
      box-shadow: inset 0 0 0 1px rgba(34,211,238,0.35);
    }
    .thumb-item.selected::before {
      content: '';
      position: absolute;
      left: -1px;
      top: 0;
      bottom: 0;
      width: 3px;
      background: #22d3ee;
    }
    .thumb-item.locked {
      opacity: 0.95;
    }
    .thumb-actions {
      position: absolute;
      top: 4px;
      right: 4px;
      display: flex;
      gap: 4px;
      z-index: 2;
    }
    .thumb-action {
      width: 18px;
      height: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      border-radius: 5px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.5);
      color: #e5e7eb;
      cursor: pointer;
    }
    .thumb-action:hover { background: rgba(0,0,0,0.65); }
    
    #sidebar .thumb-actions { display: none; }
    .counter {
      position: absolute;
      top: 8px;
      right: 8px;
      z-index: 1;
      background: rgba(0,0,0,0.45);
      color: #e5e7eb;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    #pixel-power {
      position: static;
      display: inline-flex;
      align-items: center;
      background: rgba(0,0,0,0.45);
      color: #e5e7eb;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      white-space: normal;
      text-align: center;
      max-width: 100%;
    }
    /* CSS-only top toolbar to place sound control left of control panel */
    #top-toolbar {
      position: fixed;
      top: 16px;
      left: 16px;
      right: 16px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 16px;
      z-index: 1001;
      pointer-events: none;
    }
    #sound-control { position: relative; display: inline-flex; align-items: center; z-index: 1003; top: -20px; pointer-events: auto; }
    #sound-toggle { background-color: rgba(0,0,0,0.75); padding: 6px 10px; border: 1px solid rgba(255,255,255,0.1); }
    #sound-toggle.muted { opacity: 0.6; }
    #sound-control .sound-slider { display: none; position: absolute; top: calc(100% + 8px); left: 50%; transform: translateX(-50%); background: rgba(17, 20, 24, 0.95); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 10px; gap: 8px; align-items: center; flex-direction: column; z-index: 1003; min-width: 30px; box-shadow: 0 8px 30px rgba(0,0,0,0.35); }
    #sound-control:hover .sound-slider, #sound-control.open .sound-slider, #sound-control.hover .sound-slider { display: flex; }
    #sound-volume { position: relative; width: 12px; height: 170px; user-select: none; touch-action: none; cursor: pointer; }
    #sound-volume .slider-track { position: absolute; left: 50%; transform: translateX(-50%); width: 4px; height: 100%; background: rgba(255,255,255,0.18); border-radius: 9999px; }
    #sound-volume .slider-fill { position: absolute; left: 50%; transform: translateX(-50%); width: 4px; bottom: 0; height: 0%; background: rgba(255,255,255,0.8); border-radius: 9999px; }
    #sound-volume .slider-thumb { position: absolute; left: 50%; transform: translate(-50%, 50%); width: 12px; height: 12px; border-radius: 9999px; background: #e5e7eb; border: 1px solid rgba(255,255,255,0.5); bottom: 0%; box-shadow: 0 1px 4px rgba(0,0,0,0.25); }
    /* Movement control floating (bottom-right) */
    #move-control { position: fixed; right: 16px; bottom: 16px; display: inline-flex; align-items: center; z-index: 1003; }
    #btn-movement { background-color: rgba(0,0,0,0.75); }
    #btn-movement:hover { background-color: rgba(0,0,0,0.60); }
    #movement-popup { position: absolute; bottom: calc(100% + 8px); right: 0; background: rgba(17, 20, 24, 0.95); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 10px; gap: 8px; align-items: center; flex-direction: column; z-index: 1003; min-width: 120px; box-shadow: 0 8px 30px rgba(0,0,0,0.35); display: flex; }
    #movement-popup[hidden] { display: none; }
    .movement-grid { display: grid; grid-template-columns: repeat(3, 34px); grid-auto-rows: 34px; gap: 8px; justify-content: center; align-items: center; }
    .movement-grid .dir-btn { width: 34px; height: 34px; padding: 0; line-height: 1; display: inline-flex; align-items: center; justify-content: center; }
    .movement-grid .dir-btn.kbd-press,
    .movement-grid .dir-btn:active,
    .movement-grid .dir-btn:hover { background: rgba(255,255,255,0.08); border-color: rgba(34,211,238,0.35); box-shadow: inset 0 0 0 1px rgba(34,211,238,0.25); }
    
    #btn-accounts {
      background-color: rgba(0,0,0,0.75);
      position: static;
    }
    #btn-accounts:hover {
      background-color: rgba(0,0,0,0.60);
    }
    #accounts-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.45);
      z-index: 1100;
    }
    #accounts-modal[hidden] { display: none; }
    #img-preview-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.45);
      z-index: 1100;
    }
    #img-preview-modal[hidden] { display: none; }
    
    body.no-scroll { overflow: hidden; }
    #img-preview-canvas {
      width: min(540px, 85vw);
      height: min(360px, 48vh);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      background: rgba(0,0,0,0.25);
      image-rendering: pixelated;
      display: block;
      margin: 0 auto 10px auto;
    }
    #accounts-modal[hidden] { display: none; }
    #img-preview-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.45);
      z-index: 1100;
    }
    #img-preview-modal[hidden] { display: none; }
    
    body.no-scroll { overflow: hidden; }
    #img-preview-canvas {
      width: min(540px, 85vw);
      height: min(360px, 48vh);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      background: rgba(0,0,0,0.25);
      image-rendering: pixelated;
      display: block;
      margin: 0 auto 10px auto;
    }
    #img-preview-modal .modal-card { max-height: 90vh; }
    #img-preview-modal .modal-body { max-height: none; overflow: visible; }
    .img-preview-grid {
      display: grid;
      grid-template-columns: minmax(0, 140px) 1fr;
      gap: 10px 12px;
      align-items: center;
      pointer-events: auto;
    }
    .img-preview-flex {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 720px){ .img-preview-flex { grid-template-columns: 1fr; } }
    #img-fill-side { pointer-events: auto; }
    #img-fill-side .row { display: grid; grid-template-columns: minmax(0, 140px) 1fr; gap: 10px 12px; align-items: center; }
    #img-fill-side .row + .row { margin-top: 8px; }
    #img-fill-side .color-row { align-items: start; }
    #img-fill-color {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      align-items: start;
      width: 100%;
    }
    #img-fill-color .modal-palette-swatch {
      cursor: pointer;
      width: 100%;
      aspect-ratio: 1 / 1;
      height: auto;
    }
    #img-fill-color[aria-disabled="true"] { opacity: 0.5; pointer-events: none; }
    #img-preview-modal .img-preview-grid select,
    #img-preview-modal .img-preview-grid button {
      justify-self: start;
      width: 100px;
    }
    .modal-card {
      background: rgba(17, 20, 24, 0.95);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.5);
      width: min(800px, 95vw);
      max-width: 95vw;
      color: #e5e7eb;
      padding: 16px 20px;
      position: relative;
    }
    .modal-header {
      font-size: 16px;
      font-weight: 600;
      margin: 0 0 12px 0;
    }
    .modal-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.5);
      color: #e5e7eb;
      cursor: pointer;
    }
    .modal-close:hover { background: rgba(0,0,0,0.65); }
    .modal-back {
      position: absolute;
      top: 8px;
      left: 12px;
      padding: 10px 14px;
      font-size: 14px;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35), 0 0 0 1px rgba(34,211,238,0.25) inset;
    }
    .modal-back:hover { box-shadow: 0 8px 22px rgba(0,0,0,0.45), 0 0 0 1px rgba(34,211,238,0.35) inset; }
    .modal-right-info {
      position: absolute;
      top: 8px;
      right: 72px;
      padding: 8px 12px;
      font-size: 14px;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35), 0 0 0 1px rgba(34,211,238,0.25) inset;
      pointer-events: none;
      opacity: 0.9;
    }
    .shop-header { margin: 6px 0 14px 0; }
    .shop-title { font-size: 18px; font-weight: 700; margin-bottom: 2px; }
    .shop-sub { font-size: 12px; opacity: 0.8; }
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 14px;
    }
    .shop-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 18px;
      min-height: 220px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    .shop-icon { font-size: 46px; line-height: 1; opacity: 0.9; margin-bottom: 8px; }
    .shop-name { font-size: 22px; font-weight: 800; margin-bottom: 6px; }
    .shop-desc { font-size: 12px; opacity: 0.8; margin-bottom: 14px; }
    .shop-qty-row { display: flex; align-items: center; gap: 10px; justify-content: center; margin-bottom: 14px; }
    .shop-qty-btn { padding: 6px 10px; }
    .shop-qty-val { min-width: 34px; text-align: center; font-weight: 700; }
    .shop-pill { padding: 10px 14px; border-radius: 999px; background: rgba(34,211,238,0.12); border: 1px solid rgba(34,211,238,0.35); box-shadow: inset 0 0 0 1px rgba(34,211,238,0.25); }
    #shop-premium-buy { margin-top: 12px; display: inline-flex; align-items: center; gap: 8px; align-self: center; cursor: pointer; }
    #shop-premium-buy:hover { filter: brightness(1.06); border-color: rgba(34,211,238,0.5); box-shadow: inset 0 0 0 1px rgba(34,211,238,0.35); }
    #shop-premium-buy[aria-disabled="true"] { opacity: 0.55; pointer-events: none; }
    #shop-max-price[aria-disabled="true"], #shop-rec-price[aria-disabled="true"] { opacity: 0.55; pointer-events: none; }
    #shop-max-price { cursor: pointer; }
    #shop-max-price:hover { filter: brightness(1.06); border-color: rgba(34,211,238,0.5); box-shadow: inset 0 0 0 1px rgba(34,211,238,0.35); }
    #shop-rec-price { cursor: pointer; }
    #shop-rec-price:hover { filter: brightness(1.06); border-color: rgba(34,211,238,0.5); box-shadow: inset 0 0 0 1px rgba(34,211,238,0.35); }
    /* Premium Colors (Shop) */
    #shop-card-premium { grid-column: 1 / -1; align-items: center; text-align: center; }
    .shop-palette-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(36px, 1fr));
      gap: 8px;
      align-items: start;
      width: 100%;
    }
    .shop-palette-swatch {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.2);
    }
    .shop-palette-swatch:hover { filter: brightness(1.06); }
    .shop-palette-swatch.selected {
      outline: 2px solid #22d3ee;
      outline-offset: 0;
      border-color: #22d3ee;
      box-shadow: 0 0 0 2px rgba(34,211,238,0.25);
    }
    .shop-palette-swatch.disabled { opacity: 0.55; pointer-events: none; }
    .shop-palette-swatch.transparent {
      background-color: #bbb;
      background-image:
        linear-gradient(45deg, #888 25%, transparent 25%),
        linear-gradient(-45deg, #888 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #888 75%),
        linear-gradient(-45deg, transparent 75%, #888 75%);
      background-size: 8px 8px;
      background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
    }
    .modal-tabs {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin: 0 0 12px 0;
    }
    .tab-button.active {
      background: rgba(255,255,255,0.08);
      border-color: rgba(34,211,238,0.35);
      box-shadow: inset 0 0 0 1px rgba(34,211,238,0.25);
    }
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      position: absolute;
      right: 20px;
      bottom: 16px;
      left: 20px;
    }
    .modal-body { padding-bottom: 56px; min-height: 300px; max-height: 400px; overflow-y: auto; }
    .modal-footer.split { justify-content: space-between; }
    .accounts-actions { display: flex; justify-content: flex-end; margin-bottom: 8px; margin-right: 10px; }
    #btn-check-all { margin-left: 8px; }
    .app-btn .spin-indicator { display: none; margin-left: 6px; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .app-btn.spinning .spin-indicator { display: inline-block; animation: spin 1s linear infinite; }
    .modal-card .form-grid {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 10px 12px;
    }
    .modal-card .form-grid label { font-size: 14px; align-self: center; }
    .modal-card .form-grid input { width: 100%; }
    .table-actions { display: flex; flex-direction: column; gap: 6px; }
    .table-actions-row { display: flex; gap: 6px; }
    .table-actions-row .app-btn { flex: 1 1 0; min-width: 0; }
    
    #app-toast-container { position: fixed; top: 16px; right: 16px; display: flex; flex-direction: column; gap: 10px; z-index: 2000; pointer-events: none; }
    .app-toast { pointer-events: auto; min-width: 260px; max-width: 380px; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15); box-shadow: 0 8px 30px rgba(0,0,0,0.35); backdrop-filter: blur(6px); color: #fff; display: flex; align-items: center; gap: 10px; animation: toast-in 200ms ease-out; }
    .app-toast.error { background: rgba(190, 24, 24, 0.9); }
    .app-toast.success { background: rgba(22, 163, 74, 0.9); }
    .app-toast .app-toast-message { flex: 1 1 auto; font-size: 14px; line-height: 1.35; }
    .app-toast .app-toast-close { display: inline-flex; align-items: center; justify-content: center; width: 26px; height: 26px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.15); background: rgba(0,0,0,0.35); color: #e5e7eb; cursor: pointer; }
    .app-toast.hide { animation: toast-out 250ms ease-in forwards; }
    @keyframes toast-in { from { transform: translateY(-8px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    @keyframes toast-out { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-8px); opacity: 0; } }
    
    #control-panel {
      position: relative;
      background: rgba(17, 20, 24, 0.85);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      padding: 10px 12px;
      width: auto;
      min-width: 280px;
      max-width: min(90vw, 520px);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      z-index: 1001;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      pointer-events: auto;
    }
    #control-panel .controls-row {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 8px;
    }
    #ready-popup {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      background: rgba(17, 20, 24, 0.95);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      padding: 10px;
      z-index: 1002;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 280px;
      max-width: min(90vw, 520px);
    }
      #ready-popup .ready-header {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
      }
    #ready-account-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 220px;
      overflow-y: auto;
      padding: 8px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      background: rgba(0,0,0,0.35);
    }
    #ready-pixel {
      display: inline-block;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.15);
      color: #e5e7eb;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 12px;
      white-space: normal;
      text-align: center;
    }
    #ready-popup .controls-row { justify-content: center; gap: 10px; }
    #ready-token-input { width: 320px; }
    #select-mode-controls { justify-content: center; }
    .select-mode-wrap { display: inline-flex; align-items: center; gap: 8px; justify-content: center; flex: 1; }
    .select-mode-label { font-size: 12px; color: #e5e7eb; opacity: 0.8; cursor: pointer; user-select: none; }
    .select-mode-label.active { color: #22d3ee; opacity: 1; }
    .select-mode-track { position: relative; width: 44px; height: 24px; border-radius: 9999px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.15); cursor: pointer; padding: 0; }
    .select-mode-knob { position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; border-radius: 9999px; background: #e5e7eb; transition: transform 0.18s ease; }
    .select-mode-track.on { background: rgba(34,211,238,0.35); border-color: rgba(34,211,238,0.45); }
    .select-mode-track.on .select-mode-knob { transform: translateX(20px); }
    .shop-auto-wrap { margin-top: 6px; display: flex; align-items: center; justify-content: center; gap: 6px; }
    /* Auto mode controls reuse select-mode styles */
    #auto-mode-controls { justify-content: center; }
    .toggle { position: relative; display: inline-block; width: 44px; height: 24px; }
    .toggle input { opacity: 0; width: 0; height: 0; }
    .toggle .slider { position: absolute; inset: 0; border-radius: 9999px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.15); cursor: pointer; transition: background-color 0.15s ease, border-color 0.15s ease; }
    .toggle .slider::before { content: ''; position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; border-radius: 9999px; background: #e5e7eb; transition: transform 0.18s ease; }
    .toggle input:checked + .slider { background: rgba(34,211,238,0.35); border-color: rgba(34,211,238,0.45); }
    .toggle input:checked + .slider::before { transform: translateX(20px); }
    
    #color-palette {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(17, 20, 24, 0.85);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      padding: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      max-width: min(95vw, 720px);
    }
    /* Premium/Free switcher next to palette (toggle style) */
    .palette-mode-wrap { position: fixed; z-index: 1002; display: inline-flex; align-items: center; gap: 10px; pointer-events: auto; padding: 6px 10px; border-radius: 12px; background: rgba(17, 20, 24, 0.85); border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 8px 30px rgba(0,0,0,0.35); backdrop-filter: blur(6px); }
    @media (max-width: 760px){ .palette-mode-wrap { bottom: 128px !important; } }
    .palette-mode-label { font-size: 12px; color: #e5e7eb; opacity: 0.95; cursor: pointer; user-select: none; }
    .palette-mode-label.active { color: #22d3ee; opacity: 1; }
    .palette-mode-track { position: relative; width: 44px; height: 24px; border-radius: 9999px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.15); cursor: pointer; padding: 0; }
    .palette-mode-knob { position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; border-radius: 9999px; background: #e5e7eb; transition: transform 0.18s ease; }
    .palette-mode-track.on .palette-mode-knob { transform: translateX(20px); }
    .palette-swatch {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.15);
      cursor: pointer;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.2);
    }
    .palette-swatch:hover { filter: brightness(1.1); }
    .palette-swatch.selected {
      outline: 2px solid #22d3ee;
      outline-offset: 0;
      border-color: #22d3ee;
      box-shadow: 0 0 0 2px rgba(34,211,238,0.25);
    }
    .palette-swatch.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .palette-swatch.transparent {
      background-color: rgba(255,255,255,0.06);
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none'><rect x='3' y='5' width='18' height='14' rx='2' ry='2' stroke='%23e5e7eb' stroke-width='2'/><path d='M7 15l3-3 3 4 3-3 3 4H7z' fill='%23e5e7eb'/><circle cx='9' cy='9' r='2' fill='%23e5e7eb'/></svg>");
      background-repeat: no-repeat;
      background-position: center;
      background-size: 80% 80%;
    }
    .palette-swatch.block {
      background-color: #bbb;
      background-image:
        linear-gradient(45deg, #888 25%, transparent 25%),
        linear-gradient(-45deg, #888 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #888 75%),
        linear-gradient(-45deg, transparent 75%, #888 75%);
      background-size: 8px 8px;
      background-position: 0 0, 0 4px, 4px -4px, -4px 0px;
    }
    .modal-palette-swatch.transparent {
      background-color: rgba(255,255,255,0.06);
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none'><rect x='3' y='5' width='18' height='14' rx='2' ry='2' stroke='%23e5e7eb' stroke-width='2'/><path d='M7 15l3-3 3 4 3-3 3 4H7z' fill='%23e5e7eb'/><circle cx='9' cy='9' r='2' fill='%23e5e7eb'/></svg>");
      background-repeat: no-repeat;
      background-position: center;
      background-size: 80% 80%;
    }
    /* Styles for the eraser button */
    #eraser-button {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(calc(50% + 80px)); /* Adjust 80px based on color-palette width / 2 + gap */
      background: rgba(17, 20, 24, 0.85);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      width: 44px; /* Adjust as needed */
      height: 44px; /* Adjust as needed */
      cursor: pointer;
    }

    #eraser-button.active {
      border-color: #22d3ee;
      box-shadow: 0 0 0 2px rgba(34,211,238,0.25);
    }

    #eraser-button svg {
      width: 24px;
      height: 24px;
    }
    
    #lang-switch {
      position: fixed;
      top: 16px;
      left: 180px;
      z-index: 1001;
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(17, 20, 24, 0.85);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      padding: 6px 8px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
    }
    #lang-select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.25);
      color: #e5e7eb;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    /* Modern custom dropdown for language switch */
    .lang-dropdown { position: relative; width: 100%; }
    .lang-button {
      width: 100%;
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      color: #e5e7eb;
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(6px);
      cursor: pointer;
    }
    .lang-button:focus-visible { outline: 3px solid rgba(59,130,246,0.4); outline-offset: 2px; }
    .lang-button .chev { width: 12px; height: 12px; opacity: 0.85; transition: transform .12s ease; }
    .lang-menu {
      position: absolute; left: 0; right: 0; top: calc(100% + 8px);
      background: rgba(17, 20, 24, 0.95);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 6px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      display: none;
      max-height: 280px;
      overflow: auto;
      z-index: 1002;
    }
    .lang-menu.open { display: block; animation: dropdown-in 140ms ease-out; }
    @keyframes dropdown-in { from { opacity: 0; transform: translateY(-4px) scale(0.98); } to { opacity: 1; transform: translateY(0) scale(1); } }
    .lang-item {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 8px;
      background: transparent;
      color: #e5e7eb;
      border: 0;
      cursor: pointer;
      text-align: left;
      font-size: 13px;
    }
    .lang-item:hover { background: rgba(255,255,255,0.08); }
    .lang-item[aria-selected="true"] { background: rgba(59,130,246,0.18); border: 1px solid rgba(59,130,246,0.35); }
    
    /* Favorites UI */
    #favorites-modal, #save-fav-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.45);
      z-index: 1100;
    }
    #favorites-modal[hidden], #save-fav-modal[hidden] { display: none; }
    #favorites-list .favorite-item { display: flex; justify-content: space-between; align-items: center; gap: 8px; margin-bottom: 8px; }
    #btn-favorite-star { font-size: 16px; padding: 6px 8px; }
    #btn-favorite-star.saved { color: gold; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <img id="sign" alt="sign" draggable="false" hidden />
  <img id="pixel-hover" class="pixel-marker" alt="hover" hidden />
  <canvas id="selection-overlay"></canvas>
  <canvas id="dim-overlay"></canvas> <!-- Add dim-overlay -->
  <div id="pixel-selected-list" hidden></div>
  <div id="range-overlay" hidden></div>
  <div id="top-toolbar">
    <div id="total-droplets-info" class="app-btn modal-right-info" style="position:static; margin-right:auto; margin-left: 0; pointer-events: none;" data-i18n-dynamic="droplets.totalLabel" data-count="0">💧 Tổng Droplets: -</div>
  <div id="sound-control">
    <button id="sound-toggle" class="app-btn" type="button" title="" aria-label="">🔊</button>
    <div class="sound-slider" role="group" aria-label="Ses ayarı">
      <div style="display:flex;flex-direction:column;align-items:center;gap:6px;color:#e5e7eb;opacity:0.9;font-size:12px">
        <span data-i18n=""></span>
        <div id="sound-volume" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100" aria-label="Volume">
          <div class="slider-track"></div>
          <div class="slider-fill"></div>
          <div class="slider-thumb"></div>
        </div>
      </div>
    </div>
  </div>
    <div id="control-panel">
      <div class="controls-row">
        <button id="btn-accounts" class="app-btn" type="button" data-i18n="nav.accounts">Hesaplar</button>
        <div id="pixel-power" role="status" aria-live="polite" data-i18n-dynamic="pixel.powerLabel" data-count="0" data-max="0">Piksel gücü: 0 / 0</div>
      </div>
      <div>
        <button id="btn-ready" class="app-btn" type="button" disabled data-i18n="ready.prepare">Hazırlan</button>
        <div id="ready-popup" hidden>
          <div class="ready-header">
            <button id="btn-ready-account" class="app-btn" type="button" data-i18n="ready.selectAccount">Hesap seç</button>
            <div id="ready-pixel" role="status" aria-live="polite" data-i18n-dynamic="pixel.powerLabel" data-count="0" data-max="0">Piksel gücü: 0 / 0</div>
          </div>
          <div class="controls-row" id="auto-mode-controls">
            <div class="select-mode-wrap">
              <span id="auto-mode-label-left" class="select-mode-label" data-i18n="ready.autoMode.off">Auto mode off</span>
              <button id="auto-mode-toggle" class="select-mode-track" type="button" role="switch" aria-checked="false" aria-label="Auto mode">
                <span class="select-mode-knob"></span>
              </button>
              <span id="auto-mode-label-right" class="select-mode-label" data-i18n="ready.autoMode.on">Auto mode on</span>
            </div>
            <div class="select-mode-wrap" style="margin-left:12px;">
              <span id="auto-start-label-left" class="select-mode-label" data-i18n="ready.autoStart.off">Auto start off</span>
              <button id="auto-start-toggle" class="select-mode-track" type="button" role="switch" aria-checked="false" aria-label="Auto start on token">
                <span class="select-mode-knob"></span>
              </button>
              <span id="auto-start-label-right" class="select-mode-label" data-i18n="ready.autoStart.on">Auto start on</span>
            </div>
            <div class="select-mode-wrap" style="margin-left:12px;">
              <span id="advanced-paint-label-left" class="select-mode-label" data-i18n="ready.advancedPaint.off">Advanced Paint (Tắt)</span>
              <button id="advanced-paint-toggle" class="select-mode-track" type="button" role="switch" aria-checked="false" aria-label="Advanced Paint">
                <span class="select-mode-knob"></span>
              </button>
              <span id="advanced-paint-label-right" class="select-mode-label" data-i18n="ready.advancedPaint.on">Advanced Paint (Bật)</span>
            </div>
          </div>
          <div id="ready-account-list" hidden></div>
          <div class="controls-row" hidden>
            <button id="btn-auto-select-accounts" class="app-btn" type="button" data-i18n="ready.autoSelectAccounts">Auto select account</button>
          </div>
          <div class="controls-row">
            <input id="ready-token-input" type="text" placeholder="Token" data-i18n-placeholder="ready.tokenPlaceholder" />
          </div>
          <div class="controls-row">
            <button id="btn-auto-select" class="app-btn" type="button" data-i18n="ready.autoSelect">Otomatik seç</button>
            <button id="start" class="app-btn" type="button" data-i18n="ready.start">Başlat</button>
          </div>
          <div id="overlay-section">
            <div class="controls-row">
              <span>Overlays</span>
              <button id="btn-add-overlay" class="app-btn" type="button" aria-label="Add overlay" style="padding: 4px 8px; font-size: 14px;">+</button>
            </div>
             <div id="overlay-list" class="overlay-list">
             </div>
           </div>
          <div class="controls-row" id="select-mode-controls">
            <div class="select-mode-wrap">
              <span id="select-mode-label-left" class="select-mode-label active" data-i18n="ready.selectMode.multi">Önce çok yerden seç</span>
              <button id="select-mode-toggle" class="select-mode-track" type="button" role="switch" aria-checked="false" aria-label="Select mode">
                <span class="select-mode-knob"></span>
              </button>
              <span id="select-mode-label-right" class="select-mode-label" data-i18n="ready.selectMode.frame">Önce çerçeveyi seç</span>
            </div>
          </div>
          <div id="auto-paint-settings" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
            <div class="controls-row">
              <span style="font-weight: bold;">Auto Paint Settings</span>
            </div>
            <div class="controls-row" style="margin-top: 8px; flex-direction: column; align-items: flex-start;">
              <span style="font-weight: bold;">Color Priority List</span>
              <div id="color-priority-list" style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; width: 100%; min-height: 30px; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 6px;">
                <!-- Priority color swatches will be added here -->
              </div>
              <div class="controls-row" style="margin-top: 8px; justify-content: flex-start; width: 100%;">
                <button id="add-priority-color-btn" class="app-btn" type="button" style="padding: 4px 8px; font-size: 14px;">+</button>
                <button id="pick-color-tool-btn" class="app-btn" type="button" style="padding: 4px 8px; font-size: 14px;">Pick Color</button>
                <button id="clear-priority-list-btn" class="app-btn" type="button" style="padding: 4px 8px; font-size: 14px;">Clear List</button>
              </div>
            </div>
            <div class="controls-row" style="margin-top: 8px; flex-direction: column; align-items: flex-start;">
              <span style="font-weight: bold;">Broken Pixel Priority Colors</span>
              <div id="broken-pixel-priority-list" style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; width: 100%; min-height: 30px; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 6px;">
                <!-- Broken pixel priority color swatches will be added here -->
              </div>
              <div class="controls-row" style="margin-top: 8px; justify-content: flex-start; width: 100%;">
                <button id="add-broken-pixel-color-btn" class="app-btn" type="button" style="padding: 4px 8px; font-size: 14px;">+</button>
                <button id="pick-broken-pixel-color-tool-btn" class="app-btn" type="button" style="padding: 4px 8px; font-size: 14px;">Pick Color</button>
                <button id="clear-broken-pixel-list-btn" class="app-btn" type="button" style="padding: 4px 8px; font-size: 14px;">Clear List</button>
              </div>
            </div>

            <div class="controls-grid" style="margin-top: 8px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
              <div class="controls-row" style="align-items: center;">
                <div class="select-mode-wrap">
                  <span class="select-mode-label">Broken Pixel Paint</span>
                  <button id="broken-pixel-paint-toggle" class="select-mode-track" type="button" role="switch" aria-checked="false" aria-label="Broken Pixel">
                    <span class="select-mode-knob"></span>
                  </button>
                </div>
              </div>
              <div class="controls-row" style="align-items: center;">
                <div class="select-mode-wrap">
                  <span class="select-mode-label">Priority Color Paint</span>
                  <button id="priority-color-paint-toggle" class="select-mode-track" type="button" role="switch" aria-checked="false" aria-label="Priority Color">
                    <span class="select-mode-knob"></span>
                  </button>
                </div>
              </div>
              <div class="controls-row" style="align-items: center;">
                <div class="select-mode-wrap">
                  <span class="select-mode-label">Chess Pattern Paint</span>
                  <button id="chess-paint-toggle" class="select-mode-track" type="button" role="switch" aria-checked="false" aria-label="Chess Pattern Paint">
                    <span class="select-mode-knob"></span>
                  </button>
                </div>
              </div>
              <div class="controls-row" style="align-items: center;">
                <div class="select-mode-wrap">
                  <span class="select-mode-label">Limit to Overlay Area</span>
                  <button id="limit-overlay-toggle" class="select-mode-track" type="button" role="switch" aria-checked="false" aria-label="Limit to Overlay Area">
                    <span class="select-mode-knob"></span>
                  </button>
                </div>
              </div>
            </div>

            <div class="controls-row" style="margin-top: 8px;">
              <span class="select-mode-label">Minizine to Detect (pixels)</span>
              <input type="number" id="minizine-to-detect-input" value="4" min="1" max="100" style="width: 60px; margin-left: 8px;">
            </div>

            <div class="controls-row" style="margin-top: 8px;">
              <button id="remove-duplicates-btn" class="app-btn" type="button">Remove Duplicates</button>
            </div>

          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="sign-layer" hidden>
    <div id="sign-outline"></div>
  </div>
  <input id="sign-file" type="file" accept="image/png,image/jpeg,image/webp,image/gif" multiple hidden />
  <aside id="sidebar"><div id="counter" class="counter"></div><div id="thumb-list"></div></aside>
  <div id="accounts-modal" hidden>
    <div class="modal-card">
      <button id="accounts-close" class="modal-close app-btn" title="Kapat" type="button" data-i18n-title="modal.closeTitle">×</button>
      <div class="modal-tabs">
        <button id="btn-shop-back" class="app-btn modal-back" type="button" data-i18n="buttons.back" hidden>Geri</button>
        <button id="tab-accounts" class="tab-button active" type="button" data-i18n="tabs.accounts">Hesaplar</button>
        
        <div id="shop-droplets-info" class="app-btn modal-right-info" hidden>💧 Droplets: -</div>
      </div>
      <div class="modal-body">
        <div id="accounts-section">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; justify-content: flex-start;">
            <label for="update-interval-input" data-i18n="settings.updateIntervalMinutes">Update Interval (minutes):</label>
            <input type="number" id="update-interval-input" min="1" value="5" style="width: 80px;" />
          </div>
          <div class="accounts-actions">
            <button id="btn-account-add" class="app-btn" type="button" data-i18n="accounts.add">Hesap ekle</button>
            <button id="btn-check-all" class="app-btn" type="button" data-i18n-title="accounts.checkAllTitle"><span class="label" data-i18n="accounts.checkAll">Check All Accounts</span> <span class="spin-indicator">⟳</span></button>
          </div>
          <div class="table-responsive">
            <table id="accounts-table" class="table table-dark table-striped table-hover table-sm align-middle mb-2">
              <thead>
                <tr>
                  <th data-i18n="table.accountName">Hesap ismi</th>
                  <th data-i18n="table.accountToken">Hesap Tokeni</th>
                  <th data-i18n="table.droplets">Droplets</th>
                  <th data-i18n="table.pixelRight">Piksel Hakkı</th>
                  <th data-i18n="table.status">Durum</th>
                  <th data-i18n="table.actions">İşlem</th>
                </tr>
              </thead>
              <tbody id="accounts-tbody"></tbody>
            </table>
          </div>
        </div>
        <div id="account-form-section" hidden>
          <div class="form-grid">
            <label for="account-name-input" data-i18n="form.accountNameLabel">Hesap adı</label>
            <input id="account-name-input" type="text" placeholder="Örn: Ana hesap" data-i18n-placeholder="form.accountNamePlaceholder" />
            <label for="account-token-input" data-i18n="form.accountTokenLabel">Hesap tokeni</label>
            <input id="account-token-input" type="text" placeholder="Örn: eyJhbGciOi..." data-i18n-placeholder="form.accountTokenPlaceholder" />
            <label for="account-cf-input">cf_clearance</label>
            <input id="account-cf-input" type="text" placeholder="cf_clearance" />
            <input id="account-id-input" type="hidden" />
            <label for="account-active-toggle">Active</label>
            <label class="toggle" aria-label="Active">
              <input id="account-active-toggle" type="checkbox" checked />
              <span class="slider"></span>
            </label>
          </div>
          <div class="modal-footer split">
            <button id="btn-account-cancel" class="app-btn" type="button" data-i18n="buttons.back">Geri</button>
            <button id="btn-account-save" class="app-btn" type="button" data-i18n="buttons.add">Ekle</button>
          </div>
        </div>
        <div id="shop-view-section" hidden>
          <div class="shop-header">
            <div class="shop-title" data-i18n="shop.itemsTitle">Items</div>
            <div class="shop-sub" data-i18n="shop.itemsSub">Get more charges</div>
          </div>
          <div class="shop-grid">
            <div class="shop-card" id="shop-card-max">
              <div class="shop-icon">⬆️</div>
              <div id="shop-max-name" class="shop-name" data-i18n="shop.maxTitle">+5 Max. Charges</div>
              <div class="shop-desc" data-i18n="shop.maxDesc">Increase your maximum paint charges capacity</div>
              <div class="shop-qty-row">
                <button class="app-btn shop-qty-btn" id="shop-max-dec" type="button">-</button>
                <div class="shop-qty-val" id="shop-max-qty">1</div>
                <button class="app-btn shop-qty-btn" id="shop-max-inc" type="button">+</button>
                <button class="app-btn shop-qty-btn" id="shop-max-max" type="button">MAX</button>
              </div>
              <div class="shop-pill" id="shop-max-price" role="button" tabindex="0">💧 500 Droplets</div>
              <div class="shop-auto-wrap">
                <span class="select-mode-label" data-i18n="shop.autoBuy">Auto-buy</span>
                <button class="select-mode-track" id="shop-max-auto" type="button" role="switch" aria-checked="false" aria-label="Auto-buy"><span class="select-mode-knob"></span></button>
              </div>
            </div>
            <div class="shop-card" id="shop-card-recharge">
              <div class="shop-icon">🩸</div>
              <div id="shop-rec-name" class="shop-name" data-i18n="shop.recTitle">+30 Paint Charges</div>
              <div class="shop-desc" data-i18n="shop.recDesc">Recharge paint charges</div>
              <div class="shop-qty-row">
                <button class="app-btn shop-qty-btn" id="shop-rec-dec" type="button">-</button>
                <div class="shop-qty-val" id="shop-rec-qty">1</div>
                <button class="app-btn shop-qty-btn" id="shop-rec-inc" type="button">+</button>
                <button class="app-btn shop-qty-btn" id="shop-rec-max" type="button">MAX</button>
              </div>
              <div class="shop-pill" id="shop-rec-price">💧 500 Droplets</div>
              <div class="shop-auto-wrap">
                <span class="select-mode-label" data-i18n="shop.autoBuy">Auto-buy</span>
                <button class="select-mode-track" id="shop-rec-auto" type="button" role="switch" aria-checked="false" aria-label="Auto-buy"><span class="select-mode-knob"></span></button>
              </div>
            </div>
            <div class="shop-card" id="shop-card-premium">
              <div class="shop-icon">🌈</div>
              <div class="shop-name" data-i18n="shop.premiumTitle">Premium Colors</div>
              <div class="shop-desc" data-i18n="shop.purchased">Purchased colors</div>
              <div id="shop-premium-owned" class="shop-palette-grid" aria-label="Owned premium colors"></div>
              <div class="shop-desc" style="margin-top:8px;" data-i18n="shop.exclusive">Exclusive palette</div>
              <div id="shop-premium-palette" class="shop-palette-grid" aria-label="Premium color palette"></div>
              <div id="shop-premium-buy" class="shop-pill" role="button" tabindex="0" data-i18n="shop.buyPremium">💧 2000 Droplets</div>
            </div>
          </div>
        </div>
        
      </div>
    </div>
  </div>

  <div id="img-preview-modal" hidden>
    <div class="modal-card" style="width:min(720px,95vw);max-width:95vw;">
      <button id="img-preview-close" class="modal-close app-btn" title="Kapat" type="button" data-i18n-title="modal.closeTitle">×</button>
      <div class="modal-header" data-i18n="form.uploadImage">Resim yükle</div>
      <div class="modal-body">
        <canvas id="img-preview-canvas" width="540" height="300" aria-label="Image preview"></canvas>
        <div class="img-preview-flex">
          <div>
            <div class="img-preview-grid">
              <label for="img-scale" data-i18n="preview.scale">Ölçek (%)</label>
              <input id="img-scale" type="number" min="1" max="800" step="1" value="100" />
              <label for="img-keep-ratio" data-i18n="preview.keepRatio">Oranı koru</label>
              <label class="toggle" aria-label="Keep ratio">
                <input id="img-keep-ratio" type="checkbox" checked />
                <span class="slider"></span>
              </label>
              <label for="img-width" data-i18n="preview.width">Genişlik</label>
              <input id="img-width" type="number" min="1" max="1000" step="1" />
              <label for="img-height" data-i18n="preview.height">Yükseklik</label>
              <input id="img-height" type="number" min="1" max="1000" step="1" />
              <!-- img-template-x and img-template-y moved and resized -->
              <label for="img-template-x" data-i18n="template.xCoord">X:</label>
              <input id="img-template-x" type="number" step="1" value="0" style="width: 80px;" />
              <label for="img-template-y" data-i18n="template.yCoord">Y:</label>
              <input id="img-template-y" type="number" step="1" value="0" style="width: 80px;" />
              
              <label for="img-color-conversion-toggle" data-i18n="preview.colorConversion">Color Conversion</label>
              <button id="img-color-conversion-toggle" class="app-btn" type="button" data-state="on" data-i18n="preview.colorConversionOn">Color Conversion: ON</button>

              <label for="img-alpha-input" data-i18n="preview.alphaThreshold">Transparency</label>
              <input id="img-alpha-input" type="number" min="0" max="255" step="1" value="5" />
              <label for="img-color-metric" data-i18n="preview.colorMetric">Color algorithm</label>
              <select id="img-color-metric">
                <option value="oklab" data-i18n="preview.metricOklab" selected>Oklab</option>
                <option value="rgb" data-i18n="preview.metricRgb">RGB (fast)</option>
                <option value="lab" data-i18n="preview.metricLab">Lab (CIE76)</option>
                <option value="ciede2000" data-i18n="preview.metricCiede2000">CIEDE2000 (more accurate, slower)</option>
              </select>
              <label for="img-dither-toggle" data-i18n="preview.dithering">Dithering</label>
              <button id="img-dither-toggle" class="app-btn" type="button" data-state="off" data-i18n="preview.ditheringOff">Dithering: OFF</button>
            </div>
          </div>
          <div id="img-fill-side">
            <div class="row">
              <label for="img-fill-toggle" data-i18n="preview.fillBackground" style="margin-right:8px;">Arka planı doldur</label>
              <label class="toggle" aria-label="Fill background" style="justify-self:start;">
                <input id="img-fill-toggle" type="checkbox" />
                <span class="slider"></span>
              </label>
            </div>
            <div class="row color-row">
              <label for="img-fill-color" data-i18n="preview.color">Renk</label>
              <div id="img-fill-color" aria-disabled="true"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="img-preview-cancel" class="app-btn" type="button" data-i18n="buttons.back">Geri</button>
        <button id="img-preview-apply" class="app-btn" type="button" data-i18n="preview.addToMap">Haritaya ekle</button>
      </div>
    </div>
  </div>

  

  <form class="panel" id="form">
    <button class="app-btn" type="button" id="btn-open-favorites" title="Favoriler" data-i18n-title="favorites.openTitle">📁</button>
    <button class="app-btn" type="button" id="btn-favorite-star" title="Kaydet" data-i18n-title="favorites.starTitle">★</button>
    <label for="area-code" data-i18n="form.worldXLabel">World X</label>
    <input id="area-code" name="area code" type="number" min="0" step="1" inputmode="numeric" />

    <label for="no" data-i18n="form.worldYLabel">World Y</label>
    <input id="no" name="no" type="number" min="0" step="1" inputmode="numeric" />

    <button class="app-btn" type="submit" data-i18n="form.fetchButton">Getir</button>
    <button class="app-btn" type="button" id="btn-upload-sign" data-i18n="form.uploadImage">Resim yükle</button>
    <!-- "Upload Template" button is hidden as requested -->
    <button class="app-btn" type="button" id="btn-upload-template" hidden>Upload Template</button>
  </form>
  <!-- Input file for template is hidden and disabled as requested -->
  <input id="template-file" type="file" accept="image/png,image/jpeg,image/webp,image/gif" hidden disabled />
 
  <div id="app-toast-container" aria-live="polite" aria-atomic="true"></div>
  <div id="color-palette" aria-label="Renk paleti" role="group" data-i18n-aria-label="labels.colorPalette"></div>
   <!-- Eraser Button -->
   <button id="eraser-button" class="btn btn-lg btn-square shadow-md" title="Tẩy">
     <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" fill="currentColor" class="size-5"><path d="M690-240h190v80H610l80-80Zm-500 80-85-85q-23-23-23.5-57t22.5-58l440-456q23-24 56.5-24t56.5 23l199 199q23 23 23 57t-23 57L520-160H190Zm296-80 314-322-198-198-442 456 64 64h262Zm-6-240Z"/></svg>
   </button>
  <div id="palette-mode" class="palette-mode-wrap" aria-label="Palette mode" style="bottom:76px; left:50%; transform:translateX(-50%); visibility:hidden;">
    <span id="palette-mode-label-left" class="palette-mode-label active" data-i18n="paletteMode.premium">Use premium color</span>
    <button id="palette-mode-toggle" class="palette-mode-track" type="button" role="switch" aria-checked="true" aria-label="Palette mode"><span class="palette-mode-knob"></span></button>
    <span id="palette-mode-label-right" class="palette-mode-label" data-i18n="paletteMode.free">Use free color</span>
  </div>

  <div id="move-control">
    <button id="btn-movement" class="app-btn" type="button" data-i18n="controls.movement">Hareket</button>
    <div id="movement-popup" hidden>
      <div class="movement-grid">
        <span></span>
        <button id="move-up" class="app-btn dir-btn" type="button" title="Yukarı" aria-label="Yukarı" data-i18n-title="movement.up" data-i18n-aria-label="movement.up">▲</button>
        <span></span>
        <button id="move-left" class="app-btn dir-btn" type="button" title="Sola" aria-label="Sola" data-i18n-title="movement.left" data-i18n-aria-label="movement.left">◄</button>
        <span></span>
        <button id="move-right" class="app-btn dir-btn" type="button" title="Sağa" aria-label="Sağa" data-i18n-title="movement.right" data-i18n-aria-label="movement.right">►</button>
        <span></span>
        <button id="move-down" class="app-btn dir-btn" type="button" title="Aşağı" aria-label="Aşağı" data-i18n-title="movement.down" data-i18n-aria-label="movement.down">▼</button>
        <span></span>
      </div>
    </div>
  </div>
  <div id="favorites-modal" hidden>
    <div class="modal-card">
      <div class="modal-header" data-i18n="favorites.title">Favoriler</div>
      <button id="favorites-close" class="modal-close app-btn" type="button" data-i18n-title="modal.closeTitle">×</button>
      <div class="modal-body" id="favorites-list"></div>
    </div>
  </div>

  <div id="save-fav-modal" hidden>
    <div class="modal-card">
      <div class="modal-header" data-i18n="favorites.saveTitle">Konumu kaydet</div>
      <button id="save-fav-close" class="modal-close app-btn" type="button" data-i18n-title="modal.closeTitle">×</button>
      <div class="modal-body">
        <label for="fav-name-input" data-i18n="favorites.nameLabel">Ad</label>
        <input id="fav-name-input" type="text" />
      </div>
      <div class="modal-footer">
        <button id="fav-save-btn" class="app-btn" type="button" data-i18n="buttons.save">Kaydet</button>
      </div>
    </div>
  </div>
  <script>
    
    const I18N_DEFAULT_LANG = 'en';
    let I18N_LANG = I18N_DEFAULT_LANG;
    let I18N_STRINGS = {};
    const LANGS = [
      { value: 'tr', label: 'Türkçe' },
      { value: 'en', label: 'English' },
      { value: 'vi', label: 'Tiếng Việt' },
      { value: 'de', label: 'Deutsch' },
      { value: 'es', label: 'Español' },
      { value: 'fr', label: 'Français' },
      { value: 'ru', label: 'Русский' },
      { value: 'cn', label: '中文' },
      { value: 'ja', label: '日本語' }
    ];
    function getSavedLang(){ try { return localStorage.getItem('lang') || I18N_DEFAULT_LANG; } catch { return I18N_DEFAULT_LANG; } }
    function saveLang(lang){ try { localStorage.setItem('lang', lang); } catch {} }
    async function loadI18n(lang){
      try {
        const res = await fetch('/i18n/' + encodeURIComponent(lang) + '.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('i18n load failed');
        I18N_STRINGS = await res.json();
      } catch {
        I18N_STRINGS = {};
      }
    }
    function t(key, vars){
      const parts = String(key || '').split('.');
      let cur = I18N_STRINGS;
      for (let i = 0; i < parts.length; i++) {
        const k = parts[i];
        if (cur && Object.prototype.hasOwnProperty.call(cur, k)) cur = cur[k]; else { cur = null; break; }
      }
      let s = (typeof cur === 'string') ? cur : String(key || '');
      if (vars && typeof s === 'string') {
        s = s.replace(/\{(\w+)\}/g, (m, k) => (vars && vars[k] != null ? String(vars[k]) : ''));
      }
      return s;
    }
    function applyTranslations(){
      try { document.documentElement.lang = I18N_LANG; } catch {}
      document.querySelectorAll('[data-i18n]').forEach(el => {
        try { el.textContent = t(el.getAttribute('data-i18n')); } catch {}
      });
      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        try { el.setAttribute('placeholder', t(el.getAttribute('data-i18n-placeholder'))); } catch {}
      });
      document.querySelectorAll('[data-i18n-title]').forEach(el => {
        try { el.setAttribute('title', t(el.getAttribute('data-i18n-title'))); } catch {}
      });
      document.querySelectorAll('[data-i18n-aria-label]').forEach(el => {
        try { el.setAttribute('aria-label', t(el.getAttribute('data-i18n-aria-label'))); } catch {}
      });
      
      try {
        const p = document.getElementById('pixel-power');
        if (p) {
          const count = Number(p.getAttribute('data-count') || '0');
          const max = Number(p.getAttribute('data-max') || '0');
          p.textContent = t('pixel.powerLabel', { count, max });
        }
      } catch {}
      try {
        const rp = document.getElementById('ready-pixel');
        if (rp) {
          const count = Number(rp.getAttribute('data-count') || '0');
          const max = Number(rp.getAttribute('data-max') || '0');
          rp.textContent = t('pixel.powerLabel', { count, max });
        }
      } catch {}
      // Re-layout floating UI elements after text size changes
      try { layoutSoundControl(); } catch {}
      try { layoutLangSwitch(); } catch {}
    }
    async function setLanguage(lang){
      I18N_LANG = lang || I18N_DEFAULT_LANG;
      saveLang(I18N_LANG);
      await loadI18n(I18N_LANG);
      applyTranslations();
      refreshLangDropdown();
      try { if (typeof loadAccounts === 'function') { await loadAccounts(); } } catch {}
    }
    async function initI18n(){
      const initial = getSavedLang();
      await setLanguage(initial);
      const sel = document.getElementById('lang-select');
      if (sel) {
        try { sel.value = I18N_LANG; } catch {}
        sel.addEventListener('change', async () => { await setLanguage(sel.value); });
      }
    }
    const updateIntervalInput = document.getElementById('update-interval-input');
    if (updateIntervalInput) {
      updateIntervalInput.addEventListener('change', async (e) => {
        const value = parseInt(e.target.value, 10);
        if (isNaN(value) || value <= 0) {
          showToast(t('messages.invalidUpdateInterval'), 'error', 2000);
          return;
        }
        try {
          const res = await fetch('/api/settings/update-interval', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ updateIntervalMinutes: value })
          });
          if (res.ok) {
            showToast(t('messages.updateIntervalSaved'), 'success', 1500);
          } else {
            showToast(t('messages.updateIntervalSaveFailed'), 'error', 2500);
          }
        } catch (err) {
          showToast(t('messages.updateIntervalSaveFailed'), 'error', 2500);
        }
      });
    }

    
    function ensureToastContainer() {
      let el = document.getElementById('app-toast-container');
      if (!el) {
        el = document.createElement('div');
        el.id = 'app-toast-container';
        document.body.appendChild(el);
      }
      return el;
    }
    function showToast(message, variant = 'error', durationMs = 3000) {
      let container;
      try {
        container = ensureToastContainer();
        if (!container) {
          console.log('Error: Toast container not found or created.');
          return;
        }
      } catch (e) {
        console.error('Error ensuring toast container:', e);
        return;
      }
      const toast = document.createElement('div');
      toast.className = 'app-toast ' + variant;
      const msg = document.createElement('div');
      msg.className = 'app-toast-message';
      msg.textContent = message;
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'app-toast-close';
      btn.textContent = '×';
      btn.addEventListener('click', () => hideToast(toast));
      toast.appendChild(msg);
      toast.appendChild(btn);
      container.appendChild(toast);
      const t = setTimeout(() => hideToast(toast), durationMs);
      toast._timer = t;
    }
    function hideToast(toast) {
      if (!toast || toast.classList.contains('hide')) return;
      try { clearTimeout(toast._timer); } catch {}
      toast.classList.add('hide');
      toast.addEventListener('animationend', () => {
        try { toast.parentNode && toast.parentNode.removeChild(toast); } catch {}
      }, { once: true });
    }

    // Hàm throttle
    function throttle(func, delay) {
      let timeoutId = null;
      let lastArgs = null;
      let lastThis = null;

      return function(...args) {
        lastArgs = args;
        lastThis = this;

        if (!timeoutId) {
          timeoutId = setTimeout(() => {
            func.apply(lastThis, lastArgs);
            timeoutId = null;
            lastArgs = null;
            lastThis = null;
          }, delay);
        }
      };
    }

    // Moved from inside async IIFE for global accessibility and clarity
    function calculateTotalDroplets() {
        let totalDroplets = 0;
        if (Array.isArray(accountsData)) {
            for (let i = 0; i < accountsData.length; i++) {
                const account = accountsData[i];
                if (account && account.active !== false && Number.isFinite(account.droplets)) {
                    totalDroplets += account.droplets;
                }
            }
        }
        return totalDroplets;
    }

    function updateTotalDropletsDisplay() {
        const totalDropletsEl = document.getElementById('total-droplets-info');
        if (totalDropletsEl) {
            const total = calculateTotalDroplets();
            totalDropletsEl.textContent = t('droplets.totalLabel', { count: total });
            totalDropletsEl.hidden = false; // Always display when calculated
        }
    }
    
    function getLangLabel(code){ const f = LANGS.find(x => x.value === code); return f ? f.label : code; }
    function refreshLangDropdown(){
      try {
        const cur = document.getElementById('lang-current');
        if (cur) cur.textContent = getLangLabel(I18N_LANG);
        document.querySelectorAll('#lang-menu .lang-item').forEach(btn => {
          const v = btn.getAttribute('data-value');
          btn.setAttribute('aria-selected', String(v === I18N_LANG));
        });
        const sel = document.getElementById('lang-select');
        if (sel) sel.value = I18N_LANG;
      } catch {}
    }
    function ensureLangSwitch(){
      let el = document.getElementById('lang-switch');
      if (!el) {
        el = document.createElement('div');
        el.id = 'lang-switch';
        const wrap = document.createElement('div');
        wrap.className = 'lang-dropdown';
        wrap.innerHTML = '<button id="lang-button" class="lang-button" type="button" aria-haspopup="listbox" aria-expanded="false"><span id="lang-current"></span><svg class="chev" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M7 10l5 5 5-5z"/></svg></button><div id="lang-menu" class="lang-menu" role="listbox"></div><select id="lang-select" hidden></select>';
        el.appendChild(wrap);
        document.body.appendChild(el);
        const menu = wrap.querySelector('#lang-menu');
        const select = wrap.querySelector('#lang-select');
        LANGS.forEach(l => {
          const item = document.createElement('button');
          item.type = 'button';
          item.className = 'lang-item';
          item.setAttribute('role', 'option');
          item.setAttribute('data-value', l.value);
          const text = document.createElement('span');
          text.textContent = l.label;
          item.appendChild(text);
          menu.appendChild(item);
          const opt = document.createElement('option');
          opt.value = l.value; opt.textContent = l.label; select.appendChild(opt);
        });
      }
      return el;
    }
    function bindLangDropdownEvents(){
      const btn = document.getElementById('lang-button');
      const menu = document.getElementById('lang-menu');
      if (!btn || !menu) return;
      function open(){ menu.classList.add('open'); btn.setAttribute('aria-expanded', 'true'); }
      function close(){ menu.classList.remove('open'); btn.setAttribute('aria-expanded', 'false'); }
      function toggle(){ if (menu.classList.contains('open')) close(); else open(); }
      btn.addEventListener('click', (e) => { e.stopPropagation(); toggle(); });
      document.addEventListener('click', () => { if (menu.classList.contains('open')) close(); });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') close(); });
      menu.querySelectorAll('.lang-item').forEach(elm => {
        elm.addEventListener('click', async () => {
          const v = elm.getAttribute('data-value');
          await setLanguage(v);
          close();
        });
      });
    }
    function layoutLangSwitch(){
      const ls = document.getElementById('lang-switch');
      const sidebarEl = document.getElementById('sidebar');
      const formEl = document.getElementById('form');
      if (!ls || !sidebarEl || !formEl) return;
      const sb = sidebarEl.getBoundingClientRect();
      const fm = formEl.getBoundingClientRect();
      const y = Math.min(sb.top, fm.top) + 4; 
      const xLeft = sb.right + 12;
      const xRight = fm.left - 12;
      const center = (xLeft + xRight) / 2;
      const width = Math.min(220, Math.max(140, xRight - xLeft));
      try { ls.style.width = String(width) + 'px'; } catch {}
      try { ls.style.top = String(y) + 'px'; } catch {}
      try { ls.style.left = String(center - (width/2)) + 'px'; } catch {}
    }
    window.addEventListener('resize', layoutLangSwitch);
    window.addEventListener('scroll', layoutLangSwitch, { passive: true });

    function layoutSoundControl(){ /* CSS handles positioning now */ }
    window.addEventListener('resize', layoutSoundControl);
    window.addEventListener('scroll', layoutSoundControl, { passive: true });
    // Re-layout after fonts load to ensure correct measurements
    if (document.fonts && document.fonts.ready) { try { document.fonts.ready.then(() => layoutSoundControl()); } catch {} }
    // No JS positioning needed; kept for backward compatibility

    
    try { ensureLangSwitch(); bindLangDropdownEvents(); initI18n(); layoutLangSwitch(); } catch {}
    try { layoutSoundControl(); } catch {}

    const areaInput = document.getElementById('area-code');
    const noInput = document.getElementById('no');
    const openFavsBtn = document.getElementById('btn-open-favorites');
    const favStarBtn = document.getElementById('btn-favorite-star');
    const favoritesModal = document.getElementById('favorites-modal');
    const favoritesClose = document.getElementById('favorites-close');
    const favoritesListEl = document.getElementById('favorites-list');
    const saveFavModal = document.getElementById('save-fav-modal');
    const saveFavClose = document.getElementById('save-fav-close');
    const favNameInput = document.getElementById('fav-name-input');
    const favSaveBtn = document.getElementById('fav-save-btn');

    let favoritesCache = [];
    async function refreshFavorites(){
      try {
        const res = await fetch('/api/favorites', { cache: 'no-store' });
        favoritesCache = await res.json();
      } catch {
        favoritesCache = [];
      }
    }
    function getFavorites(){ return favoritesCache; }
    async function addFavorite(entry){
      try {
        await fetch('/api/favorites', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(entry) });
      } catch {}
      await refreshFavorites();
    }
    async function removeFavorite(entry){
      try {
        await fetch('/api/favorites', { method: 'DELETE', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(entry) });
      } catch {}
      await refreshFavorites();
    }
    function currentLocation(){
      try { return JSON.parse(localStorage.getItem('lastFetch') || 'null'); } catch { return null; }
    }
    function sameLocation(a,b){ return a && b && a.mode === b.mode && JSON.stringify(a.coords) === JSON.stringify(b.coords); }
    function isCurrentLocationSaved(){
      const cur = currentLocation();
      if (!cur) return false;
      return getFavorites().some(f => sameLocation(f, cur));
    }
    function updateFavStar(){ try { if (!favStarBtn) return; favStarBtn.classList.toggle('saved', isCurrentLocationSaved()); } catch {} }
    function renderFavoritesList(){
      if (!favoritesListEl) return;
      favoritesListEl.innerHTML = '';
      const favs = getFavorites();
      for (let i = 0; i < favs.length; i++) {
        const f = favs[i];
        const row = document.createElement('div'); row.className = 'favorite-item';
        const span = document.createElement('span'); span.textContent = f && f.name ? f.name : (f && f.mode === 'single' ? `${f.coords[0].x}, ${f.coords[0].y}` : '');
        const loadBtn = document.createElement('button'); loadBtn.type = 'button'; loadBtn.className = 'app-btn'; loadBtn.textContent = t('favorites.load') || 'Yükle'; loadBtn.dataset.index = String(i); loadBtn.dataset.action = 'load';
        const delBtn = document.createElement('button'); delBtn.type = 'button'; delBtn.className = 'app-btn'; delBtn.textContent = t('buttons.delete') || 'Sil'; delBtn.dataset.index = String(i); delBtn.dataset.action = 'delete';
        row.appendChild(span); row.appendChild(loadBtn); row.appendChild(delBtn); favoritesListEl.appendChild(row);
      }
    }

    if (openFavsBtn) openFavsBtn.addEventListener('click', async () => {
      await refreshFavorites();
      renderFavoritesList();
      if (favoritesModal) favoritesModal.hidden = false;
      try { document.body.classList.add('no-scroll'); } catch {}
    });
    if (favoritesClose) favoritesClose.addEventListener('click', () => {
      if (favoritesModal) favoritesModal.hidden = true;
      try { document.body.classList.remove('no-scroll'); } catch {}
    });
    if (favoritesModal) favoritesModal.addEventListener('click', (e) => {
      if (e.target === favoritesModal) { favoritesModal.hidden = true; try { document.body.classList.remove('no-scroll'); } catch {} }
    });
    if (favoritesListEl) favoritesListEl.addEventListener('click', async (e) => {
      const target = e.target;
      if (!target || String(target.tagName).toLowerCase() !== 'button') return;
      const idx = Number(target.dataset.index);
      const favs = getFavorites();
      const fav = favs && favs[idx];
      if (!fav) return;
      const action = target.dataset.action || 'load';
      if (action === 'delete') {
        await removeFavorite({ mode: fav.mode, coords: fav.coords });
        renderFavoritesList();
        updateFavStar();
        return;
      }
      if (action === 'load') {
        if (fav.mode === 'single') {
          if (Array.isArray(fav.coords) && fav.coords[0]) {
            loadImage(fav.coords[0].x, fav.coords[0].y);
            try { localStorage.setItem('lastFetch', JSON.stringify({ mode: 'single', coords: [{ x: fav.coords[0].x, y: fav.coords[0].y }] })); } catch {}
          }
        }
        if (favoritesModal) favoritesModal.hidden = true;
        try { document.body.classList.remove('no-scroll'); } catch {}
        updateFavStar();
      }
    });

    if (favStarBtn) favStarBtn.addEventListener('click', async () => {
      const cur = currentLocation();
      if (!cur) return;
      if (isCurrentLocationSaved()) {
        await removeFavorite(cur);
        updateFavStar();
        return;
      }
      if (favNameInput && saveFavModal) {
        favNameInput.value = '';
        saveFavModal.hidden = false;
        try { document.body.classList.add('no-scroll'); } catch {}
      }
    });
    if (saveFavClose) saveFavClose.addEventListener('click', () => {
      if (saveFavModal) saveFavModal.hidden = true;
      try { document.body.classList.remove('no-scroll'); } catch {}
    });
    if (saveFavModal) saveFavModal.addEventListener('click', (e) => {
      if (e.target === saveFavModal) { saveFavModal.hidden = true; try { document.body.classList.remove('no-scroll'); } catch {} }
    });
    if (favSaveBtn) favSaveBtn.addEventListener('click', async () => {
      const name = (favNameInput && favNameInput.value) ? favNameInput.value.trim() : '';
      const cur = currentLocation();
      if (!cur) { if (saveFavModal) saveFavModal.hidden = true; try { document.body.classList.remove('no-scroll'); } catch {}; return; }
      await addFavorite({ ...cur, name });
      if (saveFavModal) saveFavModal.hidden = true;
      try { document.body.classList.remove('no-scroll'); } catch {}
      updateFavStar();
    });
    refreshFavorites().then(() => { try { updateFavStar(); } catch {} });

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    const sign = document.getElementById('sign');
    const pixelHoverEl = document.getElementById('pixel-hover');
    const colorPaletteEl = document.getElementById('color-palette');
    const paletteModeEl = document.getElementById('palette-mode');
    const paletteModeToggle = document.getElementById('palette-mode-toggle');
    const paletteModeLabelLeft = document.getElementById('palette-mode-label-left');
    const paletteModeLabelRight = document.getElementById('palette-mode-label-right');
    const pixelSelectedList = document.getElementById('pixel-selected-list');
    const selectionOverlay = document.getElementById('selection-overlay');
    const selectionCtx = selectionOverlay ? selectionOverlay.getContext('2d', { willReadFrequently: true }) : null;
    const eraserButton = document.getElementById('eraser-button');
    let isEraserMode; // Sẽ được tính toán động dựa trên selectedOverrideColorId
    function resizeSelectionOverlay(){
      try {
        if (!selectionOverlay) return;
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = document.body.getBoundingClientRect();
        selectionOverlay.width = Math.floor(rect.width * dpr);
        selectionOverlay.height = Math.floor(rect.height * dpr);
        selectionOverlay.style.width = rect.width + 'px';
        selectionOverlay.style.height = rect.height + 'px';
      } catch {}
    }
    resizeSelectionOverlay();
    window.addEventListener('resize', resizeSelectionOverlay);
    // Background refresh and recent paint cache
    const BACKGROUND_REFRESH_MS = 30 * 1000;
    const RECENT_CACHE_MAX = 10000;
    let isPainting = false;
    const recentPaintCache = new Map();
    let refreshTimer = null;

    function trimRecentPaint(){
      while (recentPaintCache.size > RECENT_CACHE_MAX){
        const oldest = recentPaintCache.keys().next().value;
        if (oldest == null) break;
        recentPaintCache.delete(oldest);
      }
    }
    function addRecentPaint(x, y, colorId){
      recentPaintCache.set(String(x)+','+String(y), { x, y, colorId, time: Date.now() });
      trimRecentPaint();
    }
    function addRecentPaintBatch(g, coordsSlice, colorsSlice, tileW, tileH, base){
      const colOffset = g.area - Number(base.x||0);
      const rowOffset = g.no - Number(base.y||0);
      const baseWx = colOffset * tileW;
      const baseWy = rowOffset * tileH;
      for (let i = 0; i < colorsSlice.length; i++){
        const wx = baseWx + coordsSlice[i*2];
        const wy = baseWy + coordsSlice[i*2+1];
        addRecentPaint(wx, wy, colorsSlice[i]);
      }
    }
    function scheduleBackgroundRefresh(delay = BACKGROUND_REFRESH_MS){
      clearTimeout(refreshTimer);
      refreshTimer = setTimeout(async () => {
        if (isPainting){
          scheduleBackgroundRefresh(1000);
          return;
        }
        if (recentPaintCache.size > 0){
          recentPaintCache.clear();
          drawSelectionOverlay();
          console.log('Pixel cache cleared');
        }
        const ok = await reloadCurrentBackground();
        if (ok){
          drawSelectionOverlay();
          console.log('Background refreshed');
        }
        scheduleBackgroundRefresh();
      }, delay);
    }
    scheduleBackgroundRefresh();
    const signLayer = document.getElementById('sign-layer');
    const signOutline = document.getElementById('sign-outline');
    const signFileInput = document.getElementById('sign-file');
    const uploadBtn = document.getElementById('btn-upload-sign');
    const mosaicCanvas = document.createElement('canvas');
    const sidebar = document.getElementById('sidebar');
    const thumbList = document.getElementById('thumb-list');
    const counter = document.getElementById('counter');
    const accountsBtn = document.getElementById('btn-accounts');
      const pixelPowerEl = document.getElementById('pixel-power');
    const soundToggleBtn = document.getElementById('sound-toggle');
    const soundVolumeEl = document.getElementById('sound-volume');
    const soundVolumeValue = document.getElementById('sound-volume-value');

    let soundEnabled = true;
    let soundVolume = 1.0;
    try {
      const se = localStorage.getItem('sound.enabled');
      const sv = localStorage.getItem('sound.volume');
      if (se != null) soundEnabled = (se === 'true');
      if (sv != null && !isNaN(Number(sv))) soundVolume = Math.min(1, Math.max(0, Number(sv)));
    } catch {}

    let audioCtx = null;
    function ensureAudioCtx(){
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx && audioCtx.state === 'suspended') { try { audioCtx.resume(); } catch {} }
      } catch {}
      return audioCtx;
    }
    function playNotifySound(){
      if (!soundEnabled) return;
      const ctx = ensureAudioCtx();
      if (!ctx) return;
      try { ctx.resume(); } catch {}
      const now = ctx.currentTime;

      const masterGain = ctx.createGain();
      masterGain.gain.setValueAtTime(0.0001, now);
      const targetVol = Math.max(0.0001, soundVolume * 0.8);
      masterGain.gain.exponentialRampToValueAtTime(targetVol, now + 0.02);
      masterGain.gain.exponentialRampToValueAtTime(0.0001, now + 1.2);
      masterGain.connect(ctx.destination);

      const delay = ctx.createDelay(0.5);
      delay.delayTime.value = 0.14;
      const feedback = ctx.createGain(); feedback.gain.value = 0.25;
      const delayMix = ctx.createGain(); delayMix.gain.value = 0.35;
      delay.connect(feedback); feedback.connect(delay);
      delay.connect(delayMix); delayMix.connect(masterGain);

      function makeVoice(frequencyHz, startOffsetSec, durationSec){
        const startAt = now + startOffsetSec;
        const stopAt = startAt + durationSec;

        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(frequencyHz * 0.995, startAt);
        osc.frequency.linearRampToValueAtTime(frequencyHz, startAt + 0.08);

        const overtone = ctx.createOscillator();
        overtone.type = 'triangle';
        overtone.frequency.value = frequencyHz * 2;
        overtone.detune.value = 3;

        const vibrato = ctx.createOscillator();
        vibrato.type = 'sine';
        vibrato.frequency.value = 6;
        const vibratoGain = ctx.createGain();
        vibratoGain.gain.value = frequencyHz * 0.015;
        vibrato.connect(vibratoGain);
        vibratoGain.connect(osc.frequency);

        const voiceGain = ctx.createGain();
        voiceGain.gain.setValueAtTime(0.0001, startAt);
        voiceGain.gain.exponentialRampToValueAtTime(targetVol, startAt + 0.03);
        voiceGain.gain.exponentialRampToValueAtTime(0.0001, stopAt);

        osc.connect(voiceGain);
        const overtoneGain = ctx.createGain(); overtoneGain.gain.value = 0.22;
        overtone.connect(overtoneGain); overtoneGain.connect(voiceGain);

        const dry = ctx.createGain(); dry.gain.value = 1.0;
        voiceGain.connect(dry); dry.connect(masterGain);
        const wetSend = ctx.createGain(); wetSend.gain.value = 0.55;
        voiceGain.connect(wetSend); wetSend.connect(delay);

        osc.start(startAt);
        overtone.start(startAt);
        vibrato.start(startAt);
        vibrato.stop(stopAt);
        overtone.stop(stopAt);
        osc.stop(stopAt + 0.01);
      }

      makeVoice(659.25, 0.00, 0.50);
      makeVoice(987.77, 0.09, 0.50);
      makeVoice(1318.51, 0.18, 0.65);

      try {
        const noiseDur = 0.18;
        const noiseBuf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * noiseDur), ctx.sampleRate);
        const ch = noiseBuf.getChannelData(0);
        for (let i = 0; i < ch.length; i++) {
          const t = i / ch.length;
          ch[i] = (Math.random() * 2 - 1) * (1 - t) * (1 - t) * 0.5;
        }
        const noise = ctx.createBufferSource(); noise.buffer = noiseBuf;
        const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 4200; bp.Q.value = 1.1;
        const ng = ctx.createGain(); ng.gain.value = targetVol * 0.18;
        noise.connect(bp); bp.connect(ng); ng.connect(masterGain);
        noise.start(now);
        noise.stop(now + noiseDur);
      } catch {}
    }
    function updateSoundUi(){
      try {
        if (soundVolumeEl) {
          const percent = Math.round(soundVolume * 100);
          try { soundVolumeEl.setAttribute('aria-valuenow', String(percent)); } catch {}
          try {
            const fill = soundVolumeEl.querySelector('.slider-fill');
            const thumb = soundVolumeEl.querySelector('.slider-thumb');
            if (fill) fill.style.height = percent + '%';
            if (thumb) thumb.style.bottom = percent + '%';
          } catch {}
        }
        if (soundVolumeValue) soundVolumeValue.textContent = Math.round(soundVolume * 100) + '%';
        if (soundToggleBtn) {
          soundToggleBtn.classList.toggle('muted', !soundEnabled || soundVolume === 0);
          soundToggleBtn.textContent = (!soundEnabled || soundVolume === 0) ? '🔇' : (soundVolume < 0.5 ? '🔈' : '🔊');
          soundToggleBtn.setAttribute('aria-pressed', soundEnabled ? 'true' : 'false');
        }
      } catch {}
    }
    function setSoundEnabled(v){
      soundEnabled = !!v;
      try { localStorage.setItem('sound.enabled', soundEnabled ? 'true' : 'false'); } catch {}
      updateSoundUi();
    }
    function setSoundVolume(v){
      const n = Number(v);
      if (!isNaN(n)) {
        const normalized = n > 1 ? (n / 100) : n;
        soundVolume = Math.min(1, Math.max(0, normalized));
        try { localStorage.setItem('sound.volume', String(soundVolume)); } catch {}
        updateSoundUi();
      }
    }
    if (soundToggleBtn) {
      soundToggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const isZero = soundVolume === 0;
        if (isZero) {
          setSoundEnabled(true);
          setSoundVolume(1);
          try { ensureAudioCtx(); } catch {}
        } else {
          setSoundVolume(0);
        }
      });
      soundToggleBtn.addEventListener('mouseenter', () => {
        const sc = document.getElementById('sound-control');
        if (sc) sc.classList.add('open');
      });
      soundToggleBtn.addEventListener('mouseleave', (e) => {
        const sc = document.getElementById('sound-control');
        if (!sc) return;
        const to = e && e.relatedTarget ? e.relatedTarget : null;
        if (to && sc.contains(to)) return; 
        setTimeout(() => { if (!sc.matches(':hover')) sc.classList.remove('open'); }, 120);
      });
      // Toggle mute with middle-click
      soundToggleBtn.addEventListener('auxclick', (e) => {
        if (e && e.button === 1) { e.preventDefault(); setSoundEnabled(!soundEnabled); updateSoundUi(); }
      });
    }
    if (soundVolumeEl) {
      let isDraggingVol = false;
      const onMove = (clientY) => {
        const rect = soundVolumeEl.getBoundingClientRect();
        const y = Math.min(Math.max(clientY - rect.top, 0), rect.height);
        const ratio = 1 - (y / rect.height);
        setSoundVolume(ratio);
        if (soundEnabled) { try { ensureAudioCtx(); } catch {} }
      };
      soundVolumeEl.addEventListener('pointerdown', (e) => {
        isDraggingVol = true;
        try { soundVolumeEl.setPointerCapture(e.pointerId); } catch {}
        onMove(e.clientY);
        const sc = document.getElementById('sound-control');
        if (sc) sc.classList.add('open');
      });
      soundVolumeEl.addEventListener('pointermove', (e) => {
        if (!isDraggingVol) return;
        onMove(e.clientY);
      });
      const endDrag = () => {
        if (!isDraggingVol) return;
        isDraggingVol = false;
        const sc = document.getElementById('sound-control');
        setTimeout(() => { if (sc && !sc.matches(':hover')) sc.classList.remove('open'); }, 200);
      };
      soundVolumeEl.addEventListener('pointerup', endDrag);
      soundVolumeEl.addEventListener('pointercancel', endDrag);
      soundVolumeEl.addEventListener('mouseleave', () => {
        const sc = document.getElementById('sound-control');
        setTimeout(() => { if (sc && !sc.matches(':hover')) sc.classList.remove('open'); }, 200);
      });
    }
    // Close panel when clicking outside
    document.addEventListener('click', (e) => {
      const sc = document.getElementById('sound-control');
      if (!sc) return;
      if (sc.contains(e.target)) return;
      sc.classList.remove('open');
    });
    updateSoundUi();

    // Movement controls (pixel-by-pixel image movement)
    const movementBtn = document.getElementById('btn-movement');
    const movementPopup = document.getElementById('movement-popup');
    const moveUpBtn = document.getElementById('move-up');
    const moveDownBtn = document.getElementById('move-down');
    const moveLeftBtn = document.getElementById('move-left');
    const moveRightBtn = document.getElementById('move-right');

    function isMovementOpen(){
      try { return !!(movementPopup && !movementPopup.hidden); } catch { return false; }
    }
    function getSelectedItem(){
      try {
        return (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
      } catch { return null; }
    }
    function updateMovementButtonEnabled(){
      if (!movementBtn) return;
      const it = getSelectedItem();
      let enable = false;
      try { enable = !!(it && it.image && it.image.complete && !(it.locked || it.lockedByReady)); } catch { enable = false; }
      try { movementBtn.disabled = !enable; } catch {}
      // Do not auto-close when disabled due to transient selection changes; keep user's choice.
    }
    function clampPositionForItem(item, x, y){
      let nx = Math.round(x|0), ny = Math.round(y|0);
      try {
        if (!img || !item || !item.image || !item.image.naturalWidth || !item.image.naturalHeight) return { x: nx, y: ny };
        const iw = item.image.naturalWidth|0, ih = item.image.naturalHeight|0;
        if (!ALLOW_DRAG_BEYOND_NINE) {
          const rects = getAllowedPlacementRects();
          if (!rects || rects.length === 0) {
            const maxX = Math.max(0, img.width - iw);
            const maxY = Math.max(0, img.height - ih);
            return { x: Math.min(Math.max(0, nx), maxX), y: Math.min(Math.max(0, ny), maxY) };
          }
          const bounds = getCompositeBounds(rects);
          const maxX = (bounds.maxX|0) - iw;
          const maxY = (bounds.maxY|0) - ih;
          const minX = bounds.minX|0;
          const minY = bounds.minY|0;
          nx = Math.min(Math.max(minX, nx), maxX);
          ny = Math.min(Math.max(minY, ny), maxY);
          return { x: nx, y: ny };
        }
        // If allowed beyond nine: keep at least 1 px inside composite bounds (with some slack)
        const rects = getAllowedPlacementRects();
        if (!rects || rects.length === 0) {
          const minX = 1 - iw;
          const minY = 1 - ih;
          const maxX = (img.width|0) - 1;
          const maxY = (img.height|0) - 1;
          nx = Math.min(Math.max(minX, nx), maxX);
          ny = Math.min(Math.max(minY, ny), maxY);
          return { x: nx, y: ny };
        }
        const b = getCompositeBounds(rects);
        const outerSlack = 512;
        const minX = (b.minX|0) - iw + 1 - outerSlack;
        const minY = (b.minY|0) - ih + 1 - outerSlack;
        const maxX = (b.maxX|0) - 1 + outerSlack;
        const maxY = (b.maxY|0) - 1 + outerSlack;
        nx = Math.min(Math.max(minX, nx), maxX);
        ny = Math.min(Math.max(minY, ny), maxY);
        return { x: nx, y: ny };
      } catch { return { x: nx, y: ny }; }
    }
    function moveSelectedBy(dx, dy, step){
      const it = getSelectedItem();
      if (!it || !it.image || !it.image.complete) { try { showToast(t('messages.noSelectedImage'), 'error', 1800); } catch {} return; }
      if (it.locked || it.lockedByReady) { return; }
      const mult = Number.isFinite(step) ? Math.max(1, step|0) : 1;
      const targetX = (it.worldX || 0) + dx * mult;
      const targetY = (it.worldY || 0) + dy * mult;
      const clamped = clampPositionForItem(it, targetX, targetY);
      if (clamped.x === (it.worldX||0) && clamped.y === (it.worldY||0)) return;
      it.worldX = clamped.x;
      it.worldY = clamped.y;
      try { localStorage.setItem('last.image.worldX', String(it.worldX||0)); localStorage.setItem('last.image.worldY', String(it.worldY||0)); } catch {}
      try { it._placedCountCache = null; } catch {}
      render();
      try { updatePixelMarkers(); } catch {}
      if (isReadyOpen()) { try { updateReadySelectionLabel(); } catch {} }
      try { saveImagesToStorage(); } catch {}
    }
    function setupMoveHold(btn, dx, dy){
      if (!btn) return;
      const stop = () => {
        try { if (btn._mvInt) { clearInterval(btn._mvInt); btn._mvInt = null; } } catch {}
        try { if (btn._mvTmo) { clearTimeout(btn._mvTmo); btn._mvTmo = null; } } catch {}
      };
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        if (btn._skipNextClick) { btn._skipNextClick = false; return; }
        moveSelectedBy(dx, dy, e && e.shiftKey ? 5 : 1);
      });
      btn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        const step = e && e.shiftKey ? 5 : 1;
        moveSelectedBy(dx, dy, step);
        btn._skipNextClick = true;
        try { btn.setPointerCapture(e.pointerId); } catch {}
        btn._mvTmo = setTimeout(() => {
          btn._mvInt = setInterval(() => moveSelectedBy(dx, dy, step), 50);
        }, 250);
      });
      const end = () => { stop(); setTimeout(() => { btn._skipNextClick = false; }, 0); };
      btn.addEventListener('pointerup', end);
      btn.addEventListener('pointercancel', end);
      btn.addEventListener('pointerleave', end);
    }
    if (movementBtn && movementPopup) {
      function clearKbdPressVisuals(){
        setKbdVisual('up', false);
        setKbdVisual('down', false);
        setKbdVisual('left', false);
        setKbdVisual('right', false);
      }
      movementBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (movementBtn.disabled) return;
        movementPopup.hidden = !movementPopup.hidden;
        if (movementPopup.hidden) clearKbdPressVisuals();
      });
      // Removed auto-close on outside click to prevent flicker when focusing an image.
      function setKbdVisual(dir, on){
        try {
          const map = { up: moveUpBtn, down: moveDownBtn, left: moveLeftBtn, right: moveRightBtn };
          const el = map[dir]; if (!el) return;
          if (on) el.classList.add('kbd-press'); else el.classList.remove('kbd-press');
        } catch {}
      }
      window.addEventListener('keydown', (e) => {
        if (!isMovementOpen()) return;
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        if (tag === 'input' || tag === 'textarea' || tag === 'select' || (e.target && e.target.isContentEditable)) return;
        let handled = false;
        const step = e.shiftKey ? 5 : 1;
        if (e.key === 'ArrowUp') { moveSelectedBy(0, -1, step); setKbdVisual('up', true); handled = true; }
        else if (e.key === 'ArrowDown') { moveSelectedBy(0, 1, step); setKbdVisual('down', true); handled = true; }
        else if (e.key === 'ArrowLeft') { moveSelectedBy(-1, 0, step); setKbdVisual('left', true); handled = true; }
        else if (e.key === 'ArrowRight') { moveSelectedBy(1, 0, step); setKbdVisual('right', true); handled = true; }
        else if (e.key === 'Escape') { movementPopup.hidden = true; handled = true; }
        if (handled) { try { e.preventDefault(); e.stopPropagation(); } catch {} }
      });
      window.addEventListener('keyup', (e) => {
        if (!isMovementOpen()) return;
        if (e.key === 'ArrowUp') setKbdVisual('up', false);
        else if (e.key === 'ArrowDown') setKbdVisual('down', false);
        else if (e.key === 'ArrowLeft') setKbdVisual('left', false);
        else if (e.key === 'ArrowRight') setKbdVisual('right', false);
      });
    }
    setupMoveHold(moveUpBtn, 0, -1);
    setupMoveHold(moveDownBtn, 0, 1);
    setupMoveHold(moveLeftBtn, -1, 0);
    setupMoveHold(moveRightBtn, 1, 0);
    updateMovementButtonEnabled();

    // Pixel fullness notifier
    const FULLNESS_NOTIFY_PERIOD_MS = 30 * 1000;
    let lastFullnessNotifyAt = 0;
    function maybeNotifyFullnessNow(){
      const now = Date.now();
      if (now - lastFullnessNotifyAt >= FULLNESS_NOTIFY_PERIOD_MS - 50) {
        lastFullnessNotifyAt = now;
        playNotifySound();
      }
    }
    function checkFullnessNotify(){
      try {
        const c = Number(pixelPowerEl && pixelPowerEl.getAttribute('data-count') || '0');
        const m = Number(pixelPowerEl && pixelPowerEl.getAttribute('data-max') || '0');
        const ratio = m > 0 ? (c / m) : 0;
        if (ratio >= 0.90) maybeNotifyFullnessNow();
      } catch {}
    }
    try { setInterval(() => { checkFullnessNotify(); }, FULLNESS_NOTIFY_PERIOD_MS); } catch {}
    const accountsModal = document.getElementById('accounts-modal');
    const accountsClose = document.getElementById('accounts-close');
    const accountsBody = document.querySelector('#accounts-modal .modal-body');
    const tabAccounts = document.getElementById('tab-accounts');
    const accountsSection = document.getElementById('accounts-section');
    const accountFormSection = document.getElementById('account-form-section');
    const shopViewSection = document.getElementById('shop-view-section');
    
    const accountsTbody = document.getElementById('accounts-tbody');
    const shopDropletsInfo = document.getElementById('shop-droplets-info');
    // Shop controls
    const shopMaxDecBtn = document.getElementById('shop-max-dec');
    const shopMaxIncBtn = document.getElementById('shop-max-inc');
    const shopMaxMaxBtn = document.getElementById('shop-max-max');
    const shopMaxQtyEl = document.getElementById('shop-max-qty');
    const shopMaxPriceEl = document.getElementById('shop-max-price');
    const shopRecDecBtn = document.getElementById('shop-rec-dec');
    const shopRecIncBtn = document.getElementById('shop-rec-inc');
    const shopRecMaxBtn = document.getElementById('shop-rec-max');
    const shopRecQtyEl = document.getElementById('shop-rec-qty');
    const shopRecPriceEl = document.getElementById('shop-rec-price');
    const shopMaxAutoBtn = document.getElementById('shop-max-auto');
    const shopRecAutoBtn = document.getElementById('shop-rec-auto');
    const shopPremiumPaletteWrap = document.getElementById('shop-premium-palette');
    const shopPremiumOwnedWrap = document.getElementById('shop-premium-owned');
    const shopPremiumBuyBtn = document.getElementById('shop-premium-buy');
    let shopCurrentAccount = null;
    let shopSelectedPremiumColorId = null;
    let shopExtraColorsBitmap = 0;
    const addAccountBtn = document.getElementById('btn-account-add');
    const checkAllBtn = document.getElementById('btn-check-all');
    const accountNameInput = document.getElementById('account-name-input');
    const accountTokenInput = document.getElementById('account-token-input');
    const accountIdInput = document.getElementById('account-id-input');
    const accountCancelBtn = document.getElementById('btn-account-cancel');
    const accountSaveBtn = document.getElementById('btn-account-save');
    const shopBackBtn = document.getElementById('btn-shop-back');
    const accountCfInput = document.getElementById('account-cf-input');
    let signDragging = false;
    let resizingItem = null;
    let resizeStartX = 0, resizeStartY = 0, resizeOrigW = 0, resizeOrigH = 0;
    let signWorldX = 0;
    let signWorldY = 0;
    let signWorldOffsetX = 0;
    let signWorldOffsetY = 0;
    let currentSignUrl = null;
    let placingNewSign = false;
    let signItems = [];
    let selectedIndex = -1;
    let pendingZoomToSelected = false;
    // When we change tiles to bring a sign into view, remember to zoom after load
    let pendingZoomToItem = null;
    let readyLockedItem = null;
    let accountsData = [];
    let readySelectedAccountIds = [];
    const MAX_READY_ACCOUNTS = 200;
    let autoSelecting = false;
    let ACTIVE_PALETTE = null;
    let paletteMode = 'premium'; // 'premium' | 'free'
    try { const savedMode = localStorage.getItem('palette.mode'); if (savedMode === 'free' || savedMode === 'premium') paletteMode = savedMode; } catch {}
    let readyShouldReset = false;
    const HOVER_ICON_SRC = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAAAAACoWZBhAAAAAXNSR0IArs4c6QAAACpJREFUeNpj+AsEZ86ASIa/DAwMZ84ACRDzDBigMs/AARITq1oUwxBWAADaREUdDMswKwAAAABJRU5ErkJggg==';
    const SELECTED_ICON_SRC = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAAXNSR0IArs4c6QAAACVJREFUeNpj+A8FDEAAZwMRBAIBmIYLIgHcgkQDIs3E6SRsjgcABYFLtfTgakEAAAAASUVORK5CYII=';
    try { if (pixelHoverEl) pixelHoverEl.src = HOVER_ICON_SRC; } catch {}
    
    const pixelHoverFillEl = (() => {
      const im = document.createElement('img');
      im.className = 'pixel-marker';
      im.alt = 'hover-fill';
      im.hidden = true;
      try { im.style.zIndex = '1299'; } catch {}
      try { document.body.appendChild(im); } catch {}
      return im;
    })();

   // Auto Paint elements
   const brokenPixelPaintToggle = document.getElementById('broken-pixel-paint-toggle');
   const priorityColorPaintToggle = document.getElementById('priority-color-paint-toggle');
   const chessPaintToggle = document.getElementById('chess-paint-toggle');
   const freePaintPixelToggle = document.getElementById('free-paint-toggle');
   const premiumPaintPixelToggle = document.getElementById('premium-paint-toggle');
   const limitOverlayToggle = document.getElementById('limit-overlay-toggle');
   const removeDuplicatesBtn = document.getElementById('remove-duplicates-btn');
   const colorPriorityListEl = document.getElementById('color-priority-list');
   const addPriorityColorBtn = document.getElementById('add-priority-color-btn');
   const pickColorToolBtn = document.getElementById('pick-color-tool-btn');
   const clearPriorityListBtn = document.getElementById('clear-priority-list-btn');
   const brokenPixelPriorityListEl = document.getElementById('broken-pixel-priority-list');
   const addBrokenPixelColorBtn = document.getElementById('add-broken-pixel-color-btn');
   const clearBrokenPixelListBtn = document.getElementById('clear-broken-pixel-list-btn');
   const minizineToDetectInput = document.getElementById('minizine-to-detect-input');

   // Auto Paint state variables
   // Các khai báo biến Auto Paint đã được di chuyển lên trên (dòng 7320)
   // Vị trí này chỉ cần giữ lại các 'const' DOM element

     let readyHoverPixel = { x: null, y: null };
    
     let selectedOverrideColorId = null;
    
     let readyGlobalMode = false;
     const readyGlobalSelected = new Map();
     let readyMouseDownPt = null;
     let readyMouseMoved = false;
     let autoSelectDeleteMode = false;
     const READY_CLICK_MOVE_TOLERANCE = 4;
     const PRIORITY_COLORS_STORAGE_KEY = 'autoPaint.priorityColors';
     const BROKEN_PIXEL_COLORS_STORAGE_KEY = 'autoPaint.brokenPixelPriorityColors';

     function getPaletteRgbById(id){
      const arr = (ACTIVE_PALETTE && Array.isArray(ACTIVE_PALETTE)) ? ACTIVE_PALETTE : PALETTE;
      for (let i = 0; i < arr.length; i++) { if (arr[i].id === id) return arr[i].rgb; }
      return [255,255,255];
    }
    const COLORED_MARKER_CACHE = new Map();
    function getMarkerSrcForColorId(colorId){
      if (colorId == null) return SELECTED_ICON_SRC;
      const k = String(colorId);
      if (COLORED_MARKER_CACHE.has(k)) return COLORED_MARKER_CACHE.get(k);
      const rgb = getPaletteRgbById(colorId);
      const off = document.createElement('canvas');
      off.width = 8; off.height = 8;
      const octx = off.getContext('2d');
      octx.fillStyle = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';
      octx.fillRect(0, 0, off.width, off.height);
      const url = off.toDataURL('image/png');
      COLORED_MARKER_CACHE.set(k, url);
      return url;
    }
    
    function getSelectedMap(item){
      if (!item) return null;
      if (!item._selectedPixels) item._selectedPixels = new Map();
      return item._selectedPixels;
    }
    function keyFor(x,y){ return String(x) + ',' + String(y); }
    function isPixelSelected(item, x, y){
      const map = getSelectedMap(item); if (!map) return false; return map.has(keyFor(x,y));
    }
    function addPixelSelection(item, x, y, colorIdOverride = null, isBrokenStatus = false, isMatchedStatus = false){
          const map = getSelectedMap(item); if (!map) return false;
          const k = keyFor(x,y); if (map.has(k)) return false;
          let effectiveColorId = colorIdOverride;
          if (effectiveColorId == null) {
            try { effectiveColorId = getItemPixelPaletteId(item, x, y); } catch {}
          }
          if (effectiveColorId != null && effectiveColorId !== 0 && isPremiumColorId(effectiveColorId)){
            const hasSelectedAccounts = Array.isArray(readySelectedAccountIds) && readySelectedAccountIds.length > 0;
            if (!hasSelectedAccounts) { try { showToast(t('messages.selectAccountFirst'), 'error', 2000); } catch {} return false; }
            const remain = getPremiumColorRemainingLimit(effectiveColorId);
            if (!(remain > 0)) { try { showToast(t('messages.premiumColorLimitReached'), 'error', 2000); } catch {} return false; }
          }
          // Store lightweight record; drawing handled by canvas overlay
          map.set(k, { x, y, el: null, fillEl: null, colorId: effectiveColorId, isBroken: isBrokenStatus, isMatched: isMatchedStatus });
          try { item._lastManualSelected = { x, y }; } catch {}
          if (pixelSelectedList) pixelSelectedList.hidden = false;
          drawSelectionOverlay();
          try { refreshPaletteTooltips(); } catch {}
          return true;
        }
    function removePixelSelection(item, x, y){
      const map = getSelectedMap(item); if (!map) return false;
      const k = keyFor(x,y); const rec = map.get(k); if (!rec) return false;
      // Remove from canvas overlay by redrawing without this record
      map.delete(k);
      drawSelectionOverlay();
      try { refreshPaletteTooltips(); } catch {}
      return true;
    }
    function clearSelectionsForItem(item){
      const map = getSelectedMap(item);
      if (!map) return;
      // Canvas overlay redraw will drop visuals
      map.clear();
      drawSelectionOverlay();
      try { item._lastManualSelected = null; } catch {}
      try { refreshPaletteTooltips(); } catch {}
    }
    function clearAllReadySelections(){
      try { if (pixelHoverEl) pixelHoverEl.hidden = true; } catch {}
      try { if (pixelSelectedList) pixelSelectedList.hidden = true; } catch {}
      for (let i = 0; i < signItems.length; i++) {
        const it = signItems[i];
        if (it) clearSelectionsForItem(it);
      }
      
      try { if (readyGlobalSelected) readyGlobalSelected.clear(); } catch {}
      try {
        if (pixelSelectedList) {
          while (pixelSelectedList.firstChild) pixelSelectedList.removeChild(pixelSelectedList.firstChild);
        }
      } catch {}
      updatePixelMarkers();
      drawSelectionOverlay();
      try { updateReadySelectionLabel(); } catch {}
      try { updateStartEnabled(); } catch {}
      try { updateAutoSelectButtonLabel(); } catch {}
      try { refreshPaletteTooltips(); } catch {}
    }
    function ensureRenderedSelectedForItem(item){
      if (!item) return;
      if (!selectionOverlay || !selectionCtx) return;
      drawSelectionOverlay();
    }
    function positionSelectedMarkersForItem(item){
      if (!item) return;
      drawSelectionOverlay();
    }

    function isReadyOpen() {
      try {
        const rp = document.getElementById('ready-popup');
        return !!(rp && !rp.hidden);
      } catch { return false; }
    }

    function ensureItemImageData(item){
      if (!item || !item.image) return null;
      if (item._imageData && item._imageData.width === item.image.naturalWidth && item._imageData.height === item.image.naturalHeight) return item._imageData;
      try {
        const off = document.createElement('canvas');
        off.width = item.image.naturalWidth; off.height = item.image.naturalHeight;
        const octx = off.getContext('2d', { willReadFrequently: true });
        octx.drawImage(item.image, 0, 0);
        item._imageData = octx.getImageData(0, 0, off.width, off.height);
        return item._imageData;
      } catch { return null; }
    }

    function isOpaquePixel(item, sx, sy){
      const id = ensureItemImageData(item);
      if (!id) return false;
      if (sx < 0 || sy < 0 || sx >= id.width || sy >= id.height) return false;
      const a = id.data[((id.width * sy + sx) << 2) + 3];
      return a !== 0;
    }

    
    function getItemPixelColor(item, sx, sy){
      const id = ensureItemImageData(item);
      if (!id) return null;
      if (sx < 0 || sy < 0 || sx >= id.width || sy >= id.height) return null;
      const i = ((id.width * sy + sx) << 2);
      return { r: id.data[i], g: id.data[i+1], b: id.data[i+2], a: id.data[i+3] };
    }
    function getBasePixelColorAtWorld(wx, wy){
      const key = String(Math.round(wx)) + ',' + String(Math.round(wy));
      const rec = recentPaintCache.get(key);
      if (rec){
        try {
          const rgb = getPaletteRgbById(rec.colorId);
          if (rgb && rgb.length === 3) return { r: rgb[0], g: rgb[1], b: rgb[2], a: 255 };
        } catch {}
      }
      const baseId = ensureBaseImageData();
      if (!baseId) return null;
      const x = Math.round(wx);
      const y = Math.round(wy);
      if (x < 0 || y < 0 || x >= baseId.width || y >= baseId.height) return null;
      const i = ((baseId.width * y + x) << 2);
      return { r: baseId.data[i], g: baseId.data[i+1], b: baseId.data[i+2], a: baseId.data[i+3] };
    }
    // For overlays: ensure imageData for a neighbor overlay
    function ensureOverlayImageData(ov){
      if (!ov || !ov.image) return null;
      try {
        const w = ov.image.naturalWidth || ov.image.width;
        const h = ov.image.naturalHeight || ov.image.height;
        if (ov.imageData && ov.imageData.width === (w|0) && ov.imageData.height === (h|0)) return ov.imageData;
        const off = document.createElement('canvas'); off.width = w; off.height = h;
        const octx = off.getContext('2d', { willReadFrequently: true });
        octx.drawImage(ov.image, 0, 0);
        ov.imageData = octx.getImageData(0, 0, w, h);
        return ov.imageData;
      } catch { return null; }
    }
    // Composite color at world coords considering overlays when present
    function getCompositeColorAtWorld(wx, wy){
      const key = String(Math.round(wx)) + ',' + String(Math.round(wy));
      // Check cache first
      // if (COMPOSITE_COLOR_CACHE.has(key)) {
      //     return COMPOSITE_COLOR_CACHE.get(key);
      // }

      const rec = recentPaintCache.get(key);
      if (rec){
        try {
          const rgb = getPaletteRgbById(rec.colorId);
          if (rgb && rgb.length === 3) {
            const color = { r: rgb[0], g: rgb[1], b: rgb[2], a: 255 };
            COMPOSITE_COLOR_CACHE.set(key, color);
            return color;
          }
        } catch {}
      }
      if (!img) return null;
      const w = img.width|0, h = img.height|0;
      try {
        if (neighborOverlays && neighborOverlays.size > 0) {
          const gx = Math.floor(wx), gy = Math.floor(wy);
          for (const [k, ov] of neighborOverlays.entries()) {
            if (!ov || !ov.image) continue;
            const ox0 = (ov.col|0) * w;
            const oy0 = (ov.row|0) * h;
            if (gx >= ox0 && gx < ox0 + w && gy >= oy0 && gy < oy0 + h) {
              const id = ensureOverlayImageData(ov);
              if (!id) break;
              const lx = gx - ox0, ly = gy - oy0;
              const i = ((id.width * ly + lx) << 2);
              const color = { r: id.data[i], g: id.data[i+1], b: id.data[i+2], a: id.data[i+3] };
              COMPOSITE_COLOR_CACHE.set(key, color);
              return color;
            }
          }
        }
      } catch {}
      const color = getBasePixelColorAtWorld(wx, wy);
      // COMPOSITE_COLOR_CACHE.set(key, color);
      return color;
    }
    function getItemPixelPaletteId(item, sx, sy){
      const key = `${item.id || item.url},${sx},${sy}`;
      if (ITEM_PIXEL_PALETTE_ID_CACHE.has(key)) {
        return ITEM_PIXEL_PALETTE_ID_CACHE.get(key);
      }

      const c = getItemPixelColor(item, sx, sy);
      if (!c || c.a === 0) {
        ITEM_PIXEL_PALETTE_ID_CACHE.set(key, null);
        return null;
      }
      const paletteId = rgbToPaletteId(c.r, c.g, c.b);
      ITEM_PIXEL_PALETTE_ID_CACHE.set(key, paletteId);
      return paletteId;
    }
    // Get color from canvas or from the sign image if the canvas is transparent there
    function getColorAtWorld(wx, wy) {
        // Lấy màu từ canvas chính
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const pixelData = ctx.getImageData(wx, wy, 1, 1).data;

        // Nếu pixel trên canvas chính không trong suốt, trả về màu đó
        if (pixelData[3] > 0) {
            return { r: pixelData[0], g: pixelData[1], b: pixelData[2], a: pixelData[3] };
        }

        // Nếu canvas trong suốt, thử lấy màu từ hình ảnh sign (nếu có và hiển thị)
        if (sign && !sign.hidden && sign.naturalWidth && sign.naturalHeight) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = sign.naturalWidth;
            tempCanvas.height = sign.naturalHeight;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCtx.drawImage(sign, 0, 0);
            
            // Chuyển đổi world coordinates sang local coordinates của sign image
            const signX = Math.floor(wx - (signItems[selectedIndex]?.worldX || 0));
            const signY = Math.floor(wy - (signItems[selectedIndex]?.worldY || 0));

            if (signX >= 0 && signX < sign.naturalWidth && signY >= 0 && signY < sign.naturalHeight) {
                const signPixelData = tempCtx.getImageData(signX, signY, 1, 1).data;
                if (signPixelData[3] > 0) {
                    return { r: signPixelData[0], g: signPixelData[1], b: signPixelData[2], a: signPixelData[3] };
                }
            }
        }
        return null;
    }

    function logSelectionDetails(item, sx, sy){  }

    function worldToScreen(wx, wy){
      return { x: canvas.offsetLeft + state.translateX + wx * state.scale, y: canvas.offsetTop + state.translateY + wy * state.scale };
    }

    function hitOverlayAt(worldX, worldY){
      const sel = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
      if (!sel || !sel._overlayRects) return null;
      const r = sel._overlayRects;
      if (r.lock && worldX >= r.lock.x && worldX <= r.lock.x + r.lock.w && worldY >= r.lock.y && worldY <= r.lock.y + r.lock.h) return 'lock';
      if (r.del && worldX >= r.del.x && worldX <= r.del.x + r.del.w && worldY >= r.del.y && worldY <= r.del.y + r.del.h) return 'del';
      return null;
    }
    function updateCanvasCursorAt(worldX, worldY){
      try {
        const hit = hitOverlayAt(worldX, worldY);
        if (hit) canvas.style.cursor = 'pointer'; else canvas.style.cursor = '';
      } catch {}
      // Update 3x3 grid hover state and re-render when it changes
      try {
        if (!img) {
          if (hoveredGridCell) { hoveredGridCell = null; render(); }
          return;
        }
        let next = gridCellAt(worldX, worldY);
        // Do not highlight the center cell (fetched tile)
        if (next && next.row === 0 && next.col === 0) next = null;
        // Also do not highlight cells that already have overlay
        if (next) {
          const k = String(next.col|0) + ',' + String(next.row|0);
          if (neighborOverlays && neighborOverlays.has(k)) next = null;
        }
        const changed = !((!hoveredGridCell && !next) || (hoveredGridCell && next && hoveredGridCell.row === next.row && hoveredGridCell.col === next.col));
        if (changed) { hoveredGridCell = next; render(); }
      } catch {}
    }

    function positionPixelMarker(el, item, sx, sy){
      if (!el || !item) return;
      const wx = (item.worldX || 0) + sx;
      const wy = (item.worldY || 0) + sy;
      const p = worldToScreen(wx, wy);
      const size = Math.max(1, state.scale);
      el.style.left = p.x + 'px';
      el.style.top = p.y + 'px';
      el.style.width = size + 'px';
      el.style.height = size + 'px';
      el.hidden = false;
    }
    function positionPixelMarkerAtWorld(el, wx, wy){
      if (!el) return;
      const p = worldToScreen(wx, wy);
      const size = Math.max(1, state.scale);
      el.style.left = p.x + 'px';
      el.style.top = p.y + 'px';
      el.style.width = size + 'px';
      el.style.height = size + 'px';
      el.hidden = false;
    }
    function drawSelectionOverlay(){
      try {
        if (!isReadyOpen()) { if (selectionCtx) selectionCtx.clearRect(0,0,selectionOverlay.width,selectionOverlay.height); return; }
        if (!selectionOverlay || !selectionCtx) return;
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = canvas.getBoundingClientRect();
        selectionCtx.clearRect(0, 0, selectionOverlay.width, selectionOverlay.height);
        selectionCtx.imageSmoothingEnabled = false;
        try {
          trimRecentPaint();
          recentPaintCache.forEach(rec => {
            const p = worldToScreen(rec.x, rec.y);
            const x = Math.floor(p.x * dpr);
            const y = Math.floor(p.y * dpr);
            const s = Math.max(1, Math.floor(state.scale * dpr));
            let rgb = null;
            try { rgb = getPaletteRgbById(rec.colorId); } catch {}
            if (rgb && rgb.length === 3) {
              selectionCtx.fillStyle = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';
              selectionCtx.fillRect(x, y, s, s);
            }
          });
        } catch {}
        const drawPixel = (xPx, yPx, sPx, colorId, fallbackColor) => {
          const s = Math.max(1, sPx|0);
          const x = xPx|0, y = yPx|0;
          // Determine fill color by palette id
          let fillRgb = null;
          if (colorId != null && colorId !== 0) {
            try {
              const rgb = getPaletteRgbById(colorId);
              if (rgb && rgb.length === 3) fillRgb = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';
            } catch {}
          }
          // Transparent (id 0)
          if (colorId === 0) {
            // Draw hollow box with red slash if space permits
            if (s >= 3) {
              selectionCtx.fillStyle = 'rgba(0,0,0,0.65)';
              selectionCtx.fillRect(x, y, s, s);
              selectionCtx.clearRect(x+1, y+1, s-2, s-2);
              selectionCtx.fillStyle = '#ef4444';
              // diagonal slash
              selectionCtx.fillRect(x+1, y+s-2, s-2, 1);
              selectionCtx.fillRect(x+1, y+s-3, s-2, 1);
            } else {
              // Minimal indicator
              selectionCtx.fillStyle = '#ef4444';
              selectionCtx.fillRect(x, y, s, s);
            }
            // continue to draw ring/dot for consistent indicator
          }
          // Unknown -> fallback
          if (!fillRgb && fallbackColor) {
            fillRgb = fallbackColor;
          }
          if (!fillRgb) fillRgb = '#ffffff';
          // Border for contrast
          if (s >= 2) {
            selectionCtx.fillStyle = 'rgba(0,0,0,0.65)';
            selectionCtx.fillRect(x, y, s, s);
            selectionCtx.fillStyle = fillRgb;
            selectionCtx.fillRect(x+1, y+1, s-2, s-2);
          } else {
            // 1px scale
            selectionCtx.fillStyle = fillRgb;
            selectionCtx.fillRect(x, y, s, s);
          }
          // Draw black center dot with white ring to be visible on all colors
          const cx = x + s / 2;
          const cy = y + s / 2;
          if (s >= 3) {
            const rOuter = Math.max(1, Math.floor(s / 2) - 1);
            const rInner = Math.max(1, rOuter - 4);
            try {
              selectionCtx.beginPath();
              selectionCtx.lineWidth = 1;
              selectionCtx.strokeStyle = '#000000';
              selectionCtx.arc(cx, cy, rOuter, 0, Math.PI * 2);
              selectionCtx.stroke();
            } catch {}
            try {
              selectionCtx.beginPath();
              selectionCtx.fillStyle = '#ffffff';
              selectionCtx.arc(cx, cy, rInner, 0, Math.PI * 2);
              selectionCtx.fill();
            } catch {}
          } else {
            // Very small: approximate with black box and white center pixel
            try { selectionCtx.fillStyle = '#000000'; selectionCtx.fillRect(x, y, s, s); } catch {}
            try { const cxp = x + Math.floor(s/2); const cyp = y + Math.floor(s/2); selectionCtx.fillStyle = '#ffffff'; selectionCtx.fillRect(cxp, cyp, 1, 1); } catch {}
          }
        };
        // Draw global selections (world coords)
        try {
          if (readyGlobalSelected && readyGlobalSelected.size > 0) {
            readyGlobalSelected.forEach(rec => {
              if (!rec) return;
              const p = worldToScreen(rec.wx, rec.wy);
              const x = Math.floor(p.x * dpr);
              const y = Math.floor(p.y * dpr);
              const s = Math.max(1, Math.floor(state.scale * dpr));
              drawPixel(x, y, s, rec.colorId, '#ffffff');
            });
          }
        } catch {}
        // Draw per-image selections
        try {
          const sel = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
          if (sel) {
            const map = getSelectedMap(sel);
            if (map && map.size > 0) {
              map.forEach(rec => {
                if (!rec) return;
                const wx = (sel.worldX || 0) + rec.x;
                const wy = (sel.worldY || 0) + rec.y;
                const p = worldToScreen(wx, wy);
                const x = Math.floor(p.x * dpr);
                const y = Math.floor(p.y * dpr);
                const s = Math.max(1, Math.floor(state.scale * dpr));
                drawPixel(x, y, s, rec.colorId, '#22d3ee');
              });
            }
          }
        } catch {}
      } catch {}
    }
    function ensureBaseImageData(){
      if (!img) return null;
      const w = img.width|0, h = img.height|0;
      if (baseImageData && baseImageData.width === w && baseImageData.height === h) return baseImageData;
      try {
        const off = document.createElement('canvas'); off.width = w; off.height = h;
        const octx = off.getContext('2d', { willReadFrequently: true });
        octx.drawImage(img, 0, 0);
        baseImageData = octx.getImageData(0, 0, w, h);
        return baseImageData;
      } catch { return null; }
    }

    function isSameColorAsBase(item, sx, sy){
      // Compare against composite (base + overlays) so seam tiles are handled
      const itemColor = getItemPixelColor(item, sx, sy);
      if (!itemColor || itemColor.a === 0) return false;
      const wx = Math.round((item.worldX || 0) + sx);
      const wy = Math.round((item.worldY || 0) + sy);
      const baseColor = getCompositeColorAtWorld(wx, wy);
      if (!baseColor || baseColor.a === 0) return false;
      return (itemColor.r === baseColor.r) && (itemColor.g === baseColor.g) && (itemColor.b === baseColor.b);
    }
    function isSamePaletteIdAsBase(item, sx, sy) {
      const itemColor = getItemPixelColor(item, sx, sy);
      if (!itemColor || itemColor.a === 0) {
        return false;
      }
      const wx = Math.round((item.worldX || 0) + sx);
      const wy = Math.round((item.worldY || 0) + sy);
      const baseColor = getCompositeColorAtWorld(wx, wy);
      if (!baseColor || baseColor.a === 0) {
        return false;
      }
      const itemPaletteId = rgbToPaletteId(itemColor.r, itemColor.g, itemColor.b);
      const basePaletteId = rgbToPaletteId(baseColor.r, baseColor.g, baseColor.b);
      return itemPaletteId === basePaletteId;
    }

    function countPlacedPixelsForItem(item){
      const itemId = ensureItemImageData(item);
      const baseId = ensureBaseImageData();
      if (!itemId || !baseId) return 0;
      const wx0 = Math.round(item.worldX || 0);
      const wy0 = Math.round(item.worldY || 0);
      const nowMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const cache = item._placedCountCache;
      if (cache && cache.baseW === baseId.width && cache.baseH === baseId.height && cache.wx0 === wx0 && cache.wy0 === wy0 && cache.ovVer === overlayVersion && (nowMs - cache.atMs) < 1000) {
        return cache.count;
      }
      let count = 0;
      const w = itemId.width|0, h = itemId.height|0;
      const itemData = itemId.data;
      // Compute composite bounds (base + any unlocked neighbor overlays), capped to 3x3
      let b = null;
      try { b = getCompositeBounds(getAllowedPlacementRects()); } catch { b = { minX: 0, minY: 0, maxX: baseId.width|0, maxY: baseId.height|0 }; }
      for (let y = 0; y < h; y++){
        const wy = wy0 + y;
        if (b && (wy < b.minY || wy >= b.maxY)) continue;
        for (let x = 0; x < w; x++){
          const wx = wx0 + x;
          if (b && (wx < b.minX || wx >= b.maxX)) continue;
          const iItem = ((w * y + x) << 2);
          const a = itemData[iItem + 3];
          if (a === 0) continue;
          const col = getCompositeColorAtWorld(wx, wy);
          if (!col || col.a === 0) continue;
          if (itemData[iItem] === col.r && itemData[iItem+1] === col.g && itemData[iItem+2] === col.b) {
            count++;
          }
        }
      }
      item._placedCountCache = { count, wx0, wy0, baseW: baseId.width, baseH: baseId.height, ovVer: overlayVersion, atMs: nowMs };
      return count;
    }

    // Allowed placement rectangles: base tile + any neighbor overlays
    function getAllowedPlacementRects(){
      const rects = [];
      if (img && img.width && img.height) {
        rects.push({ x0: 0, y0: 0, x1: img.width|0, y1: img.height|0 });
      }
      try {
        if (neighborOverlays && neighborOverlays.size > 0) {
          const w = img ? (img.width|0) : 0;
          const h = img ? (img.height|0) : 0;
          neighborOverlays.forEach(ov => {
            if (!ov) return;
            const col = ov.col|0, row = ov.row|0;
            rects.push({ x0: col * w, y0: row * h, x1: col * w + w, y1: row * h + h });
          });
        }
      } catch {}
      // Add selected overlay as an allowed placement rectangle
      try {
        if (selectedOverlayIndex !== -1 && savedOverlays[selectedOverlayIndex] && savedOverlays[selectedOverlayIndex].isVisible) {
          const overlayRect = savedOverlays[selectedOverlayIndex].rect;
          rects.push({ x0: overlayRect.x, y0: overlayRect.y, x1: overlayRect.x + overlayRect.w, y1: overlayRect.y + overlayRect.h });
        }
      } catch {}
      // Always cap to 3x3 region around base tile to match visual clipping
      try {
        const w = img ? (img.width|0) : 0;
        const h = img ? (img.height|0) : 0;
        const cap = { x0: -w, y0: -h, x1: 2*w, y1: 2*h };
        for (let i = 0; i < rects.length; i++) {
          const r = rects[i];
          if (!r) continue;
          r.x0 = Math.max(r.x0, cap.x0);
          r.y0 = Math.max(r.y0, cap.y0);
          r.x1 = Math.min(r.x1, cap.x1);
          r.y1 = Math.min(r.y1, cap.y1);
        }
      } catch {}
      return rects;
    }
    function getCompositeBounds(rects){
      if (!rects || rects.length === 0) return { minX: 0, minY: 0, maxX: img ? (img.width|0) : 0, maxY: img ? (img.height|0) : 0 };
      let minX = rects[0].x0, minY = rects[0].y0, maxX = rects[0].x1, maxY = rects[0].y1;
      for (let i = 1; i < rects.length; i++) {
        const r = rects[i];
        if (!r) continue;
        if (r.x0 < minX) minX = r.x0;
        if (r.y0 < minY) minY = r.y0;
        if (r.x1 > maxX) maxX = r.x1;
        if (r.y1 > maxY) maxY = r.y1;
      }
      return { minX, minY, maxX, maxY };
    }
    function isWithinAllowedPlacement(x, y, w, h){
      const rects = getAllowedPlacementRects();
      for (let i = 0; i < rects.length; i++) {
        const r = rects[i];
        if (!r) continue;
        if (x >= r.x0 && y >= r.y0 && (x + w) <= r.x1 && (y + h) <= r.y1) return true;
      }
      return false;
    }
    // Returns true if the rect overlaps allowed area by at least minPixels
    function isPartiallyWithinAllowedPlacement(x, y, w, h, minPixels){
      const rects = getAllowedPlacementRects();
      const minPx = Math.max(1, Number(minPixels || 1)|0);
      for (let i = 0; i < rects.length; i++) {
        const r = rects[i];
        if (!r) continue;
        const ix0 = Math.max(x, r.x0);
        const iy0 = Math.max(y, r.y0);
        const ix1 = Math.min(x + w, r.x1);
        const iy1 = Math.min(y + h, r.y1);
        const iw = (ix1 - ix0)|0;
        const ih = (iy1 - iy0)|0;
        if (iw >= 1 && ih >= 1 && (iw * ih) >= minPx) return true;
      }
      return false;
    }

    function snapItemToNearest(item, targetX, targetY){
      let nx = Math.round(targetX || 0), ny = Math.round(targetY || 0);

      if (!img) {
        return { x: nx, y: ny };
      }

      const rects = getAllowedPlacementRects();
      // If there are no allowed placement rectangles (e.g., no base image or overlays),
      // or if there's a selected overlay, strictly clamp to that overlay's bounds.
      if (!rects || rects.length === 0 || (selectedOverlayIndex !== -1 && savedOverlays[selectedOverlayIndex] && savedOverlays[selectedOverlayIndex].isVisible)) {
        const iw = item.image ? (item.image.naturalWidth || 0) : 0;
        const ih = item.image ? (item.image.naturalHeight || 0) : 0;
        
        // If an overlay is selected, clamp to its bounds
        if (selectedOverlayIndex !== -1 && savedOverlays[selectedOverlayIndex] && savedOverlays[selectedOverlayIndex].isVisible) {
          const overlayRect = savedOverlays[selectedOverlayIndex].rect;
          const minXo = overlayRect.x;
          const minYo = overlayRect.y;
          const maxXo = overlayRect.x + overlayRect.w - iw;
          const maxYo = overlayRect.y + overlayRect.h - ih;

          nx = Math.min(Math.max(minXo, nx), maxXo);
          ny = Math.min(Math.max(minYo, ny), maxYo);
        } else { // Fallback to base image bounds if no specific overlay is selected
          const minXb = 0;
          const minYb = 0;
          const maxXb = img.width - iw;
          const maxYb = img.height - ih;

          nx = Math.min(Math.max(minXb, nx), maxXb);
          ny = Math.min(Math.max(minYb, ny), maxYb);
        }
        return { x: nx, y: ny };
      }

      // Original snapping logic for multiple allowed rectangles (3x3 grid, etc.)
      const bounds = getCompositeBounds(rects);
      const id = ensureItemImageData(item);
      const iw = id && id.width ? id.width : 0;
      const ih = id && id.height ? id.height : 0;

      const minXb = (bounds.minX|0) - iw + 1;
      const minYb = (bounds.minY|0) - ih + 1;
      const maxXb = (bounds.maxX|0) - 1;
      const maxYb = (bounds.maxY|0) - 1;
      const rx = Math.round(Math.min(Math.max(minXb, targetX), maxXb));
      const ry = Math.round(Math.min(Math.max(minYb, targetY), maxYb));
      let bestX = rx, bestY = ry, bestScore = -1;
      const radius = 2;
      const minX = Math.max(minXb, rx - radius), maxXn = Math.min(maxXb, rx + radius);
      const minY = Math.max(minYb, ry - radius), maxYn = Math.min(maxYb, ry + radius);
      const stride = Math.max(1, Math.floor(Math.min(iw, ih) / 64)); // Use iw, ih here
      for (let oy = minY; oy <= maxYn; oy++) {
        for (let ox = minX; ox <= maxXn; ox++) {
          if (!isPartiallyWithinAllowedPlacement(ox, oy, iw, ih, 1)) continue; // Use iw, ih here
          let score = 0;
          for (let sy = 0; sy < ih; sy += stride) { // Use ih here
            const by = oy + sy;
            let iItem = ((iw * sy) << 2); // Use iw here
            for (let sx = 0; sx < iw; sx += stride) { // Use iw here
              const a = id.data[iItem + 3];
              if (a !== 0) {
                const r1 = id.data[iItem], g1 = id.data[iItem+1], b1 = id.data[iItem+2];
                const bx = ox + sx;
                const col = getCompositeColorAtWorld(bx, by);
                if (col && col.a !== 0 && col.r === r1 && col.g === g1 && col.b === b1) score++;
              }
              iItem += (stride << 2);
            }
          }
          if (score > bestScore) { bestScore = score; bestX = ox; bestY = oy; }
        }
      }
      return { x: bestX, y: bestY };
    }

    function hideEl(el){ try { if (el) el.hidden = true; } catch {} }

    function updatePixelMarkers(){
      const hideHover = !!(state.dragging || state.zooming);
      if (!isReadyOpen()) {
        hideEl(pixelHoverEl);
        try { pixelHoverFillEl.hidden = true; } catch {}
        if (pixelSelectedList) pixelSelectedList.hidden = true;
        drawSelectionOverlay();
        return;
      }
      if (readyGlobalMode) {
        
        // Global selections drawn by overlay
        drawSelectionOverlay();
        
        try { if (!hideHover) { pixelHoverEl.hidden = false; pixelHoverEl.src = HOVER_ICON_SRC; } else { hideEl(pixelHoverEl); } } catch {}
        try {
          if (!hideHover && selectedOverrideColorId != null && selectedOverrideColorId !== 0 && readyHoverPixel && readyHoverPixel.x != null && readyHoverPixel.y != null) {
            pixelHoverFillEl.src = getMarkerSrcForColorId(selectedOverrideColorId);
            positionPixelMarkerAtWorld(pixelHoverFillEl, readyHoverPixel.x, readyHoverPixel.y);
            pixelHoverFillEl.hidden = false;
          } else {
            pixelHoverFillEl.hidden = true;
          }
        } catch {}
        
        try {
          const sel = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
          if (sel) {
            const map = getSelectedMap(sel);
            if (pixelSelectedList) pixelSelectedList.hidden = (readyGlobalSelected.size === 0) && (!map || map.size === 0);
          } else {
            if (pixelSelectedList) pixelSelectedList.hidden = readyGlobalSelected.size === 0;
          }
        } catch {}
        return;
      }
      const sel = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
      if (!sel || !sel.image || !sel.image.complete) { hideEl(pixelHoverEl); try { pixelHoverFillEl.hidden = true; } catch {}; if (pixelSelectedList) pixelSelectedList.hidden = true; return; }
      ensureRenderedSelectedForItem(sel);
      positionSelectedMarkersForItem(sel);
      drawSelectionOverlay();
      
      // Global selections drawn by overlay
      if (pixelSelectedList) {
        const perImageCount = getSelectedMap(sel).size;
        const globalCount = readyGlobalSelected ? readyGlobalSelected.size : 0;
        pixelSelectedList.hidden = (perImageCount + globalCount) === 0;
      }
      if (!hideHover && readyHoverPixel && readyHoverPixel.x != null && readyHoverPixel.y != null) {
        positionPixelMarker(pixelHoverEl, sel, readyHoverPixel.x, readyHoverPixel.y);
        try {
          if (!hideHover && selectedOverrideColorId != null && selectedOverrideColorId !== 0) {
            pixelHoverFillEl.src = getMarkerSrcForColorId(selectedOverrideColorId);
            positionPixelMarker(pixelHoverFillEl, sel, readyHoverPixel.x, readyHoverPixel.y);
            pixelHoverFillEl.hidden = false;
          } else {
            pixelHoverFillEl.hidden = true;
          }
        } catch {}
      } else {
        hideEl(pixelHoverEl);
        try { pixelHoverFillEl.hidden = true; } catch {}
      }
    }

    function updateReadyHoverFromEvent(e){
      if (!isReadyOpen()) { hideEl(pixelHoverEl); return; }
      
      try {
        const t = e && e.target ? e.target : null;
        const overUi = !!(t && t.closest && (
          t.closest('#control-panel') ||
          t.closest('#ready-popup') ||
          t.closest('#sidebar') ||
          t.closest('#color-palette')
        ));
        if (overUi) {
          readyHoverPixel.x = null; readyHoverPixel.y = null;
          hideEl(pixelHoverEl);
          try { pixelHoverFillEl.hidden = true; } catch {}
          return;
        }
      } catch {}
      if (readyGlobalMode) {
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        const worldX = (px - state.translateX) / state.scale;
        const worldY = (py - state.translateY) / state.scale;
        const wx = Math.floor(worldX);
        const wy = Math.floor(worldY);
        
        if (img && wx >= 0 && wy >= 0 && wx < img.width && wy < img.height) {
          readyHoverPixel.x = wx; readyHoverPixel.y = wy;
          try { pixelHoverEl.src = HOVER_ICON_SRC; positionPixelMarkerAtWorld(pixelHoverEl, wx, wy); pixelHoverEl.hidden = false; } catch {}
          try {
            if (selectedOverrideColorId != null && selectedOverrideColorId !== 0) {
              pixelHoverFillEl.src = getMarkerSrcForColorId(selectedOverrideColorId);
              positionPixelMarkerAtWorld(pixelHoverFillEl, wx, wy);
              pixelHoverFillEl.hidden = false;
            } else {
              pixelHoverFillEl.hidden = true;
            }
          } catch {}
        } else {
          readyHoverPixel.x = null; readyHoverPixel.y = null; hideEl(pixelHoverEl); try { pixelHoverFillEl.hidden = true; } catch {}
        }
        return;
      }
      const sel = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
      if (!sel || !sel.image || !sel.image.complete) { hideEl(pixelHoverEl); return; }
      try { pixelHoverEl.src = HOVER_ICON_SRC; } catch {}
      const rect = canvas.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      const worldX = (px - state.translateX) / state.scale;
      const worldY = (py - state.translateY) / state.scale;
      const lx = Math.floor(worldX - (sel.worldX || 0));
      const ly = Math.floor(worldY - (sel.worldY || 0));
      if (lx >= 0 && ly >= 0 && lx < sel.image.naturalWidth && ly < sel.image.naturalHeight && isOpaquePixel(sel, lx, ly)) {
        readyHoverPixel.x = lx; readyHoverPixel.y = ly;
        positionPixelMarker(pixelHoverEl, sel, lx, ly);
        try {
          if (selectedOverrideColorId != null && selectedOverrideColorId !== 0) {
            pixelHoverFillEl.src = getMarkerSrcForColorId(selectedOverrideColorId);
            positionPixelMarker(pixelHoverFillEl, sel, lx, ly);
            pixelHoverFillEl.hidden = false;
          } else {
            pixelHoverFillEl.hidden = true;
          }
        } catch {}
      } else {
        readyHoverPixel.x = null; readyHoverPixel.y = null; hideEl(pixelHoverEl); try { pixelHoverFillEl.hidden = true; } catch {}
      }
    }

    
    const PALETTE = [
      { id: 1, rgb: [0, 0, 0] },
      { id: 2, rgb: [60, 60, 60] },
      { id: 3, rgb: [120, 120, 120] },
      { id: 4, rgb: [210, 210, 210] },
      { id: 5, rgb: [255, 255, 255] },
      { id: 6, rgb: [96, 0, 24] },
      { id: 7, rgb: [237, 28, 36] },
      { id: 8, rgb: [255, 127, 39] },
      { id: 9, rgb: [246, 170, 9] },
      { id: 10, rgb: [249, 221, 59] },
      { id: 11, rgb: [255, 250, 188] },
      { id: 12, rgb: [14, 185, 104] },
      { id: 13, rgb: [19, 230, 123] },
      { id: 14, rgb: [135, 255, 94] },
      { id: 15, rgb: [12, 129, 110] },
      { id: 16, rgb: [16, 174, 166] },
      { id: 17, rgb: [19, 225, 190] },
      { id: 18, rgb: [40, 80, 158] },
      { id: 19, rgb: [64, 147, 228] },
      { id: 20, rgb: [96, 247, 242] },
      { id: 21, rgb: [107, 80, 246] },
      { id: 22, rgb: [153, 177, 251] },
      { id: 23, rgb: [120, 12, 153] },
      { id: 24, rgb: [170, 56, 185] },
      { id: 25, rgb: [224, 159, 249] },
      { id: 26, rgb: [203, 0, 122] },
      { id: 27, rgb: [236, 31, 128] },
      { id: 28, rgb: [243, 141, 169] },
      { id: 29, rgb: [104, 70, 52] },
      { id: 30, rgb: [149, 104, 42] },
      { id: 31, rgb: [248, 178, 119] }
    ];
    if (!ACTIVE_PALETTE) { ACTIVE_PALETTE = PALETTE.slice(); }
    function setupColorPalette(){
      if (!colorPaletteEl) return;
      colorPaletteEl.innerHTML = '';
      
      const swT = document.createElement('div');
      //swT.className = 'palette-swatch transparent selected';
      swT.className = 'palette-swatch transparent'; // Bỏ 'selected' mặc định
      swT.title = t('palette.transparentTitle');
      swT.setAttribute('role', 'button');
      swT.addEventListener('click', () => {
        // Chuyển đổi trạng thái isEraserMode
        isEraserMode = !isEraserMode; 
        updateEraserButtonUi(); // Cập nhật UI nút tẩy
        if (isEraserMode) {
            selectedOverrideColorId = null; // Chọn màu trong suốt
        } else {
            // Nếu thoát chế độ tẩy, chọn lại màu mặc định hoặc màu đã chọn trước đó (nếu có)
            selectedOverrideColorId = parseInt(localStorage.getItem('palette.selectedColorId') || PALETTE[0].id, 10);
        }
        try {
          const rp = document.getElementById('ready-popup');
          const wasReadyOpen = !!(rp && !rp.hidden);
          const wasGlobal = !!readyGlobalMode;
          const hadGlobalSelections = !!(readyGlobalSelected && readyGlobalSelected.size > 0);
          
          readyGlobalMode = false;
          // Switch back to per-image mode without generic resets
          updatePaletteSelectionUi();
          try { updateReadyButtonEnabled(); } catch {}
          try { updateReadySelectionLabel(); } catch {}
          try { updatePixelMarkers(); } catch {}
          // Special case: If Ready is open and user was in global color mode and had placed selections,
          // clear ONLY global selections and close the Ready popup
          if (wasReadyOpen && wasGlobal && hadGlobalSelections) {
            try {
              readyGlobalSelected.forEach(rec => {
                try { if (rec && rec.el && rec.el.parentNode) rec.el.parentNode.removeChild(rec.el); } catch {}
                try { if (rec && rec.fillEl && rec.fillEl.parentNode) rec.fillEl.parentNode.removeChild(rec.fillEl); } catch {}
              });
              readyGlobalSelected.clear();
            } catch {}
            // Bỏ dòng resetReadyNow() để không tự thoát ready popup
            // try { resetReadyNow(); } catch {}
          }
        } catch {
          selectedOverrideColorId = null;
          if (!isEraserMode) { // Nếu không phải chế độ tẩy, khôi phục màu đã chọn trước đó
             selectedOverrideColorId = parseInt(localStorage.getItem('palette.selectedColorId') || PALETTE[0].id, 10);
          }
          readyGlobalMode = false;
          updatePaletteSelectionUi();
          try { updateReadyButtonEnabled(); } catch {}
          try { updateReadySelectionLabel(); } catch {}
          try { updatePixelMarkers(); } catch {}
        }
      });
      colorPaletteEl.appendChild(swT);
      // Thêm event listener cho nút tẩy
      if (eraserButton) {
          eraserButton.addEventListener('click', () => {
              isEraserMode = !isEraserMode;
              updateEraserButtonUi();
              if (isEraserMode) {
                  selectedOverrideColorId = null; // Chế độ tẩy = màu trong suốt
              } else {
                  selectedOverrideColorId = parseInt(localStorage.getItem('palette.selectedColorId') || PALETTE[0].id, 10); // Khôi phục màu đã chọn
              }
              updatePaletteSelectionUi();
              try { updateReadyButtonEnabled(); } catch {}
              try { updateReadySelectionLabel(); } catch {}
              try { updatePixelMarkers(); } catch {}
          });
      }

      
      const arr = (ACTIVE_PALETTE && Array.isArray(ACTIVE_PALETTE)) ? ACTIVE_PALETTE : PALETTE;
      for (let i = 0; i < arr.length; i++){
        const p = arr[i];
        const el = document.createElement('div');
        el.className = 'palette-swatch';
        el.style.backgroundColor = 'rgb(' + p.rgb[0] + ',' + p.rgb[1] + ',' + p.rgb[2] + ')';
        setPaletteSwatchTitle(el, p);
        el.setAttribute('data-id', String(p.id));
        el.setAttribute('role', 'button');
        el.addEventListener('click', () => {
          // Block choosing a premium override color if no selected accounts can provide it or capacity is 0
          if (isPremiumColorId(p.id)) {
            const providers = getAccountsProvidingColor(p.id);
            const remain = getPremiumColorRemainingLimit(p.id);
            if (!(Array.isArray(providers) && providers.length > 0 && remain > 0)) {
              try { showToast(t('messages.premiumColorLimitReached'), 'error', 2000); } catch {}
              return;
            }
          }
          selectedOverrideColorId = p.id;
          try { localStorage.setItem('palette.selectedColorId', String(p.id)); } catch {}
          
          try {
            const rp = document.getElementById('ready-popup');
            if (rp && !rp.hidden) {
              const hasSelectedSign = (selectedIndex >= 0 && selectedIndex < signItems.length);
              // Enable global mode only if no image is selected; otherwise stay in per-image mode
              readyGlobalMode = !hasSelectedSign;
            }
          } catch {}
          updatePaletteSelectionUi();
          try { updateReadyButtonEnabled(); } catch {}
          try { updateReadySelectionLabel(); } catch {}
          try { updatePixelMarkers(); } catch {}
        });
        colorPaletteEl.appendChild(el);
      }
      // Block (remove) swatch → sends color id 0 and shows no fill overlay
      const swB = document.createElement('div');
      swB.className = 'palette-swatch block';
      swB.title = 'Block';
      swB.setAttribute('role', 'button');
      swB.setAttribute('data-id', '0');
      swB.addEventListener('click', () => {
        selectedOverrideColorId = 0;
        
        try {
          const rp = document.getElementById('ready-popup');
          if (rp && !rp.hidden) {
            const hasSelectedSign = (selectedIndex >= 0 && selectedIndex < signItems.length);
            readyGlobalMode = !hasSelectedSign;
          }
        } catch {}
        updatePaletteSelectionUi();
        try { updateReadyButtonEnabled(); } catch {}
        try { updateReadySelectionLabel(); } catch {}
        try { updatePixelMarkers(); } catch {}
      });
      colorPaletteEl.appendChild(swB);
      updatePaletteSelectionUi();
      try { refreshPaletteTooltips(); } catch {}
    }
    function updateReadyButtonEnabled(){
      try {
        const btn = document.getElementById('btn-ready');
        if (!btn) return;
        btn.disabled = !(
          (selectedIndex >= 0 && selectedIndex < signItems.length) ||
          (selectedOverrideColorId != null)
        );
      } catch {}
    }
    function openReadyOnPaletteClick(){  }
    function updatePaletteSelectionUi(){
      if (!colorPaletteEl) return;
      const swatches = Array.from(colorPaletteEl.querySelectorAll('.palette-swatch'));
      swatches.forEach(sw => {
        const idAttr = sw.getAttribute('data-id');
        const id = idAttr == null ? null : Number(idAttr);
        const isSelected = (idAttr == null && selectedOverrideColorId == null) || (idAttr != null && id === selectedOverrideColorId);
        sw.classList.toggle('selected', !!isSelected);

        // Update disabled state based on current paletteMode and account ownership
        const isPremium = isPremiumColorId(id);
        const hasAccountSupport = isPremium ? (getAccountsProvidingColor(id).length > 0) : true;
        const isDisabledForMode = (paletteMode === 'free' && isPremium);

        if (isDisabledForMode || !hasAccountSupport) {
            sw.classList.add('disabled');
            sw.setAttribute('aria-disabled', 'true');
        } else {
            sw.classList.remove('disabled');
            sw.removeAttribute('aria-disabled');
        }
      });
    }

    const COLOR_DIFFERENCE_THRESHOLD = 3; // Ngưỡng khác biệt màu sắc (tùy chỉnh)

    function areColorsSignificantlyDifferent(color1, color2, threshold = COLOR_DIFFERENCE_THRESHOLD) {
      if (!color1 || !color2) return true; // Nếu một trong hai màu không tồn tại, coi là khác biệt
      // Chuyển đổi RGB sang LAB để tính toán khoảng cách màu chính xác hơn
      const lab1 = srgbToLab(color1.r, color1.g, color1.b);
      const lab2 = srgbToLab(color2.r, color2.g, color2.b);
      
      // Tính toán khoảng cách Delta E 2000
      const deltaE = ciede2000(lab1, lab2);
      
      return deltaE > threshold;
    }

    function squaredDistance(r1,g1,b1, r2,g2,b2){
      const dr=r1-r2, dg=g1-g2, db=b1-b2; return dr*dr+dg*dg+db*db;
    }
    function srgbToXyz(r,g,b){
      let sr=r/255, sg=g/255, sb=b/255;
      const toLin=(u)=> (u<=0.04045)?(u/12.92):Math.pow((u+0.055)/1.055,2.4);
      sr=toLin(sr); sg=toLin(sg); sb=toLin(sb);
      const x=sr*0.4124 + sg*0.3576 + sb*0.1805;
      const y=sr*0.2126 + sg*0.7152 + sb*0.0722;
      const z=sr*0.0193 + sg*0.1192 + sb*0.9505;
      return [x,y,z];
    }
    function xyzToLab(x,y,z){
      const xn=0.95047, yn=1.0, zn=1.08883;
      x/=xn; y/=yn; z/=zn;
      const f=(t)=> t>0.008856?Math.cbrt(t):(7.787*t + 16/116);
      const fx=f(x), fy=f(y), fz=f(z);
      return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
    }
    function srgbToLab(r,g,b){
      const xyz=srgbToXyz(r,g,b); return xyzToLab(xyz[0],xyz[1],xyz[2]);
    }
    function srgbToOklab(r,g,b){
      let sr=r/255, sg=g/255, sb=b/255;
      const toLin=(u)=> (u<=0.04045)?(u/12.92):Math.pow((u+0.055)/1.055,2.4);
      sr=toLin(sr); sg=toLin(sg); sb=toLin(sb);
      const l=0.4122214708*sr + 0.5363325363*sg + 0.0514459929*sb;
      const m=0.2119034982*sr + 0.6806995451*sg + 0.1073969566*sb;
      const s=0.0883024619*sr + 0.2817188376*sg + 0.6299787005*sb;
      const l_=Math.cbrt(l), m_=Math.cbrt(m), s_=Math.cbrt(s);
      return [
        0.2104542553*l_ + 0.7936177850*m_ - 0.0040720468*s_,
        1.9779984951*l_ - 2.4285922050*m_ + 0.4505937099*s_,
        0.0259040371*l_ + 0.7827717662*m_ - 0.8086757660*s_
      ];
    }
    function ciede2000(lab1, lab2){
      const [L1,a1,b1]=lab1; const [L2,a2,b2]=lab2;
      const avgLp=(L1+L2)/2;
      const C1=Math.hypot(a1,b1); const C2=Math.hypot(a2,b2);
      const avgC=(C1+C2)/2;
      const G=0.5*(1-Math.sqrt(Math.pow(avgC,7)/(Math.pow(avgC,7)+Math.pow(25,7))));
      const a1p=(1+G)*a1; const a2p=(1+G)*a2;
      const C1p=Math.hypot(a1p,b1); const C2p=Math.hypot(a2p,b2);
      const avgCp=(C1p+C2p)/2;
      let h1p=Math.atan2(b1,a1p); if (h1p<0) h1p+=2*Math.PI;
      let h2p=Math.atan2(b2,a2p); if (h2p<0) h2p+=2*Math.PI;
      let deltahp;
      const diffh=h2p-h1p;
      if (isNaN(h1p) || isNaN(h2p)) deltahp=0;
      else if (Math.abs(diffh)<=Math.PI) deltahp=diffh;
      else if (diffh>Math.PI) deltahp=diffh-2*Math.PI;
      else deltahp=diffh+2*Math.PI;
      const deltaLp=L2-L1;
      const deltaCp=C2p-C1p;
      const deltaHp=2*Math.sqrt(C1p*C2p)*Math.sin(deltahp/2);
      const avgLpMinus50Sq=Math.pow(avgLp-50,2);
      const Sl=1+(0.015*avgLpMinus50Sq)/Math.sqrt(20+avgLpMinus50Sq);
      const Sc=1+0.045*avgCp;
      const T=1-0.17*Math.cos((h1p+h2p)/2 - Math.PI/6) + 0.24*Math.cos(2*(h1p+h2p)/2) + 0.32*Math.cos(3*(h1p+h2p)/2 + Math.PI/30) - 0.20*Math.cos(4*(h1p+h2p)/2 - 63*Math.PI/180);
      const Sh=1+0.015*avgCp*T;
      const deltaTheta=30*Math.PI/180*Math.exp(-Math.pow(((h1p+h2p)/2 - 275*Math.PI/180)/(25*Math.PI/180),2));
      const Rc=2*Math.sqrt(Math.pow(avgCp,7)/(Math.pow(avgCp,7)+Math.pow(25,7)));
      const Rt=-Rc*Math.sin(2*deltaTheta);
      return Math.sqrt(Math.pow(deltaLp/Sl,2)+Math.pow(deltaCp/Sc,2)+Math.pow(deltaHp/Sh,2)+Rt*(deltaCp/Sc)*(deltaHp/Sh));
    }
    let PALETTE_LAB = [];
    let PALETTE_OKLAB = [];
    let EXACT_PALETTE_MAP = new Map();
    function recomputePaletteCaches(){
      try {
        const arrActive = (ACTIVE_PALETTE && Array.isArray(ACTIVE_PALETTE)) ? ACTIVE_PALETTE : PALETTE;
        const arrLab = [];
        const arrOk = [];
        const m = new Map();
        for (let i = 0; i < arrActive.length; i++){
          const p = arrActive[i];
          const lab = srgbToLab(p.rgb[0], p.rgb[1], p.rgb[2]);
          const ok = srgbToOklab(p.rgb[0], p.rgb[1], p.rgb[2]);
          arrLab.push({ id: p.id, lab, rgb: p.rgb });
          arrOk.push({ id: p.id, oklab: ok, rgb: p.rgb });
          m.set(String(p.rgb[0]) + ',' + String(p.rgb[1]) + ',' + String(p.rgb[2]), p.id);
        }
        PALETTE_LAB = arrLab;
        PALETTE_OKLAB = arrOk;
        EXACT_PALETTE_MAP = m;
      } catch {}
    }
    try { recomputePaletteCaches(); } catch {}
    function nearestPaletteColor(r,g,b, metric){
      const arr = (ACTIVE_PALETTE && Array.isArray(ACTIVE_PALETTE)) ? ACTIVE_PALETTE : PALETTE;
      if (metric === 'oklab'){
        const ok = srgbToOklab(r,g,b);
        let best = arr[0].rgb, bestD = Infinity;
        for (let i = 0; i < PALETTE_OKLAB.length; i++){
          const q = PALETTE_OKLAB[i];
          const dL = ok[0]-q.oklab[0], dA = ok[1]-q.oklab[1], dB = ok[2]-q.oklab[2];
          const d = dL*dL + dA*dA + dB*dB;
          if (d < bestD){ bestD = d; best = q.rgb; if (d === 0) break; }
        }
        return best;
      } else if (metric === 'lab' || metric === 'ciede2000'){
        const lab = srgbToLab(r,g,b);
        let best = arr[0].rgb, bestD = Infinity;
        for (let i = 0; i < PALETTE_LAB.length; i++){
          const q = PALETTE_LAB[i];
          let d;
          if (metric === 'lab'){
            const dL = lab[0]-q.lab[0], dA = lab[1]-q.lab[1], dB = lab[2]-q.lab[2];
            d = dL*dL + dA*dA + dB*dB;
          } else {
            d = ciede2000(lab, q.lab);
          }
          if (d < bestD){ bestD = d; best = q.rgb; if (d === 0) break; }
        }
        return best;
      } else {
        let best = arr[0].rgb, bestD = Infinity;
        for (let i = 0; i < arr.length; i++){
          const p = arr[i].rgb;
          const d = squaredDistance(r,g,b,p[0],p[1],p[2]);
          if (d < bestD){ bestD = d; best = p; if (d === 0) break; }
        }
        return best;
      }
    }
    function nearestPaletteId(r,g,b, metric){
      const arr = (ACTIVE_PALETTE && Array.isArray(ACTIVE_PALETTE)) ? ACTIVE_PALETTE : PALETTE;
      if (metric === 'oklab'){
        const ok = srgbToOklab(r,g,b);
        let bestId = arr[0].id, bestD = Infinity;
        for (let i = 0; i < PALETTE_OKLAB.length; i++){
          const q = PALETTE_OKLAB[i];
          const dL = ok[0]-q.oklab[0], dA = ok[1]-q.oklab[1], dB = ok[2]-q.oklab[2];
          const d = dL*dL + dA*dA + dB*dB;
          if (d < bestD){ bestD = d; bestId = q.id; if (d === 0) break; }
        }
        return bestId;
      } else if (metric === 'lab' || metric === 'ciede2000'){
        const lab = srgbToLab(r,g,b);
        let bestId = arr[0].id, bestD = Infinity;
        for (let i = 0; i < PALETTE_LAB.length; i++){
          const q = PALETTE_LAB[i];
          let d;
          if (metric === 'lab'){
            const dL = lab[0]-q.lab[0], dA = lab[1]-q.lab[1], dB = lab[2]-q.lab[2];
            d = dL*dL + dA*dA + dB*dB;
          } else {
            d = ciede2000(lab, q.lab);
          }
          if (d < bestD){ bestD = d; bestId = q.id; if (d === 0) break; }
        }
        return bestId;
      } else {
        let bestId = arr[0].id, bestD = Infinity;
        for (let i = 0; i < arr.length; i++){
          const p = arr[i].rgb;
          const d = squaredDistance(r,g,b,p[0],p[1],p[2]);
          if (d < bestD){ bestD = d; bestId = arr[i].id; if (d === 0) break; }
        }
        return bestId;
      }
    }
    function rgbToPaletteId(r,g,b){
      const key = String(r) + ',' + String(g) + ',' + String(b);
      if (EXACT_PALETTE_MAP.has(key)) return EXACT_PALETTE_MAP.get(key);
      const metric = imgColorMetricSelect ? imgColorMetricSelect.value : 'oklab';
      return nearestPaletteId(r,g,b, metric);
    }
    function quantizeImageToPalette(image){
      const w=image.naturalWidth|0, h=image.naturalHeight|0;
      const off=document.createElement('canvas'); off.width=w; off.height=h;
      const octx=off.getContext('2d', { willReadFrequently: true });
      octx.imageSmoothingEnabled = false;
      octx.drawImage(image,0,0);
      const id=octx.getImageData(0,0,w,h);
      const data=id.data;
      const alphaTh = imgAlphaInput ? parseInt(imgAlphaInput.value||'0',10) : 0;
      for (let i=0;i<data.length;i+=4){
        data[i+3] = (data[i+3] <= alphaTh) ? 0 : 255;
      }
      const metric = imgColorMetricSelect ? imgColorMetricSelect.value : 'oklab';
      if (imgDitherEnabled){
        const w2 = w + 2;
        const errCurrR = new Float32Array(w2), errCurrG = new Float32Array(w2), errCurrB = new Float32Array(w2);
        const errNextR = new Float32Array(w2), errNextG = new Float32Array(w2), errNextB = new Float32Array(w2);
        for (let y = 0; y < h; y++){
          const leftToRight = (y % 2 === 0);
          for (let i = 0; i < w2; i++){ errCurrR[i]+=0; errCurrG[i]+=0; errCurrB[i]+=0; }
          if (leftToRight){
            for (let x = 0; x < w; x++){
              const idx = (y * w + x) * 4;
              if (data[idx + 3] === 0) continue;
              let r = data[idx] + errCurrR[x+1];
              let g = data[idx+1] + errCurrG[x+1];
              let b = data[idx+2] + errCurrB[x+1];
              r = r < 0 ? 0 : (r > 255 ? 255 : r);
              g = g < 0 ? 0 : (g > 255 ? 255 : g);
              b = b < 0 ? 0 : (b > 255 ? 255 : b);
              const nn = nearestPaletteColor(r,g,b,metric);
              data[idx]=nn[0]; data[idx+1]=nn[1]; data[idx+2]=nn[2];
              const er = r - nn[0];
              const eg = g - nn[1];
              const eb = b - nn[2];
              errCurrR[x+2] += er * (7/16); errCurrG[x+2] += eg * (7/16); errCurrB[x+2] += eb * (7/16);
              errNextR[x  ] += er * (3/16); errNextG[x  ] += eg * (3/16); errNextB[x  ] += eb * (3/16);
              errNextR[x+1] += er * (5/16); errNextG[x+1] += eg * (5/16); errNextB[x+1] += eb * (5/16);
              errNextR[x+2] += er * (1/16); errNextG[x+2] += eg * (1/16); errNextB[x+2] += eb * (1/16);
            }
          } else {
            for (let x = w - 1; x >= 0; x--){
              const idx = (y * w + x) * 4;
              if (data[idx + 3] === 0) continue;
              let r = data[idx] + errCurrR[x+1];
              let g = data[idx+1] + errCurrG[x+1];
              let b = data[idx+2] + errCurrB[x+1];
              r = r < 0 ? 0 : (r > 255 ? 255 : r);
              g = g < 0 ? 0 : (g > 255 ? 255 : g);
              b = b < 0 ? 0 : (b > 255 ? 255 : b);
              const nn = nearestPaletteColor(r,g,b,metric);
              data[idx]=nn[0]; data[idx+1]=nn[1]; data[idx+2]=nn[2];
              const er = r - nn[0];
              const eg = g - nn[1];
              const eb = b - nn[2];
              errCurrR[x  ] += er * (7/16); errCurrG[x  ] += eg * (7/16); errCurrB[x  ] += eb * (7/16);
              errNextR[x+2] += er * (3/16); errNextG[x+2] += eg * (3/16); errNextB[x+2] += eb * (3/16);
              errNextR[x+1] += er * (5/16); errNextG[x+1] += eg * (5/16); errNextB[x+1] += eb * (5/16);
              errNextR[x  ] += er * (1/16); errNextG[x  ] += eg * (1/16); errNextB[x  ] += eb * (1/16);
            }
          }
          for (let i = 0; i < w2; i++){ errCurrR[i] = errNextR[i]; errCurrG[i] = errNextG[i]; errCurrB[i] = errNextB[i]; errNextR[i]=0; errNextG[i]=0; errNextB[i]=0; }
        }
      } else {
        for (let y = 0; y < h; y++){
          for (let x = 0; x < w; x++){
            const idx = (y * w + x) * 4;
            if (data[idx + 3] === 0) continue;
            const nn = nearestPaletteColor(data[idx], data[idx+1], data[idx+2], metric);
            data[idx]=nn[0]; data[idx+1]=nn[1]; data[idx+2]=nn[2];
          }
        }
      }
      octx.putImageData(id,0,0);
      return new Promise((resolve)=>{ off.toBlob((blob)=>resolve(blob), 'image/png'); });
    }

    
    function countNonTransparentPixels(image){
      try {
        const w=image.naturalWidth|0, h=image.naturalHeight|0;
        if (!w || !h) return 0;
        const off=document.createElement('canvas'); off.width=w; off.height=h;
        const octx=off.getContext('2d', { willReadFrequently: true });
        octx.drawImage(image,0,0);
        const id=octx.getImageData(0,0,w,h);
        const data=id.data;
        let cnt=0;
        for(let i=3;i<data.length;i+=4){ if(data[i]!==0) cnt++; }
        return cnt;
      } catch { return 0; }
    }

    
    const COMPOSITE_COLOR_CACHE = new Map();
    const ITEM_PIXEL_PALETTE_ID_CACHE = new Map();

    function clearColorCaches() {
      COMPOSITE_COLOR_CACHE.clear();
      ITEM_PIXEL_PALETTE_ID_CACHE.clear();
    }

    const PIXEL_FONT_5x7 = {
      '0': [
        '01110','10001','10011','10101','11001','10001','01110'
      ],
      '1': [
        '00100','01100','00100','00100','00100','00100','01110'
      ],
      '2': [
        '01110','10001','00001','00010','00100','01000','11111'
      ],
      '3': [
        '11110','00001','00001','01110','00001','00001','11110'
      ],
      '4': [
        '00010','00110','01010','10010','11111','00010','00010'
      ],
      '5': [
        '11111','10000','11110','00001','00001','10001','01110'
      ],
      '6': [
        '00110','01000','10000','11110','10001','10001','01110'
      ],
      '7': [
        '11111','00001','00010','00100','01000','01000','01000'
      ],
      '8': [
        '01110','10001','10001','01110','10001','10001','01110'
      ],
      '9': [
        '01110','10001','10001','01111','00001','00010','11100'
      ],
      'p': [
        '11110','10001','10001','11110','10000','10000','10000'
      ],
      'i': [
        '00100','00000','01100','00100','00100','00100','01110'
      ],
      'x': [
        '10001','01010','00100','01010','10001','00000','00000'
      ],
      'e': [
        '01110','10000','11110','10000','10000','10001','01110'
      ],
      'l': [
        '10000','10000','10000','10000','10000','10000','11111'
      ],
      ' ': [
        '00000','00000','00000','00000','00000','00000','00000'
      ],
      '/': [
        '00001','00010','00100','01000','10000','00000','00000'
      ],
      '-': [
        '00000','00000','00000','11111','00000','00000','00000'
      ],
      '.': [
        '00000','00000','00000','00000','00000','00100','00100'
      ],
      '%': [
        '10001','00010','00100','01000','10000','10001','00000'
      ]
    };

    function measurePixelText(text, pixelSize){
      const glyphW = 5, glyphH = 7, space = 1;
      const cellsW = Math.max(0, text.length * (glyphW + space) - space);
      return { width: cellsW * pixelSize, height: glyphH * pixelSize };
    }

    function drawPixelText(ctx, text, x, y, pixelSize, color){
      const glyphW = 5, glyphH = 7, space = 1;
      let cx = x;
      ctx.save();
      ctx.fillStyle = color || '#fff';
      for(let k=0;k<text.length;k++){
        const ch = text[k].toLowerCase();
        const g = PIXEL_FONT_5x7[ch] || PIXEL_FONT_5x7[' '];
        for(let r=0;r<glyphH;r++){
          const row = g[r] || '00000';
          for(let c=0;c<glyphW;c++){
            if (row[c] === '1') ctx.fillRect(cx + c*pixelSize, y + r*pixelSize, pixelSize, pixelSize);
          }
        }
        cx += (glyphW + space) * pixelSize;
      }
      ctx.restore();
    }

    
    const PIX_ICON_LOCK_CLOSED = [
      '0011100',
      '0100010',
      '0100010',
      '0111110',
      '0110110',
      '0110110',
      '0111110'
    ];
    const PIX_ICON_LOCK_OPEN = [
      '0011000',
      '0100000',
      '0100000',
      '0111110',
      '0110110',
      '0110110',
      '0111110'
    ];
    const PIX_ICON_X = [
      '1000001',
      '0100010',
      '0010100',
      '0001000',
      '0010100',
      '0100010',
      '1000001'
    ];
    const PIX_ICON_RESIZE = [
      '0000001',
      '0000011',
      '0000111',
      '0001111',
      '0011111',
      '0111111',
      '1111111'
    ];
    function drawPixelIcon(ctx, pattern, x, y, pixelSize, color){
      ctx.save();
      ctx.fillStyle = color || '#ffffff';
      const h = pattern.length|0;
      const w = h ? pattern[0].length|0 : 0;
      for (let r = 0; r < h; r++){
        const row = pattern[r] || '';
        for (let c = 0; c < w; c++){
          if (row[c] === '1') ctx.fillRect(x + c*pixelSize, y + r*pixelSize, pixelSize, pixelSize);
        }
      }
      ctx.restore();
    }
    function measurePixelIcon(pattern, pixelSize){
      const h = pattern.length|0;
      const w = h ? pattern[0].length|0 : 0;
      return { width: w * pixelSize, height: h * pixelSize };
    }

    function getContentCenterPx() {
      const c = canvas.getBoundingClientRect();
      const s = sidebar && sidebar.getBoundingClientRect ? sidebar.getBoundingClientRect() : null;
      const regionLeft = s ? Math.max(0, Math.min(c.width, s.right - c.left)) : 0;
      return { x: regionLeft + (c.width - regionLeft) / 2, y: c.height / 2 };
    }

    let img = null;
    let baseImageData = null;
    let currentTiles = [];
    let currentTileW = 0;
    let currentTileH = 0;
    let currentMosaicCols = 1;
    let currentMosaicRows = 1;
    const state = {
      scale: 1,
      minScale: 0.1,
      maxScale: 16,
      translateX: 0,
      translateY: 0,
      dragging: false,
      lastX: 0,
      lastY: 0,
      zooming: false
    };
    let zoomingTimeout = null;
    // Hovered cell in the 3x3 grid relative to the fetched tile
    let hoveredGridCell = null; // { row: -1|0|1, col: -1|0|1 }
    // Overlay tiles fetched via lock clicks: key = "col,row" → { image, col, row, area, no }
    const neighborOverlays = new Map();
    let overlayVersion = 0;
    // Allow dragging images beyond the 3x3 grid; outside parts stay clipped
    const ALLOW_DRAG_BEYOND_NINE = true;

    function resizeCanvasToDisplaySize() {
      const dpr = window.devicePixelRatio || 1;
      const displayWidth = Math.floor(canvas.clientWidth * dpr);
      const displayHeight = Math.floor(canvas.clientHeight * dpr);
      if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
        canvas.width = displayWidth;
        canvas.height = displayHeight;
      }
      return dpr;
    }

    function render() {
      if (!img) return;
      const dpr = resizeCanvasToDisplaySize();
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      ctx.imageSmoothingEnabled = false;
      ctx.setTransform(dpr * state.scale, 0, 0, dpr * state.scale, dpr * state.translateX, dpr * state.translateY);
      ctx.drawImage(img, 0, 0);
      // Draw neighbor overlay tiles above base image but below uploaded images
      try {
        if (img && neighborOverlays.size > 0) {
          neighborOverlays.forEach((ov) => {
            if (!ov || !ov.image || !ov.image.complete) return;
            const w = img.width|0, h = img.height|0;
            const x = (ov.col|0) * w;
            const y = (ov.row|0) * h;
            ctx.drawImage(ov.image, x, y);
          });
        }
      } catch {}
      // Clip sign images and selection UI to the 3x3 region around base tile
      const baseW = img.width|0, baseH = img.height|0;
      ctx.save();
      try { ctx.beginPath(); ctx.rect(-baseW, -baseH, baseW * 3, baseH * 3); ctx.clip(); } catch {}

      let dimSelectedWhileReadyOpen = false;
      try {
        const rp = document.getElementById('ready-popup');
        dimSelectedWhileReadyOpen = !!(rp && !rp.hidden);
      } catch {}
      for (let i = 0; i < signItems.length; i++) {
        const it = signItems[i];
        if (it.image && it.image.complete) {
          const wx = typeof it.worldX === 'number' ? it.worldX : 0;
          const wy = typeof it.worldY === 'number' ? it.worldY : 0;
          ctx.save();
          if (i !== selectedIndex || dimSelectedWhileReadyOpen) {
            ctx.globalAlpha = 0.70;
            ctx.filter = 'saturate(0.6)';
          } else {
            ctx.globalAlpha = 1;
            ctx.filter = 'none';
          }
          const iw = Math.max(1, it.displayWidth || it.image.naturalWidth);
          const ih = Math.max(1, it.displayHeight || it.image.naturalHeight);
          ctx.drawImage(it.image, wx, wy, iw, ih);
          ctx.restore();
        }
      }
      
      if (!dimSelectedWhileReadyOpen && selectedIndex >= 0 && selectedIndex < signItems.length) {
        const it = signItems[selectedIndex];
        if (it && it.image && it.image.complete) {
          const wx = (typeof it.worldX === 'number' ? it.worldX : 0);
          const wy = (typeof it.worldY === 'number' ? it.worldY : 0);
          const iwSel = Math.max(1, it.displayWidth || it.image.naturalWidth);
          const ihSel = Math.max(1, it.displayHeight || it.image.naturalHeight);
          const totalCount = (it && it.pixelCount != null) ? Number(it.pixelCount) : 0;
          let selectedCount = 0;
          try {
            const map = getSelectedMap(it);
            selectedCount = map ? map.size : 0;
          } catch {}
          const placedCount = countPlacedPixelsForItem(it);
          const label = String(placedCount) + '/' + String(totalCount) + ' PX - ' + String((totalCount > 0 ? (placedCount / totalCount * 100) : 0).toFixed(1)) + ' %';
          // Scale UI relative to image size: baseline = 100x100 → scale = 1 (capped at 5x)
          const uiScale = Math.min(5, Math.max(0.1, Math.max(iwSel, ihSel) / 100));
          const pixelSize = 0.2 * uiScale;
          const padding = Math.max(0.2 * uiScale, Math.floor((0.5 * uiScale) / state.scale));
          const offset = 1 * uiScale;
          const m = measurePixelText(label, pixelSize);
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(wx + offset - padding, wy + offset - padding, m.width + padding * 2, m.height + padding * 2);
          drawPixelText(ctx, label, wx + offset, wy + offset, pixelSize, '#ffffff');
          ctx.restore();
        }
      }
      const sel = signItems[selectedIndex];
      if (sel && sel.image && sel.image.complete && !dimSelectedWhileReadyOpen) {
        const iwSel2 = Math.max(1, sel.displayWidth || sel.image.naturalWidth);
        const ihSel2 = Math.max(1, sel.displayHeight || sel.image.naturalHeight);
        ctx.save();
        ctx.strokeStyle = '#22d3ee';
        ctx.lineWidth = 2 / state.scale;
        ctx.setLineDash([6 / state.scale, 6 / state.scale]);
        ctx.strokeRect(sel.worldX || 0, sel.worldY || 0, iwSel2, ihSel2);
        ctx.restore();

        const wx0 = (sel.worldX || 0);
        const wy0 = (sel.worldY || 0);
        // Scale UI relative to image size: baseline = 100x100 → scale = 1 (capped at 5x)
        const uiScale2 = Math.min(5, Math.max(0.1, Math.max(iwSel2, ihSel2) / 100));
        const pixelSize = 0.6 * uiScale2;
        const padding = Math.max(0.3 * uiScale2, Math.floor((0.5 * uiScale2) / state.scale));
        const gap = padding * 10;
        const off = 1 * uiScale2;
        const lockPattern = sel.locked ? PIX_ICON_LOCK_CLOSED : PIX_ICON_LOCK_OPEN;
        const lockSize = measurePixelIcon(lockPattern, pixelSize);
        const delSize = measurePixelIcon(PIX_ICON_X, pixelSize);
        const showResize = !(sel.locked || sel.lockedByReady);
        const resizeSize = showResize ? measurePixelIcon(PIX_ICON_RESIZE, pixelSize) : { width: 0, height: 0 };
        const lockBgW = lockSize.width + padding * 2;
        const delBgW = delSize.width + padding * 2;
        const bgH = Math.max(lockSize.height, delSize.height) + padding * 2;
        const totalW = lockBgW + delBgW + gap;
        let xRight = wx0 + iwSel2 - off - totalW;
        let yTop = wy0 + off;

        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        const xLockBg = xRight;
        const xDelBg = xLockBg + lockBgW + gap;
        ctx.fillRect(xLockBg, yTop, lockBgW, bgH);
        ctx.fillRect(xDelBg, yTop, delBgW, bgH);
        let resizeBgW, resizeBgH, xResizeBg, yResizeBg, xResizeIcon, yResizeIcon;
        if (showResize) {
          resizeBgW = resizeSize.width + padding * 2;
          resizeBgH = resizeSize.height + padding * 2;
          xResizeBg = wx0 + iwSel2 - off - resizeBgW;
          yResizeBg = wy0 + ihSel2 - off - resizeBgH;
          ctx.fillRect(xResizeBg, yResizeBg, resizeBgW, resizeBgH);
        }

        const xLockIcon = xLockBg + padding;
        const yIcons = yTop + padding;
        drawPixelIcon(ctx, lockPattern, xLockIcon, yIcons, pixelSize, '#ffffff');

        const xDelIcon = xDelBg + padding;
        drawPixelIcon(ctx, PIX_ICON_X, xDelIcon, yIcons, pixelSize, '#ffffff');

        if (showResize) {
          xResizeIcon = xResizeBg + padding;
          yResizeIcon = yResizeBg + padding;
          drawPixelIcon(ctx, PIX_ICON_RESIZE, xResizeIcon, yResizeIcon, pixelSize, '#ffffff');
        }
        ctx.restore();

        sel._overlayRects = {
          lock: { x: xLockIcon, y: yIcons, w: lockSize.width, h: lockSize.height },
          del: { x: xDelIcon, y: yIcons, w: delSize.width, h: delSize.height },
          resize: showResize ? { x: xResizeBg, y: yResizeBg, w: resizeBgW, h: resizeBgH } : null,
          bg: { x: xRight, y: yTop, w: totalW, h: bgH }
        };
      }
      ctx.restore();
      
      // Draw 3x3 grid overlay and hover highlight
      try { drawNineGridOverlay(); } catch {}

      try { updatePixelMarkers(); } catch {}
      try { updateRangeOverlayPosition(); } catch {}
      try { autoUnlockNeighborsBasedOnSigns(); } catch {}
    }

    // Determine which of the 3x3 grid cells the world point is in
    function gridCellAt(worldX, worldY){
      if (!img) return null;
      const w = img.width|0, h = img.height|0;
      if (w <= 0 || h <= 0) return null;
      // Limit to the 3x3 block around the fetched tile
      if (worldX < -w || worldX >= 2*w || worldY < -h || worldY >= 2*h) return null;
      const col = Math.floor(worldX / w);
      const row = Math.floor(worldY / h);
      if (col < -1 || col > 1 || row < -1 || row > 1) return null;
      return { row, col };
    }

    // Draw highlight for hovered cell only (no persistent grid lines)
    function drawNineGridOverlay(){
      if (!img) return;
      const w = img.width|0, h = img.height|0;
      if (w <= 0 || h <= 0) return;
      ctx.save();
      // Hovered cell outline only
      if (hoveredGridCell) {
        // If this cell already has an overlay, do not draw outline/lock
        try {
          const k = String(hoveredGridCell.col|0) + ',' + String(hoveredGridCell.row|0);
          if (neighborOverlays && neighborOverlays.has(k)) { ctx.restore(); return; }
        } catch {}
        const hx = hoveredGridCell.col * w;
        const hy = hoveredGridCell.row * h;
        ctx.lineWidth = Math.max(1, 2 / state.scale);
        try { ctx.setLineDash([6 / state.scale, 6 / state.scale]); } catch {}
        ctx.strokeStyle = '#3b82f6';
        ctx.strokeRect(hx, hy, w, h);
        try { ctx.setLineDash([]); } catch {}

        // Draw a big lock emoji at cell center
        const cx = hx + w / 2;
        const cy = hy + h / 2;
        const baseSize = Math.min(w, h);
        const fontPx = Math.max(28, Math.floor(baseSize * 0.24));
        // Subtle background disc to improve contrast
        try {
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          const r = Math.max(14, Math.floor(baseSize * 0.16));
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        } catch {}
        try {
          ctx.save();
          ctx.font = String(fontPx) + 'px system-ui, "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = '#ffffff';
          ctx.fillText('🔒', cx, cy);
          ctx.restore();
        } catch {}
      }
      ctx.restore();
    }

    // Returns true if given world point hits the lock emoji inside hovered cell
    function isOverLockButton(worldX, worldY){
      if (!img || !hoveredGridCell) return false;
      if (hoveredGridCell.row === 0 && hoveredGridCell.col === 0) return false;
      const w = img.width|0, h = img.height|0;
      if (w <= 0 || h <= 0) return false;
      const cx = hoveredGridCell.col * w + w / 2;
      const cy = hoveredGridCell.row * h + h / 2;
      const baseSize = Math.min(w, h);
      const r = Math.max(16, Math.floor(baseSize * 0.18));
      const dx = worldX - cx;
      const dy = worldY - cy;
      return (dx*dx + dy*dy) <= (r*r);
    }

    function getCurrentTileCoords(){
      try {
        if (Array.isArray(currentTiles) && currentTiles.length > 0) {
          const t = currentTiles[0];
          if (t && typeof t.x === 'number' && typeof t.y === 'number') return { x: t.x, y: t.y };
        }
      } catch {}
      let ax = 0, ay = 0;
      try {
        const a = parseInt((areaInput && areaInput.value) ? areaInput.value : '0', 10);
        const n = parseInt((noInput && noInput.value) ? noInput.value : '0', 10);
        if (Number.isFinite(a)) ax = a;
        if (Number.isFinite(n)) ay = n;
      } catch {}
      return { x: ax, y: ay };
    }
    function getCurrentOriginTile(){
      try {
        if (Array.isArray(currentTiles) && currentTiles.length > 0) {
          let minX = Infinity, minY = Infinity;
          for (let i = 0; i < currentTiles.length; i++) {
            const t = currentTiles[i];
            if (!t) continue;
            const tx = Number(t.x || 0);
            const ty = Number(t.y || 0);
            if (tx < minX) minX = tx;
            if (ty < minY) minY = ty;
          }
          if (minX !== Infinity && minY !== Infinity) return { x: minX, y: minY };
        }
      } catch {}
      return null;
    }
    function shiftSignItemsForOriginChange(prevOrigin, newOrigin, tileW, tileH){
      try {
        if (!prevOrigin || !newOrigin) return;
        const w = Number(tileW || 0), h = Number(tileH || 0);
        if (!(w > 0 && h > 0)) return;
        const dxTiles = (Number(prevOrigin.x || 0) - Number(newOrigin.x || 0));
        const dyTiles = (Number(prevOrigin.y || 0) - Number(newOrigin.y || 0));
        if (dxTiles === 0 && dyTiles === 0) return;
        const dx = dxTiles * w;
        const dy = dyTiles * h;
        for (let i = 0; i < signItems.length; i++) {
          const it = signItems[i];
          if (!it || !it.image) continue;
          it.worldX = Number(it.worldX || 0) + dx;
          it.worldY = Number(it.worldY || 0) + dy;
          try { it._placedCountCache = null; } catch {}
        }
        try { saveImagesToStorage(); } catch {}
      } catch {}
    }

    // Shift view so that the newly centered tile appears where the hovered cell was
    function shiftViewForCell(col, row){
      if (!img) return;
      const w = img.width|0, h = img.height|0;
      state.translateX += (col * w) * state.scale;
      state.translateY += (row * h) * state.scale;
    }

    // Handle clicking the lock: fetch neighbor tile and place it under the clicked cell
    function handleGridLockClick(){
      if (!img || !hoveredGridCell) return;
      const col = hoveredGridCell.col|0;
      const row = hoveredGridCell.row|0;
      if (col === 0 && row === 0) return;
      const base = getCurrentTileCoords();
      const newArea = Number(base.x || 0) + col;
      const newNo = Number(base.y || 0) + row;
      const key = String(col) + ',' + String(row);
      // Fetch the neighbor tile image and store as overlay; do not change center tile/view
      try {
        const imgEl = new Image();
        imgEl.onload = () => {
          neighborOverlays.set(key, { image: imgEl, col, row, area: newArea, no: newNo });
          overlayVersion++;
          render();
          try { saveOverlaysToStorage(); } catch {}
        };
        imgEl.onerror = () => {};
        imgEl.src = buildUrl(newArea, newNo) + '?t=' + Date.now();
      } catch {}
    }

    // Programmatically ensure a neighbor overlay is fetched for given cell
    function ensureNeighborOverlay(col, row){
      try {
        if (!img) return;
        col = col|0; row = row|0;
        if (col === 0 && row === 0) return;
        const key = String(col) + ',' + String(row);
        if (neighborOverlays && neighborOverlays.has(key)) return;
        const base = getCurrentTileCoords();
        const newArea = Number(base.x || 0) + col;
        const newNo = Number(base.y || 0) + row;
        const imgEl = new Image();
        imgEl.onload = () => {
          try { neighborOverlays.set(key, { image: imgEl, col, row, area: newArea, no: newNo }); } catch {}
          overlayVersion++;
          render();
          try { saveOverlaysToStorage(); } catch {}
        };
        imgEl.onerror = () => {};
        imgEl.src = buildUrl(newArea, newNo) + '?t=' + Date.now();
      } catch {}
    }

    // Promise-based ensure for overlay cell; resolves when loaded/ready
    function ensureNeighborOverlayAsync(col, row){
      return new Promise((resolve) => {
        try {
          if (!img) { resolve(false); return; }
          col = col|0; row = row|0;
          if (col === 0 && row === 0) { resolve(true); return; }
          const key = String(col) + ',' + String(row);
          const existing = neighborOverlays && neighborOverlays.get ? neighborOverlays.get(key) : null;
          if (existing && existing.image && existing.image.complete) { resolve(true); return; }
          const base = getCurrentTileCoords();
          const newArea = Number(base.x || 0) + col;
          const newNo = Number(base.y || 0) + row;
          const imgEl = new Image();
          imgEl.onload = () => {
            try { neighborOverlays.set(key, { image: imgEl, col, row, area: newArea, no: newNo }); } catch {}
            overlayVersion++;
            try { saveOverlaysToStorage(); } catch {}
            render();
            resolve(true);
          };
          imgEl.onerror = () => resolve(false);
          imgEl.src = buildUrl(newArea, newNo) + '?t=' + Date.now();
        } catch { resolve(false); }
      });
    }

    // Ensure overlays for all neighbor cells intersecting the given item's bounds are loaded
    async function ensureOverlaysForItemLoaded(item){
      try {
        if (!img || !item || !item.image || !item.image.complete) return;
        const w = currentTileW || (img.width|0);
        const h = currentTileH || (img.height|0);
        const x0 = Number(item.worldX || 0), y0 = Number(item.worldY || 0);
        const x1 = x0 + (item.image.naturalWidth|0), y1 = y0 + (item.image.naturalHeight|0);
        const promises = [];
        for (let row = -1; row <= 1; row++) {
          for (let col = -1; col <= 1; col++) {
            if (col === 0 && row === 0) continue;
            const cx0 = col * w, cy0 = row * h, cx1 = cx0 + w, cy1 = cy0 + h;
            const intersects = (x1 > cx0) && (x0 < cx1) && (y1 > cy0) && (y0 < cy1);
            if (intersects) promises.push(ensureNeighborOverlayAsync(col, row));
          }
        }
        if (promises.length > 0) await Promise.all(promises);
      } catch {}
    }

    // If any part of any sign lies in a neighbor cell, auto-unlock that neighbor overlay
    function autoUnlockNeighborsBasedOnSigns(){
      try {
        if (!img || !Array.isArray(signItems) || signItems.length === 0) return;
        const w = img.width|0, h = img.height|0;
        for (let i = 0; i < signItems.length; i++) {
          const it = signItems[i];
          if (!it || !it.image || !it.image.complete) continue;
          const x0 = Number(it.worldX || 0), y0 = Number(it.worldY || 0);
          const x1 = x0 + (it.image.naturalWidth|0), y1 = y0 + (it.image.naturalHeight|0);
          for (let row = -1; row <= 1; row++) {
            for (let col = -1; col <= 1; col++) {
              if (col === 0 && row === 0) continue;
              const cx0 = col * w, cy0 = row * h, cx1 = cx0 + w, cy1 = cy0 + h;
              const intersects = (x1 > cx0) && (x0 < cx1) && (y1 > cy0) && (y0 < cy1);
              if (intersects) ensureNeighborOverlay(col, row);
            }
          }
        }
      } catch {}
    }

    function overlaysStorageKey(){
      const base = getCurrentTileCoords();
      return 'overlays:' + String(base.x) + ',' + String(base.y);
    }
    function saveOverlaysToStorage(){
      try {
        const list = [];
        neighborOverlays.forEach((ov, k) => {
          if (!ov) return;
          list.push({ key: k, col: ov.col|0, row: ov.row|0, area: Number(ov.area||0), no: Number(ov.no||0) });
        });
        localStorage.setItem(overlaysStorageKey(), JSON.stringify(list));
      } catch {}
    }
    function restoreOverlaysFromStorage(){
      try {
        const raw = localStorage.getItem(overlaysStorageKey()) || '[]';
        let list = [];
        try { list = JSON.parse(raw); } catch { list = []; }
        if (!Array.isArray(list) || list.length === 0) return;
        for (let i = 0; i < list.length; i++) {
          const e = list[i];
          if (!e || e.col == null || e.row == null || e.area == null || e.no == null) continue;
          const key = String(e.col) + ',' + String(e.row);
          try {
            const imgEl = new Image();
            imgEl.onload = () => {
              neighborOverlays.set(key, { image: imgEl, col: e.col|0, row: e.row|0, area: Number(e.area||0), no: Number(e.no||0) });
              overlayVersion++;
              render();
            };
            imgEl.onerror = () => {};
            imgEl.src = buildUrl(e.area, e.no) + '?t=' + Date.now();
          } catch {}
        }
      } catch {}
    }

    function fitToView() {
      if (!img) return;
      const vw = canvas.clientWidth;
      const vh = canvas.clientHeight;
      const scaleToFit = Math.min(vw / img.width, vh / img.height);
      state.scale = scaleToFit;
      state.translateX = (vw - img.width * state.scale) / 2;
      state.translateY = (vh - img.height * state.scale) / 2;
      render();
    }

async function reloadCurrentBackground() {
  if (recentPaintCache.size > 0) return false;
  try {
    const saved = JSON.parse(localStorage.getItem('lastFetch') || 'null');
    if (saved) {
      if (saved.mode === 'single') {
        const area = saved.coords[0].x;
        const no = saved.coords[0].y;
        return await new Promise(resolve => {
          const url = buildUrl(area, no) + '?t=' + Date.now();
          const image = new Image();
          image.onload = () => {
            //clearColorCaches(); // Xóa cache màu sắc khi tải lại ảnh nền
            const prevOrigin = getCurrentOriginTile();
            const prevW = currentTileW || (img ? (img.width|0) : 0);
            const prevH = currentTileH || (img ? (img.height|0) : 0);
            img = image;
            baseImageData = null;
            currentTiles = [{ x: Number(area), y: Number(no) }];
            currentTileW = image.width;
            currentTileH = image.height;
            currentMosaicCols = 1;
            currentMosaicRows = 1;
            try { shiftSignItemsForOriginChange(prevOrigin, { x: Number(area), y: Number(no) }, prevW, prevH); } catch {}
            try { signItems.forEach(it => { if (it) it._placedCountCache = null; }); } catch {}
            try {
              if (!hasSavedView()) {
                if (neighborOverlays && neighborOverlays.size > 0) { neighborOverlays.clear(); overlayVersion++; hoveredGridCell = null; }
              }
            } catch {}
            render();
            updatePixelMarkers();
            try { restoreOverlaysFromStorage(); } catch {}
            try {
              if (pendingZoomToItem && pendingZoomToItem.image && pendingZoomToItem.image.complete) {
                const w = img ? (img.width|0) : 0;
                const h = img ? (img.height|0) : 0;
                const wx = Math.floor(pendingZoomToItem.worldX || 0);
                const wy = Math.floor(pendingZoomToItem.worldY || 0);
                const inCurrent3x3 = !!(img && wx >= -w && wx < 2*w && wy >= -h && wy < 2*h);
                if (inCurrent3x3) { zoomToSign(pendingZoomToItem); }
                pendingZoomToItem = null;
              }
            } catch {}
            resolve(true);
          };
          image.onerror = () => resolve(false);
          image.src = url;
        });
      }
    }
    // Si no hay datos guardados, carga desde los inputs
    const area = (areaInput && areaInput.value) ? String(areaInput.value).trim() : '';
    const no = (noInput && noInput.value) ? String(noInput.value).trim() : '';
    if (!area || !no) return false;
    return await new Promise(resolve => {
      const url = buildUrl(area, no) + '?t=' + Date.now();
      const image = new Image();
      image.onload = () => {
        clearColorCaches(); // Xóa cache màu sắc khi tải ảnh mới từ input
        const prevOrigin = getCurrentOriginTile();
        const prevW = currentTileW || (img ? (img.width|0) : 0);
        const prevH = currentTileH || (img ? (img.height|0) : 0);
        img = image;
        baseImageData = null;
        currentTiles = [{ x: Number(area), y: Number(no) }];
        currentTileW = image.width;
        currentTileH = image.height;
        currentMosaicCols = 1;
        currentMosaicRows = 1;
        try { shiftSignItemsForOriginChange(prevOrigin, { x: Number(area), y: Number(no) }, prevW, prevH); } catch {}
        try { signItems.forEach(it => { if (it) it._placedCountCache = null; }); } catch {}
        try {
          if (!hasSavedView()) {
            if (neighborOverlays && neighborOverlays.size > 0) { neighborOverlays.clear(); overlayVersion++; hoveredGridCell = null; }
          }
        } catch {}
        render();
        updatePixelMarkers();
        try { restoreOverlaysFromStorage(); } catch {}
        try {
          if (pendingZoomToItem && pendingZoomToItem.image && pendingZoomToItem.image.complete) {
            const w = img ? (img.width|0) : 0;
            const h = img ? (img.height|0) : 0;
            const wx = Math.floor(pendingZoomToItem.worldX || 0);
            const wy = Math.floor(pendingZoomToItem.worldY || 0);
            const inCurrent3x3 = !!(img && wx >= -w && wx < 2*w && wy >= -h && wy < 2*h);
            if (inCurrent3x3) { zoomToSign(pendingZoomToItem); }
            pendingZoomToItem = null;
          }
        } catch {}
        resolve(true);
      };
      image.onerror = () => resolve(false);
      image.src = url;
    });
  } catch {
    return false;
  }
}

    const USE_LOCAL_TILE = false;
    function buildUrl(area, no) {
      if (USE_LOCAL_TILE) return '767.png';
      
      return '/tiles/' + encodeURIComponent(area) + '/' + encodeURIComponent(no) + '.png';
    }

function hasSavedView(){
  try {
    const sx = parseFloat(localStorage.getItem('view.translateX') || '');
    const sy = parseFloat(localStorage.getItem('view.translateY') || '');
    const sc = parseFloat(localStorage.getItem('view.scale') || '');
    return !isNaN(sx) && !isNaN(sy) && !isNaN(sc);
  } catch { return false; }
}

function loadImage(area, no, preserveView = false) {
  if (!area || !no) return;
  const url = buildUrl(area, no);
  const image = new Image();

  image.onload = () => {
    const prevScale = state.scale;
    const prevTx = state.translateX;
    const prevTy = state.translateY;
    const prevOrigin = getCurrentOriginTile();
    const prevW = currentTileW || (img ? (img.width|0) : 0);
    const prevH = currentTileH || (img ? (img.height|0) : 0);

    img = image;
    currentTiles = [{ x: Number(area), y: Number(no) }];
    currentTileW = image.width;
    currentTileH = image.height;
    currentMosaicCols = 1;
    currentMosaicRows = 1;
    clearColorCaches(); // Xóa cache màu sắc khi tải ảnh mới
    try { baseImageData = null; } catch {}
    try { shiftSignItemsForOriginChange(prevOrigin, { x: Number(area), y: Number(no) }, prevW, prevH); } catch {}
    // Clear overlays only if we are NOT preserving view and also want to reset overlays
    try {
      if (!preserveView) {
        if (neighborOverlays && neighborOverlays.size > 0) { neighborOverlays.clear(); overlayVersion++; hoveredGridCell = null; }
      }
    } catch {}

    if (preserveView) {
      state.scale = prevScale;
      state.translateX = prevTx;
      state.translateY = prevTy;
      render();
      try { restoreOverlaysFromStorage(); } catch {}
    } else if (hasSavedView()) {
      // If saved view exists but this is a manual fetch (preserveView=false), do not restore overlays
      render();
      updatePixelMarkers();
    } else {
      fitToView();
    }
    localStorage.setItem('lastFetch', JSON.stringify({ mode: 'single', coords: [{ x: Number(area), y: Number(no) }] }));
    // Center focus only when there's no saved view and not preserving view
    try {
      if (!(preserveView || hasSavedView())) {
        const vw = canvas.clientWidth;
        const vh = canvas.clientHeight;
        const centerPx = getContentCenterPx();
        const newScale = state.scale; // keep current scale after fit/restore above
        const cx = (img.width|0) / 2;
        const cy = (img.height|0) / 2;
        state.translateX = centerPx.x - cx * newScale;
        state.translateY = centerPx.y - cy * newScale;
        render();
      }
    } catch {}
    try {
      if (pendingZoomToItem && pendingZoomToItem.image && pendingZoomToItem.image.complete) {
        const w = img ? (img.width|0) : 0;
        const h = img ? (img.height|0) : 0;
        const wx = Math.floor(pendingZoomToItem.worldX || 0);
        const wy = Math.floor(pendingZoomToItem.worldY || 0);
        const inCurrent3x3 = !!(img && wx >= -w && wx < 2*w && wy >= -h && wy < 2*h);
        if (inCurrent3x3) { zoomToSign(pendingZoomToItem); }
        pendingZoomToItem = null;
      }
    } catch {}
  };
  image.onerror = () => {
    alert(t('messages.imageLoadFailed'));
  };
  image.src = url;
}
    let rightEraseHeld = false;
    let rightEraseLastKey = null;
    
    
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      const worldX = (px - state.translateX) / state.scale;
      const worldY = (py - state.translateY) / state.scale;

      // Handle clicks for picking colors (both priority and broken pixel)
      if (isPickingColorMode || isPickingBrokenPixelColorMode) {
          // Prevent other canvas click handlers from firing
          e.stopPropagation();
          
          let pickedColor = null;
          // Try to get color from the selected sign item's original image data
          if (selectedIndex >= 0 && selectedIndex < signItems.length) {
              const selItem = signItems[selectedIndex];
              const lx = Math.floor(worldX - (selItem.worldX || 0));
              const ly = Math.floor(worldY - (selItem.worldY || 0));
              if (lx >= 0 && ly >= 0 && lx < selItem.image.naturalWidth && ly < selItem.image.naturalHeight) {
                  pickedColor = getItemPixelColor(selItem, lx, ly);
              }
          }
          // Fallback to world color if no sign item is selected or pixel is transparent
          if (!pickedColor || pickedColor.a === 0) {
              pickedColor = getColorAtWorld(worldX, worldY);
          }

          if (pickedColor && pickedColor.a > 0) { // Ensure color is not transparent
              const paletteId = rgbToPaletteId(pickedColor.r, pickedColor.g, pickedColor.b);
              if (paletteId != null) {
                  if (isPickingColorMode) {
                      if (!priorityColors.includes(paletteId)) {
                          priorityColors.push(paletteId);
                          savePriorityColors();
                          renderPriorityColors();
                          showToast(t('messages.colorAddedToPriorityList'), 'success', 2000);
                      } else {
                          showToast(t('messages.colorAlreadyInPriorityList'), 'info', 2000);
                      }
                  } else if (isPickingBrokenPixelColorMode) {
                      if (!brokenPixelPriorityColors.includes(paletteId)) {
                          brokenPixelPriorityColors.push(paletteId);
                          saveBrokenPixelColors();
                          renderBrokenPixelColors();
                          showToast(t('messages.colorAddedToBrokenPixelList'), 'success', 2000);
                      } else {
                          showToast(t('messages.colorAlreadyInBrokenPixelList'), 'info', 2000);
                      }
                  }
              }
          } else {
              showToast(t('messages.noColorAtLocation'), 'error', 2000);
          }
          // Turn off picking mode after a successful pick
          isPickingColorMode = false;
          isPickingBrokenPixelColorMode = false;
          canvas.style.cursor = '';
          return; // Exit to prevent further canvas event processing
      }

      if (isDrawingOverlay) {
          if (!img) { // Need a base image to draw on
              showToast(t('messages.noImageToDrawOn'), 'error', 2000);
              // Exit drawing mode if no image to draw on
              isDrawingOverlay = false;
              isDraggingOverlay = false;
              canvas.style.cursor = '';
              rangeOverlay.hidden = true;
              return;
          }
          isDraggingOverlay = true; // Start dragging for overlay
          overlayStartX = worldX;
          overlayStartY = worldY;
          rangeOverlay.hidden = false;
          
          // Initial position on screen, converted from world coordinates
          const initialScreenPos = worldToScreen(overlayStartX, overlayStartY);
          rangeOverlay.style.left = initialScreenPos.x + 'px';
          rangeOverlay.style.top = initialScreenPos.y + 'px';
          rangeOverlay.style.width = '1px';
          rangeOverlay.style.height = '1px';
          return;
      }

      // Lock button click on hovered neighbor cell
      try {
        if (e.button === 0 && isOverLockButton(worldX, worldY)) {
          e.preventDefault();
          handleGridLockClick();
          return;
        }
      } catch {}

      
      if (isReadyOpen()) {
        readyMouseDownPt = { screenX: e.clientX, screenY: e.clientY, worldX, worldY, button: e.button };
        readyMouseMoved = false;
        if (e.button === 2) {
          try { updateReadyHoverFromEvent(e); } catch {}
          rightEraseHeld = true;
          rightEraseLastKey = currentHoverKey();
          maybeRemoveSelectionAtHover();
        }
      }

      
      let hitIndex = -1;
      for (let i = signItems.length - 1; i >= 0; i--) {
        const it = signItems[i];
        if (!it || !it.image || !it.image.complete) continue;
        const x = it.worldX || 0;
        const y = it.worldY || 0;
        const w = Math.max(1, it.displayWidth || it.image.naturalWidth);
        const h = Math.max(1, it.displayHeight || it.image.naturalHeight);
        if (worldX >= x && worldX <= x + w && worldY >= y && worldY <= y + h) {
          hitIndex = i;
          break;
        }
      }

      if (!readyGlobalMode && hitIndex >= 0) {
        selectedIndex = hitIndex;
        
        try {
          const rp = document.getElementById('ready-popup');
          if (rp && !rp.hidden && readyLockedItem && readyLockedItem !== signItems[selectedIndex]) {
            readyLockedItem.lockedByReady = false;
            try { updateItemLockUi(readyLockedItem); } catch {}
            readyLockedItem = null;
          }
        } catch {}
        updateThumbSelection();
        updateCounter();
        const it = signItems[selectedIndex];
        
        if (it && it._overlayRects) {
          const rbg = it._overlayRects.bg;
          if (rbg && worldX >= rbg.x && worldX <= rbg.x + rbg.w && worldY >= rbg.y && worldY <= rbg.y + rbg.h) {
            const rLock = it._overlayRects.lock;
            const rDel = it._overlayRects.del;
            if (rLock && worldX >= rLock.x && worldX <= rLock.x + rLock.w && worldY >= rLock.y && worldY <= rLock.y + rLock.h) {
              it.locked = !it.locked;
              try { updateItemLockUi(it); } catch {}
              try {
                const mapKey = 'locks.map';
                let locks = {};
                try { locks = JSON.parse(localStorage.getItem(mapKey) || '{}'); } catch {}
                locks[it.url] = !!it.locked;
                try {
                  const altKey = (it.url && it.url.startsWith('data:')) ? it.url : (localStorage.getItem('last.image.dataUrl') || null);
                  if (altKey) locks[altKey] = !!it.locked;
                } catch {}
                localStorage.setItem(mapKey, JSON.stringify(locks));
              } catch {}
              render();
              return; 
            }
            if (rDel && worldX >= rDel.x && worldX <= rDel.x + rDel.w && worldY >= rDel.y && worldY <= rDel.y + rDel.h) {
              
              deleteItem(it);
              render();
              return;
            }
          }
          const rResize = it._overlayRects.resize;
          if (!(it.locked || it.lockedByReady) && rResize && worldX >= rResize.x && worldX <= rResize.x + rResize.w && worldY >= rResize.y && worldY <= rResize.y + rResize.h) {
            resizingItem = it;
            resizeStartX = worldX;
            resizeStartY = worldY;
            resizeOrigW = Math.max(1, it.displayWidth || it.image.naturalWidth);
            resizeOrigH = Math.max(1, it.displayHeight || it.image.naturalHeight);
            document.body.classList.add('dragging');
            return;
          }
        }
        if (!(it.locked || it.lockedByReady)) {
          signDragging = true;
          // Preserve fractional click offset to avoid pixel jumps when dragging
          signWorldOffsetX = worldX - (it.worldX || 0);
          signWorldOffsetY = worldY - (it.worldY || 0);
        }
        render();
        if (isReadyOpen()) {
          
          updateReadyHoverFromEvent(e);
          updatePixelMarkers();
        }
      } else if (!readyGlobalMode) {
        try {
          const prev = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
          if (prev) clearSelectionsForItem(prev);
        } catch {}
        selectedIndex = -1;
        try {
          const rp = document.getElementById('ready-popup');
          if (rp && !rp.hidden) {
            resetReadyNow();
          }
        } catch {}
        updateThumbSelection();
        updateCounter();
        state.dragging = true;
        state.lastX = e.clientX;
        state.lastY = e.clientY;
        document.body.classList.add('dragging');
        render();
        updatePixelMarkers();
      }
    });
    canvas.addEventListener('contextmenu', (e) => { if (isReadyOpen()) { e.preventDefault(); } });
    window.addEventListener('mousemove', (e) => {
      if (isDraggingOverlay) { // Only update if actively dragging for overlay
          const rect = canvas.getBoundingClientRect();
          const px = e.clientX - rect.left;
          const py = e.clientY - rect.top;
          const worldX = (px - state.translateX) / state.scale;
          const worldY = (py - state.translateY) / state.scale;

          const x = Math.min(overlayStartX, worldX);
          const y = Math.min(overlayStartY, worldY);
          const w = Math.abs(worldX - overlayStartX);
          const h = Math.abs(worldY - overlayStartY);
 
          const p = worldToScreen(x, y);
          rangeOverlay.style.left = p.x + 'px';
          rangeOverlay.style.top = p.y + 'px';
          rangeOverlay.style.width = (w * state.scale) + 'px';
          rangeOverlay.style.height = (h * state.scale) + 'px';
          
          rangeOverlay.hidden = false; // Ensure the overlay is visible during dragging
          return;
      }
      if (isReadyOpen()) {
        if (readyMouseDownPt) {
          const moveDx = Math.abs(e.clientX - readyMouseDownPt.screenX);
          const moveDy = Math.abs(e.clientY - readyMouseDownPt.screenY);
          if (moveDx > READY_CLICK_MOVE_TOLERANCE || moveDy > READY_CLICK_MOVE_TOLERANCE) readyMouseMoved = true;
        }
      }
      if (rightEraseHeld && isReadyOpen()) {
        try { updateReadyHoverFromEvent(e); } catch {}
        if (rightEraseLastKey !== currentHoverKey()) {
          if (maybeRemoveSelectionAtHover()) {
            rightEraseLastKey = currentHoverKey();
          }
        }
      }
      if (resizingItem) {
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        const worldX = (px - state.translateX) / state.scale;
        const worldY = (py - state.translateY) / state.scale;
        const newW = Math.max(1, resizeOrigW + Math.round(worldX - resizeStartX));
        const newH = Math.max(1, resizeOrigH + Math.round(worldY - resizeStartY));
        resizingItem.displayWidth = newW;
        resizingItem.displayHeight = newH;
        render();
        return;
      }
      if (state.dragging) {
        if (rightEraseHeld) {
          return;
        }
        const dx = e.clientX - state.lastX;
        const dy = e.clientY - state.lastY;
        state.lastX = e.clientX;
        state.lastY = e.clientY;
        // Clamp panning only when composite content is larger than viewport
        try {
          const rects = getAllowedPlacementRects();
          const b = getCompositeBounds(rects);
          const vw = canvas.clientWidth, vh = canvas.clientHeight;
          const s = state.scale;
          const cw = (b.maxX - b.minX) * s;
          const ch = (b.maxY - b.minY) * s;
          let nx = state.translateX + dx;
          let ny = state.translateY + dy;
          // Allow some overscroll slack so users can pan even when content nearly fits
          const panSlackX = Math.max(32, Math.floor(vw * 0.2));
          const panSlackY = Math.max(32, Math.floor(vh * 0.2));
          if (cw > vw) {
            const minTx = vw - (b.maxX * s) - panSlackX; // right edge aligned with slack
            const maxTx = - (b.minX * s) + panSlackX;    // left edge aligned with slack
            nx = Math.min(Math.max(minTx, nx), maxTx);
          }
          if (ch > vh) {
            const minTy = vh - (b.maxY * s) - panSlackY;
            const maxTy = - (b.minY * s) + panSlackY;
            ny = Math.min(Math.max(minTy, ny), maxTy);
          }
          state.translateX = nx;
          state.translateY = ny;
        } catch { state.translateX += dx; state.translateY += dy; }
        render();
        updatePixelMarkers();
        
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        const worldX = (px - state.translateX) / state.scale;
        const worldY = (py - state.translateY) / state.scale;
        updateCanvasCursorAt(worldX, worldY);
        return;
      }
      if (isReadyOpen()) {
        try {
          const t = e && e.target ? e.target : null;
          const overUi = !!(t && t.closest && (
            t.closest('#control-panel') ||
            t.closest('#ready-popup') ||
            t.closest('#sidebar') ||
            t.closest('#color-palette')
          ));
          if (overUi) {
            readyHoverPixel.x = null; readyHoverPixel.y = null;
            hideEl(pixelHoverEl);
            try { pixelHoverFillEl.hidden = true; } catch {}
          } else {
            updateReadyHoverFromEvent(e);
          }
        } catch { updateReadyHoverFromEvent(e); }
      }
      
      
      if (isReadyOpen() && readyMouseDownPt && !readyMouseMoved) {
        return;
      }
      
      try {
        const rect = canvas.getBoundingClientRect();
        const px = e.clientX - rect.left;
        const py = e.clientY - rect.top;
        const worldX = (px - state.translateX) / state.scale;
        const worldY = (py - state.translateY) / state.scale;
        updateCanvasCursorAt(worldX, worldY);
      } catch {}
      
      if (isReadyOpen() && readyMouseDownPt && readyMouseMoved && !state.dragging) {
        state.dragging = true;
        state.lastX = e.clientX;
        state.lastY = e.clientY;
        document.body.classList.add('dragging');
      }
      if (!signDragging) return;
      if (isReadyOpen()) {
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      let worldX = (px - state.translateX) / state.scale - signWorldOffsetX;
      let worldY = (py - state.translateY) / state.scale - signWorldOffsetY;
      const sel = signItems[selectedIndex];
      if (sel && sel.image && img) {
        const snapped = snapItemToNearest(sel, worldX, worldY);
        sel.worldX = snapped.x;
        sel.worldY = snapped.y;
        
        if (sel.pixelCount == null) {
          try { sel.pixelCount = countNonTransparentPixels(sel.image); } catch {}
        }
        render();
        updatePixelMarkers();
        if (isReadyOpen()) { try { updateReadySelectionLabel(); } catch {} }
        try { saveImagesToStorage(); } catch {}
      }
    });
/*
      // Xử lý kéo ảnh
      if (signDragging) {
        // Nếu ready popup đang mở và ở chế độ global, chuyển sang chế độ kéo bản đồ
        if (isReadyOpen() && readyGlobalMode) {
          signDragging = false; // Ngừng kéo ảnh
          state.dragging = true; // Bắt đầu kéo bản đồ
          state.lastX = e.clientX; // Cập nhật vị trí chuột cho kéo bản đồ
          state.lastY = e.clientY;
          document.body.classList.add('dragging');
          render(); // Render lại để cập nhật trạng thái
          updatePixelMarkers();
          updateCanvasCursorAt(worldX, worldY);
          return; // Thoát, xử lý kéo bản đồ ở lượt tiếp theo của mousemove
        }
        // Nếu không ở chế độ global hoặc ready popup không mở, tiếp tục kéo ảnh
      }
      // Xử lý kéo bản đồ (được kích hoạt nếu signDragging là false)
      else if (state.dragging) {
        // Logic kéo bản đồ hiện tại (đã nằm trong khối này)
      } else {
        // Nếu không có hành động kéo nào đang diễn ra, thoát
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      let worldX = (px - state.translateX) / state.scale - signWorldOffsetX;
      let worldY = (py - state.translateY) / state.scale - signWorldOffsetY;
      const sel = signItems[selectedIndex];
      if (sel && sel.image && img) {
        const snapped = snapItemToNearest(sel, worldX, worldY);
        sel.worldX = snapped.x;
        sel.worldY = snapped.y;
        
        if (sel.pixelCount == null) {
          try { sel.pixelCount = countNonTransparentPixels(sel.image); } catch {}
        }
        render();
        updatePixelMarkers();
        if (isReadyOpen()) { try { updateReadySelectionLabel(); } catch {} }
        try { saveImagesToStorage(); } catch {}
      }
    });
*/
    window.addEventListener('mouseup', (e) => {
      if (isDraggingOverlay) {
          isDraggingOverlay = false; // Stop dragging
          canvas.style.cursor = ''; // Reset cursor
          rangeOverlay.hidden = true; // Hide the active drawing overlay

          const rect = canvas.getBoundingClientRect();
          const px = e.clientX - rect.left;
          const py = e.clientY - rect.top;
          const worldX = (px - state.translateX) / state.scale;
          const worldY = (py - state.translateY) / state.scale;

          const x = Math.min(overlayStartX, worldX);
          const y = Math.min(overlayStartY, worldY);
          const w = Math.abs(worldX - overlayStartX);
          const h = Math.abs(worldY - overlayStartY);

          if (w > 0 && h > 0) {
              const overlayName = prompt(t('messages.enterOverlayName'), `Overlay ${savedOverlays.length + 1}`);
              if (overlayName !== null) {
                  const newOverlay = {
                      id: Date.now(), // Unique ID for the overlay
                      name: overlayName,
                      rect: {
                          x: Math.round(x),
                          y: Math.round(y),
                          w: Math.round(w),
                          h: Math.round(h)
                      },
                      isVisible: true, // Default to visible
                      isSaved: false, // Default to not saved
                      imageData: null // Placeholder for image data
                  };
                  savedOverlays.push(newOverlay);
                  selectedOverlayIndex = savedOverlays.length - 1; // Select the newly added overlay
                  saveOverlaysToStorage();
                  renderOverlayList();
                  updateRangeOverlayPosition();
                  // Capture the image data for the new overlay
                  captureOverlayImageData(newOverlay);
              }
          }
          isDrawingOverlay = false; // Exit drawing mode after completion
          return;
      }
      if (resizingItem) {
        const w = Math.max(1, resizingItem.displayWidth || resizingItem.image.naturalWidth);
        const h = Math.max(1, resizingItem.displayHeight || resizingItem.image.naturalHeight);
        resizingItem.displayWidth = null;
        resizingItem.displayHeight = null;
        applyResize(resizingItem, w, h);
        resizingItem = null;
        document.body.classList.remove('dragging');
        return;
      }
      if (isReadyOpen()) {// Ready mode
         
        if (readyMouseDownPt && !readyMouseMoved && e.button === 0) {
          const hasAccounts = Array.isArray(readySelectedAccountIds) && readySelectedAccountIds.length > 0;
          if (!hasAccounts) {
            showToast(t('messages.selectAccountFirst'), 'error', 2000);
            readyMouseDownPt = null; readyMouseMoved = false;
            return;
          }
          const rect = canvas.getBoundingClientRect();
          const px = e.clientX - rect.left;
          const py = e.clientY - rect.top;
          const worldX = (px - state.translateX) / state.scale;
          const worldY = (py - state.translateY) / state.scale;
          const wx = Math.floor(worldX);
          const wy = Math.floor(worldY);
          const area = (areaInput && areaInput.value) ? String(areaInput.value).trim() : '';
          const no = (noInput && noInput.value) ? String(noInput.value).trim() : '';
          
          if (!img) {
            readyMouseDownPt = null; readyMouseMoved = false;
            return;
          }
          if (readyGlobalMode) {
            if (wx >= 0 && wy >= 0 && wx < img.width && wy < img.height) {
              const limit = Math.max(0, Number(getReadySelectionLimit()) || 0);
              if (limit > 0 && readyGlobalSelected.size >= limit) {
                showToast(t('messages.maxPixelsReached', { limit }), 'error', 2000);
                readyMouseDownPt = null; readyMouseMoved = false;
                return;
              }
              const key = String(wx) + ',' + String(wy);
              if (!readyGlobalSelected.has(key)) {
                const rec = { wx, wy, el: null, fillEl: null, colorId: selectedOverrideColorId };
                readyGlobalSelected.set(key, rec);
                if (pixelSelectedList) pixelSelectedList.hidden = false;
                try { updateReadySelectionLabel(); updateStartEnabled(); } catch {}
                try { refreshPaletteTooltips(); } catch {}
                drawSelectionOverlay();
              }
            }
          } else {
            const selItem = signItems[selectedIndex];
            if (selItem && selItem.image && selItem.image.complete) {
              const lx = Math.floor(worldX - (selItem.worldX || 0));
              const ly = Math.floor(worldY - (selItem.worldY || 0));
              if (lx >= 0 && ly >= 0 && lx < selItem.image.naturalWidth && ly < selItem.image.naturalHeight) {
                if (isOpaquePixel(selItem, lx, ly) && (selectedOverrideColorId != null || !isSamePaletteIdAsBase(selItem, lx, ly))) {
                  const limit = Math.max(0, Number(getReadySelectionLimit()) || 0);
                  const map = getSelectedMap(selItem);
                  const already = map ? map.size : 0;
                  if (limit > 0 && already >= limit) {
                    showToast(t('messages.maxPixelsReached', { limit }), 'error', 2000);
                    readyMouseDownPt = null; readyMouseMoved = false;
                    return;
                  }
                  const didAdd = addPixelSelection(selItem, lx, ly, selectedOverrideColorId != null ? selectedOverrideColorId : null);
                  if (didAdd) {
                    try { updateReadySelectionLabel(); updateStartEnabled(); updatePixelMarkers(); render(); } catch {}
                  }
                }
              }
            }
          }
        } else if (readyMouseDownPt && !readyMouseMoved && e.button === 2) {
          
          const rect = canvas.getBoundingClientRect();
          const px = e.clientX - rect.left;
          const py = e.clientY - rect.top;
          const worldX = (px - state.translateX) / state.scale;
          const worldY = (py - state.translateY) / state.scale;
          if (readyGlobalMode) {
            const wx = Math.floor(worldX);
            const wy = Math.floor(worldY);
            if (img && wx >= 0 && wy >= 0 && wx < img.width && wy < img.height) {
              const key = String(wx) + ',' + String(wy);
              const rec = readyGlobalSelected.get(key);
              if (rec) {
                readyGlobalSelected.delete(key);
                try { updateReadySelectionLabel(); updateStartEnabled(); } catch {}
                try { refreshPaletteTooltips(); } catch {}
                drawSelectionOverlay();
              }
            }
          } else {
            const selItem = signItems[selectedIndex];
            if (selItem && selItem.image && selItem.image.complete) {
              const lx = Math.floor(worldX - (selItem.worldX || 0));
              const ly = Math.floor(worldY - (selItem.worldY || 0));
              if (lx >= 0 && ly >= 0 && lx < selItem.image.naturalWidth && ly < selItem.image.naturalHeight) {
                const removed = removePixelSelection(selItem, lx, ly);
                if (removed) { try { updateReadySelectionLabel(); updateStartEnabled(); } catch {} }
              }
            }
          }
        }
        readyMouseDownPt = null; readyMouseMoved = false;
        rightEraseHeld = false; rightEraseLastKey = null;
      }
      state.dragging = false;
      signDragging = false;
      document.body.classList.remove('dragging');
      try {
        // Persist current selected item's world position at end of drag
        const it = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
        if (it && it.image && it.image.complete) {
          localStorage.setItem('last.image.worldX', String(it.worldX||0));
          localStorage.setItem('last.image.worldY', String(it.worldY||0));
        }
      } catch {}
      try { saveImagesToStorage(); } catch {}
      setTimeout(() => { try { updatePixelMarkers(); } catch {} }, 50);
    });

    
    document.addEventListener('mousedown', (e) => {
      try {
        const rp = document.getElementById('ready-popup');
        if (rp && !rp.hidden) {
          const isCanvasClick = (e.target === canvas) || (canvas && canvas.contains && canvas.contains(e.target));
          const isPopupClick = (e.target === rp) || (rp && rp.contains && rp.contains(e.target));
          const readyBtnEl = document.getElementById('btn-ready');
          const isReadyBtnClick = (e.target === readyBtnEl) || (readyBtnEl && readyBtnEl.contains && readyBtnEl.contains(e.target));
          const paletteEl = document.getElementById('color-palette');
          const isPaletteClick = (e.target === paletteEl) || (paletteEl && paletteEl.contains && paletteEl.contains(e.target));
          if (!isCanvasClick && !isPopupClick && !isReadyBtnClick && !isPaletteClick) {
            
            resetReadyNow();
          }
        }
      } catch {}
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      state.zooming = true;
      try { if (zoomingTimeout) { clearTimeout(zoomingTimeout); } } catch {}
      if (!img) return;
      const rect = canvas.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      const imageX = (px - state.translateX) / state.scale;
      const imageY = (py - state.translateY) / state.scale;
      const zoom = Math.exp(-e.deltaY * 0.0015);
      const newScale = Math.min(state.maxScale, Math.max(state.minScale, state.scale * zoom));
      if (newScale === state.scale) return;
      // Zoom toward cursor, anchoring to composite bounds to avoid jumps across tiles
      let nx, ny;
      try {
        const rects = getAllowedPlacementRects();
        const b = getCompositeBounds(rects);
        const clamp = (v, min, max) => v < min ? min : (v > max ? max : v);
        const wx = clamp(imageX, b.minX, b.maxX);
        const wy = clamp(imageY, b.minY, b.maxY);
        nx = px - wx * newScale;
        ny = py - wy * newScale;
      } catch {
        nx = px - imageX * newScale;
        ny = py - imageY * newScale;
      }
      try {
        const rects = getAllowedPlacementRects();
        const b = getCompositeBounds(rects);
        const vw = canvas.clientWidth, vh = canvas.clientHeight;
        const cw = (b.maxX - b.minX) * newScale;
        const ch = (b.maxY - b.minY) * newScale;
        // Allow some overscroll slack while zooming
        const panSlackX = Math.max(32, Math.floor(vw * 0.2));
        const panSlackY = Math.max(32, Math.floor(vh * 0.2));
        if (cw > vw) {
          const minTx = vw - (b.maxX * newScale) - panSlackX;
          const maxTx = - (b.minX * newScale) + panSlackX;
          nx = Math.min(Math.max(minTx, nx), maxTx);
        }
        if (ch > vh) {
          const minTy = vh - (b.maxY * newScale) - panSlackY;
          const maxTy = - (b.minY * newScale) + panSlackY;
          ny = Math.min(Math.max(minTy, ny), maxTy);
        }
      } catch {}
      state.translateX = nx;
      state.translateY = ny;
      state.scale = newScale;
      render();
      updatePixelMarkers();
      zoomingTimeout = setTimeout(() => { state.zooming = false; try { updatePixelMarkers(); } catch {} }, 50);
    }, { passive: false });

    window.addEventListener('resize', () => {
      render();
      updatePixelMarkers();
      updateDimOverlay(); /* Cập nhật dim overlay khi thay đổi kích thước cửa sổ */
    });

    // Persist view pan/zoom changes periodically
    setInterval(() => {
      try {
        localStorage.setItem('view.translateX', String(state.translateX));
        localStorage.setItem('view.translateY', String(state.translateY));
        localStorage.setItem('view.scale', String(state.scale));
      } catch {}
    }, 1000);

    
    function updatePixelPowerPosition() {}

    document.getElementById('form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const area = areaInput.value.trim();
      const no = noInput.value.trim();
      if (!area || !no) return;
      loadImage(area, no);
      
      try { localStorage.setItem('view.worldX', String(Number(area))); localStorage.setItem('view.worldY', String(Number(no))); } catch {}
    });

    function updateCounter() {
      const total = signItems.length;
      const selected = selectedIndex >= 0 ? (selectedIndex + 1) : 0;
      counter.textContent = String(selected) + ' / ' + String(total);
      try {
        const btn = document.getElementById('btn-ready');
        if (btn) btn.disabled = !(
          (selectedIndex >= 0 && selectedIndex < signItems.length) ||
          (selectedOverrideColorId != null)
        );
      } catch {}
    }

    function updateThumbSelection() {
      signItems.forEach((it, i) => {
        if (it.el) it.el.classList.toggle('selected', i === selectedIndex);
      });
      try { localStorage.setItem('selected.index', String(selectedIndex)); } catch {}
      try {
        const btn = document.getElementById('btn-ready');
        if (btn) btn.disabled = !(
          (selectedIndex >= 0 && selectedIndex < signItems.length) ||
          (selectedOverrideColorId != null)
        );
      } catch {}
      
      try {
        if (!(selectedIndex >= 0 && selectedIndex < signItems.length)) {
          const rp = document.getElementById('ready-popup');
          if (rp) rp.hidden = true;
          try { if (movementPopup) movementPopup.hidden = true; } catch {}
        }
      } catch {}
      if (isReadyOpen()) { try { updateReadySelectionLabel(); } catch {} }
      try { updateMovementButtonEnabled(); } catch {}
      try {
        const it = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
        if (movementBtn && movementPopup) {
          const canOpen = !!(it && it.image && it.image.complete && !(it.locked || it.lockedByReady));
          if (canOpen) {
            if (window._mvOpenTmo) { try { clearTimeout(window._mvOpenTmo); } catch {} }
            window._mvOpenTmo = setTimeout(() => { if (!readyPopup || readyPopup.hidden) movementPopup.hidden = false; }, 50);
          }
        }
      } catch {}
    }

    function updateItemLockUi(item) {
      if (!item || !item.el) return;
      item.el.classList.toggle('locked', !!item.locked);
      const btn = item.el.querySelector('.thumb-action.lock');
      if (btn) btn.textContent = (item.locked || item.lockedByReady) ? '🔒' : '🔓';
      try { updateMovementButtonEnabled(); } catch {}
    }

    function deleteItem(item) {
      const idx = signItems.indexOf(item);
      if (idx === -1) return;
      if (readyLockedItem === item) {
        try { readyLockedItem.lockedByReady = false; } catch {}
        readyLockedItem = null;
      }
      if (item.el && item.el.parentNode) {
        try { item.el.parentNode.removeChild(item.el); } catch {}
      }
      try { if (item.url) URL.revokeObjectURL(item.url); } catch {}
      signItems.splice(idx, 1);
      if (selectedIndex === idx) selectedIndex = Math.min(idx, signItems.length - 1);
      else if (selectedIndex > idx) selectedIndex -= 1;
      if (signItems.length === 0) selectedIndex = -1;
      updateThumbSelection();
      updateCounter();
      render();
      try { updateMovementButtonEnabled(); } catch {}
      try { saveImagesToStorage(); } catch {}
    }

    function applyResize(item, w, h) {
      if (!item || !item.image) return;
      if (!item.originalImage) item.originalImage = item.image;
      const src = item.originalImage;
      const off = document.createElement('canvas');
      off.width = w; off.height = h;
      const octx = off.getContext('2d', { willReadFrequently: true });
      octx.imageSmoothingEnabled = false;
      octx.drawImage(src, 0, 0, src.naturalWidth || src.width, src.naturalHeight || src.height, 0, 0, w, h);
      const id = octx.getImageData(0, 0, w, h);
      item._imageData = id;
      let cnt = 0;
      for (let i = 3; i < id.data.length; i += 4) { if (id.data[i] !== 0) cnt++; }
      item.pixelCount = cnt;
      off.naturalWidth = w; off.naturalHeight = h; off.complete = true;
      const dataUrl = off.toDataURL('image/png');
      item.image = off;
      item.url = dataUrl;
      item.dataUrl = dataUrl;
      if (item.el) {
        const im = item.el.querySelector('img');
        if (im) im.src = dataUrl;
      }
      render();
      updateCounter();
      try { saveImagesToStorage(); } catch {}
    }

    function zoomToSign(item) {
      if (!item || !item.image) return;
      const vw = canvas.clientWidth;
      const vh = canvas.clientHeight;
      const sw = item.image.naturalWidth || 1;
      const sh = item.image.naturalHeight || 1;
      const scaleToFit = Math.min(vw / sw, vh / sh);
      const marginFactor = 0.85;
      const newScale = Math.min(state.maxScale, Math.max(state.minScale, scaleToFit * marginFactor));
      const centerX = (item.worldX || 0) + sw / 2;
      const centerY = (item.worldY || 0) + sh / 2;
      const centerPx = getContentCenterPx();
      state.scale = newScale;
      state.translateX = centerPx.x - centerX * newScale;
      state.translateY = centerPx.y - centerY * newScale;
      render();
      try {
        localStorage.setItem('view.translateX', String(state.translateX));
        localStorage.setItem('view.translateY', String(state.translateY));
        localStorage.setItem('view.scale', String(state.scale));
        // Update world X/Y inputs to the tile that contains the image center
        if (areaInput && noInput && img) {
          const w = img.width|0, h = img.height|0;
          const cx = Math.floor(centerX);
          const cy = Math.floor(centerY);
          const base = getCurrentTileCoords();
          const col = Math.floor(cx / Math.max(1, w));
          const row = Math.floor(cy / Math.max(1, h));
          const areaX = Number(base.x || 0) + col;
          const areaY = Number(base.y || 0) + row;
          areaInput.value = String(areaX);
          noInput.value = String(areaY);
          try { localStorage.setItem('area code', String(areaX)); localStorage.setItem('no', String(areaY)); } catch {}
        }
      } catch {}
    }

    function addThumbForItem(item, index) {
      const div = document.createElement('div');
      div.className = 'thumb-item';
      const im = document.createElement('img');
      im.src = item.url;
      im.alt = item.name || (t('thumb.imageAlt', { n: (index + 1) }));
      div.appendChild(im);

      const actions = document.createElement('div');
      actions.className = 'thumb-actions';
      const btnLock = document.createElement('button');
      btnLock.className = 'thumb-action lock';
      btnLock.title = t('thumb.lock');
      btnLock.textContent = item.locked ? '🔒' : '🔓';
      btnLock.addEventListener('click', (ev) => {
        ev.stopPropagation();
        
        item.locked = !item.locked;
        updateItemLockUi(item);
        try {
          const mapKey = 'locks.map';
          let locks = {};
          try { locks = JSON.parse(localStorage.getItem(mapKey) || '{}'); } catch {}
          locks[item.url] = !!item.locked;
          try {
            const altKey = (item.url && item.url.startsWith('data:')) ? item.url : (localStorage.getItem('last.image.dataUrl') || null);
            if (altKey) locks[altKey] = !!item.locked;
          } catch {}
          localStorage.setItem(mapKey, JSON.stringify(locks));
        } catch {}
        try { saveImagesToStorage(); } catch {}
      });
      const btnDel = document.createElement('button');
      btnDel.className = 'thumb-action del';
      btnDel.title = t('buttons.delete');
      btnDel.textContent = '🗑️';
      btnDel.addEventListener('click', (ev) => {
        ev.stopPropagation();
        deleteItem(item);
        try { saveImagesToStorage(); } catch {}
      });
      actions.appendChild(btnLock);
      actions.appendChild(btnDel);
      div.appendChild(actions);

      div.addEventListener('click', () => {
        selectSign(signItems.indexOf(item), true);
      });
      item.el = div;
      if (item.lockedByReady == null) item.lockedByReady = false;
      thumbList.appendChild(div);
      updateItemLockUi(item);
      updateThumbSelection();
      updateCounter();
      try {
        // Persist current item's position when it is added
        localStorage.setItem('last.image.worldX', String(item.worldX || 0));
        localStorage.setItem('last.image.worldY', String(item.worldY || 0));
        // Persist lock state per image
        const mapKey = 'locks.map';
        let locks = {};
        try { locks = JSON.parse(localStorage.getItem(mapKey) || '{}'); } catch {}
        locks[item.url] = !!item.locked;
        try {
          const altKey = (item.url && item.url.startsWith('data:')) ? item.url : (localStorage.getItem('last.image.dataUrl') || null);
          if (altKey) locks[altKey] = !!item.locked;
        } catch {}
        localStorage.setItem(mapKey, JSON.stringify(locks));
      } catch {}
      try { saveImagesToStorage(); } catch {}
    }

    function ensureDataUrlForItem(item){
      try {
        if (!item) return null;
        if (item.dataUrl && typeof item.dataUrl === 'string' && item.dataUrl.startsWith('data:')) return item.dataUrl;
        const src = String(item.url || '');
        if (src.startsWith('data:')) { item.dataUrl = src; return src; }
        if (item.image && item.image.naturalWidth && item.image.naturalHeight) {
          const off = document.createElement('canvas');
          off.width = item.image.naturalWidth; off.height = item.image.naturalHeight;
          const octx = off.getContext('2d', { willReadFrequently: true });
          octx.imageSmoothingEnabled = false;
          octx.drawImage(item.image, 0, 0);
          const durl = off.toDataURL('image/png');
          item.dataUrl = durl;
          return durl;
        }
      } catch {}
      return null;
    }
    function saveImagesToStorage(){
      try {
        const list = [];
        for (let i = 0; i < signItems.length; i++) {
          const it = signItems[i];
          if (!it || !it.image) continue;
          const durl = ensureDataUrlForItem(it);
          if (!durl) continue;
          list.push({ name: it.name || 'image.png', dataUrl: durl, worldX: Math.floor(Number(it.worldX || 0)), worldY: Math.floor(Number(it.worldY || 0)), locked: !!it.locked });
        }
        localStorage.setItem('images.list', JSON.stringify(list));
        // If all images have been removed, also clear legacy keys to prevent fallback restore on refresh
        if (list.length === 0) {
          try { localStorage.removeItem('last.image.url'); } catch {}
          try { localStorage.removeItem('last.image.name'); } catch {}
          try { localStorage.removeItem('last.image.dataUrl'); } catch {}
          try { localStorage.removeItem('last.image.worldX'); } catch {}
          try { localStorage.removeItem('last.image.worldY'); } catch {}
          try { localStorage.removeItem('selected.index'); } catch {}
        }
      } catch {}
    }
    function restoreImagesFromStorage(){
      try {
        let list = [];
        try { list = JSON.parse(localStorage.getItem('images.list') || '[]'); } catch {}
        if (Array.isArray(list) && list.length > 0) {
          const savedSelRaw = parseInt(localStorage.getItem('selected.index') || '', 10);
          const savedSel = Number.isFinite(savedSelRaw) ? savedSelRaw : -1;
          for (let i = 0; i < list.length; i++) {
            const entry = list[i];
            if (!entry || !entry.dataUrl) continue;
            try {
              const imgEl = new Image();
              imgEl.onload = () => {
                const item = { url: entry.dataUrl, dataUrl: entry.dataUrl, name: entry.name || 'image.png', image: imgEl, originalImage: imgEl, worldX: Number(entry.worldX || 0), worldY: Number(entry.worldY || 0), el: null, locked: !!entry.locked, pixelCount: countNonTransparentPixels(imgEl) };
                signItems.push(item);
                addThumbForItem(item, signItems.length - 1);
                updateCounter();
                render();
                try { updatePixelMarkers(); } catch {}
              };
              imgEl.src = entry.dataUrl;
            } catch {}
          }
          setTimeout(() => {
            const idx = (savedSel >= 0 && savedSel < signItems.length) ? savedSel : -1;
            if (idx >= 0) { try { selectSign(idx, false); } catch {} }
          }, 100);
          return;
        }
        // Fallback to legacy single-image restore (skip if images.list existed but is empty)
        const hadList = !!localStorage.getItem('images.list');
        if (hadList) return;
        let lastUrl = localStorage.getItem('last.image.url');
        const lastName = localStorage.getItem('last.image.name') || 'image.png';
        const dataUrl = localStorage.getItem('last.image.dataUrl');
        if (!lastUrl && dataUrl) lastUrl = dataUrl;
        if (lastUrl) {
          const imgEl = new Image();
          imgEl.onload = () => {
            const savedWX = parseFloat(localStorage.getItem('last.image.worldX') || '');
            const savedWY = parseFloat(localStorage.getItem('last.image.worldY') || '');
            const item = { url: lastUrl, dataUrl: (lastUrl && lastUrl.startsWith('data:')) ? lastUrl : null, name: lastName, image: imgEl, originalImage: imgEl, worldX: 0, worldY: 0, el: null, locked: false, pixelCount: countNonTransparentPixels(imgEl) };
            if (!isNaN(savedWX)) item.worldX = savedWX;
            if (!isNaN(savedWY)) item.worldY = savedWY;
            try {
              const locks = JSON.parse(localStorage.getItem('locks.map') || '{}');
              const dataKey = localStorage.getItem('last.image.dataUrl') || null;
              if (locks && Object.prototype.hasOwnProperty.call(locks, item.url)) item.locked = !!locks[item.url];
              else if (dataKey && Object.prototype.hasOwnProperty.call(locks, dataKey)) item.locked = !!locks[dataKey];
            } catch {}
            signItems.push(item);
            let savedSel = parseInt(localStorage.getItem('selected.index') || '', 10);
            if (!Number.isFinite(savedSel)) savedSel = -1;
            selectedIndex = (savedSel >= 0 && savedSel < signItems.length) ? savedSel : -1;
            addThumbForItem(item, signItems.length - 1);
            updateCounter();
            render();
            try { updatePixelMarkers(); } catch {}
          };
          imgEl.src = lastUrl;
        }
      } catch {}
    }

    function selectSign(index, zoom = true) {
      if (index < 0 || index >= signItems.length) return;
      selectedIndex = index;
      
      try {
        const rp = document.getElementById('ready-popup');
        if (rp && !rp.hidden && readyLockedItem && readyLockedItem !== signItems[selectedIndex]) {
          readyLockedItem.lockedByReady = false;
          readyLockedItem = null;
        }
      } catch {}
      const item = signItems[selectedIndex];
      
      try {
        const rp = document.getElementById('ready-popup');
        if (rp && !rp.hidden) {
          readyHoverPixel = { x: null, y: null };
          
          ensureRenderedSelectedForItem(item);
          updatePixelMarkers();
        }
      } catch {}
      updateThumbSelection();
      updateCounter();
      try {
        const btn = document.getElementById('btn-ready');
        if (btn) btn.disabled = !(selectedIndex >= 0 && selectedIndex < signItems.length);
      } catch {}
      if (item.image && item.image.complete) {
        if (zoom) {
          try {
            // Ensure the item's tile is loaded; if not, load it then zoom
            const w = img ? (img.width|0) : 0;
            const h = img ? (img.height|0) : 0;
            const wx = Math.floor(item.worldX || 0);
            const wy = Math.floor(item.worldY || 0);
            const inCurrent3x3 = !!(img && wx >= -w && wx < 2*w && wy >= -h && wy < 2*h);
            if (!inCurrent3x3) {
              const areaNow = getCurrentTileCoords();
              const areaX = Number(areaNow.x || 0);
              const areaY = Number(areaNow.y || 0);
              const dx = Math.floor(wx / Math.max(1, w));
              const dy = Math.floor(wy / Math.max(1, h));
              const targetArea = { x: areaX + dx, y: areaY + dy };
              pendingZoomToItem = item;
              loadImage(targetArea.x, targetArea.y, true);
              // zoom will occur after load completes (see below)
            } else {
              zoomToSign(item);
            }
          } catch { zoomToSign(item); }
        }
        try { localStorage.setItem('last.image.url', item.url || ''); localStorage.setItem('last.image.name', item.name || 'image.png'); } catch {}
      } else {
        pendingZoomToSelected = !!zoom;
      }
      render();
    }

    
    function setAccountsActiveTab(){
      if (!tabAccounts) return;
      tabAccounts.classList.add('active');
      if (accountsSection) accountsSection.hidden = false;
      if (accountFormSection) accountFormSection.hidden = true;
      if (shopViewSection) shopViewSection.hidden = true;
    }
    if (tabAccounts) {
      tabAccounts.addEventListener('click', () => setAccountsActiveTab());
    }
    accountsBtn.addEventListener('click', async () => {
      accountsModal.hidden = false;
      setAccountsActiveTab();
    });
    function showAccountForm() {
      if (!accountsSection || !accountFormSection) return;
      accountsSection.hidden = true;
      accountFormSection.hidden = false;
      if (shopViewSection) shopViewSection.hidden = true;
      try {
        accountNameInput.value = '';
        accountTokenInput.value = '';
        if (accountCfInput) accountCfInput.value = '';
        accountIdInput.value = '';
        accountNameInput.focus();
      } catch {}
    }
    function openEditAccount(row) {
      if (!row) return;
      if (!accountsSection || !accountFormSection) return;
      accountsSection.hidden = true;
      accountFormSection.hidden = false;
      try {
        accountNameInput.value = row.name || '';
        accountTokenInput.value = row.token || '';
        if (accountCfInput) accountCfInput.value = row.cf_clearance || '';
        accountIdInput.value = String(row.id || '');
        const accountActiveToggle = document.getElementById('account-active-toggle');
        if (accountActiveToggle) accountActiveToggle.checked = row.active !== false;
        accountNameInput.focus();
      } catch {}
      
      try { accountSaveBtn.textContent = t('buttons.save'); } catch {}
    }
    const PREMIUM_PALETTE = [
      { id: 1, label: 'Black', rgb: [0, 0, 0] },
      { id: 2, label: 'Dark Gray', rgb: [60, 60, 60] },
      { id: 3, label: 'Gray', rgb: [120, 120, 120] },
      { id: 32, label: 'Medium Gray', rgb: [170, 170, 170] },
      { id: 4, label: 'Light Gray', rgb: [210, 210, 210] },
      { id: 5, label: 'White', rgb: [255, 255, 255] },
      { id: 6, label: 'Deep Red', rgb: [96, 0, 24] },
      { id: 33, label: 'Dark Red', rgb: [165, 14, 30] },
      { id: 7, label: 'Red', rgb: [237, 28, 36] },
      { id: 34, label: 'Light Red', rgb: [250, 128, 114] },
      { id: 35, label: 'Dark Orange', rgb: [228, 92, 26] },
      { id: 8, label: 'Orange', rgb: [255, 127, 39] },
      { id: 9, label: 'Gold', rgb: [246, 170, 9] },
      { id: 10, label: 'Yellow', rgb: [249, 221, 59] },
      { id: 11, label: 'Light Yellow', rgb: [255, 250, 188] },
      { id: 37, label: 'Dark Goldenrod', rgb: [156, 132, 49] },
      { id: 38, label: 'Goldenrod', rgb: [197, 173, 49] },
      { id: 39, label: 'Light Goldenrod', rgb: [232, 212, 95] },
      { id: 40, label: 'Dark Olive', rgb: [74, 107, 58] },
      { id: 41, label: 'Olive', rgb: [90, 148, 74] },
      { id: 42, label: 'Light Olive', rgb: [132, 197, 115] },
      { id: 12, label: 'Dark Green', rgb: [14, 185, 104] },
      { id: 13, label: 'Green', rgb: [19, 230, 123] },
      { id: 14, label: 'Light Green', rgb: [135, 255, 94] },
      { id: 15, label: 'Dark Teal', rgb: [12, 129, 110] },
      { id: 16, label: 'Teal', rgb: [16, 174, 166] },
      { id: 17, label: 'Light Teal', rgb: [19, 225, 190] },
      { id: 43, label: 'Dark Cyan', rgb: [15, 121, 159] },
      { id: 20, label: 'Cyan', rgb: [96, 247, 242] },
      { id: 44, label: 'Light Cyan', rgb: [187, 250, 242] },
      { id: 18, label: 'Dark Blue', rgb: [40, 80, 158] },
      { id: 19, label: 'Blue', rgb: [64, 147, 228] },
      { id: 45, label: 'Light Blue', rgb: [125, 199, 255] },
      { id: 46, label: 'Dark Indigo', rgb: [77, 49, 184] },
      { id: 21, label: 'Indigo', rgb: [107, 80, 246] },
      { id: 22, label: 'Light Indigo', rgb: [153, 177, 251] },
      { id: 47, label: 'Dark Slate Blue', rgb: [74, 66, 132] },
      { id: 48, label: 'Slate Blue', rgb: [122, 113, 196] },
      { id: 49, label: 'Light Slate Blue', rgb: [181, 174, 241] },
      { id: 23, label: 'Dark Purple', rgb: [120, 12, 153] },
      { id: 24, label: 'Purple', rgb: [170, 56, 185] },
      { id: 25, label: 'Light Purple', rgb: [224, 159, 249] },
      { id: 26, label: 'Dark Pink', rgb: [203, 0, 122] },
      { id: 27, label: 'Pink', rgb: [236, 31, 128] },
      { id: 28, label: 'Light Pink', rgb: [243, 141, 169] },
      { id: 53, label: 'Dark Peach', rgb: [155, 82, 73] },
      { id: 54, label: 'Peach', rgb: [209, 128, 120] },
      { id: 55, label: 'Light Peach', rgb: [250, 182, 164] },
      { id: 29, label: 'Dark Brown', rgb: [104, 70, 52] },
      { id: 30, label: 'Brown', rgb: [149, 104, 42] },
      { id: 50, label: 'Light Brown', rgb: [219, 164, 99] },
      { id: 56, label: 'Dark Tan', rgb: [123, 99, 82] },
      { id: 57, label: 'Tan', rgb: [156, 132, 107] },
      { id: 36, label: 'Light Tan', rgb: [214, 181, 148] },
      { id: 51, label: 'Dark Beige', rgb: [209, 128, 81] },
      { id: 31, label: 'Beige', rgb: [248, 178, 119] },
      { id: 52, label: 'Light Beige', rgb: [255, 197, 165] },
      { id: 61, label: 'Dark Stone', rgb: [109, 100, 63] },
      { id: 62, label: 'Stone', rgb: [148, 140, 107] },
      { id: 63, label: 'Light Stone', rgb: [205, 197, 158] },
      { id: 58, label: 'Dark Slate', rgb: [51, 57, 65] },
      { id: 59, label: 'Slate', rgb: [109, 117, 141] },
      { id: 60, label: 'Light Slate', rgb: [179, 185, 209] }
    ];
    // Only allow premium colors with id > 32
    const SHOP_PREMIUM_PALETTE = PREMIUM_PALETTE.filter(p => p && typeof p.id === 'number' && p.id > 31);

    function computeUnionExtraColorsBitmapAllAccounts(){
      let union = 0;
      try {
        if (Array.isArray(accountsData)) {
          for (let i = 0; i < accountsData.length; i++) {
            const r = accountsData[i];
            const v = Number(r && r.extraColorsBitmap != null ? r.extraColorsBitmap : 0) || 0;
            union = (union | v) >>> 0;
          }
        }
      } catch {}
      return union;
    }
    function getPremiumColorsFromBitmap(bitmap){
      const res = [];
      const arr = Array.isArray(PREMIUM_PALETTE) ? PREMIUM_PALETTE : [];
      const b = Number(bitmap) || 0;
      for (let i = 0; i < arr.length; i++) {
        const p = arr[i];
        if (!p || typeof p.id !== 'number' || p.id <= 31) continue;
        const idx = p.id - 32;
        if (idx < 0) continue;
        const mask = 1 << idx;
        if ((b & mask) !== 0) res.push({ id: p.id, rgb: p.rgb });
      }
      return res;
    }
    function recomputeActivePalette(){
      try {
        const base = PALETTE.slice();
        if (paletteMode === 'premium') {
          const union = computeUnionExtraColorsBitmapAllAccounts();
          const extra = getPremiumColorsFromBitmap(union);
          const byId = new Map();
          for (let i = 0; i < base.length; i++) byId.set(base[i].id, base[i]);
          for (let i = 0; i < extra.length; i++) byId.set(extra[i].id, extra[i]);
          const combined = Array.from(byId.values());
          combined.sort((a, b) => a.id - b.id);
          ACTIVE_PALETTE = combined;
        } else {
          ACTIVE_PALETTE = base;
        }
      } catch {
        ACTIVE_PALETTE = PALETTE.slice();
      }
      try { recomputePaletteCaches(); } catch {}
      try { setupColorPalette(); } catch {}
      try { buildFillPaletteUi(); } catch {}
      try { updatePaletteSelectionUi(); } catch {}
    }

    function isPremiumColorId(id){ return Number(id) > 31; }
    function accountProvidesColor(acc, colorId){
      if (!acc) return false;
      if (acc.active === false) return false;
      if (!acc.token) return false;
      if (!isPremiumColorId(colorId)) return true;
      const b = Number(acc.extraColorsBitmap || 0);
      const idx = Number(colorId) - 32;
      if (idx < 0) return false;
      const mask = 1 << idx;
      return (b & mask) !== 0;
    }
    function getAccountsProvidingColor(colorId){
      const rows = Array.isArray(accountsData) ? accountsData : [];
      const selectedSet = new Set(readySelectedAccountIds || []);
      const out = [];
      for (let i = 0; i < rows.length; i++){
        const r = rows[i];
        if (!selectedSet.has(r.id)) continue;
        if (accountProvidesColor(r, colorId)) out.push(r);
      }
      return out;
    }
    function getAccountsProvidingColorAll(colorId){
      const rows = Array.isArray(accountsData) ? accountsData : [];
      const out = [];
      for (let i = 0; i < rows.length; i++){
        const r = rows[i];
        if (accountProvidesColor(r, colorId)) out.push(r);
      }
      return out;
    }
    function getAccountsProvidingColorScoped(colorId, scope){
      return (scope === 'selected') ? getAccountsProvidingColor(colorId) : getAccountsProvidingColorAll(colorId);
    }
    function getPremiumColorTotalLimit(colorId){
      if (!isPremiumColorId(colorId)) return Infinity;
      const rows = getAccountsProvidingColor(colorId);
      let total = 0;
      for (let i = 0; i < rows.length; i++){
        const cRaw = Number(rows[i] && rows[i].pixelCount);
        if (Number.isFinite(cRaw)) total += Math.max(0, Math.floor(cRaw));
      }
      return total;
    }
    function getPremiumColorTotalLimitAll(colorId){
      if (!isPremiumColorId(colorId)) return Infinity;
      const rows = getAccountsProvidingColorAll(colorId);
      let total = 0;
      for (let i = 0; i < rows.length; i++){
        const cRaw = Number(rows[i] && rows[i].pixelCount);
        if (Number.isFinite(cRaw)) total += Math.max(0, Math.floor(cRaw));
      }
      return total;
    }
    function getPremiumColorRemainingLimitAll(colorId){
      // For the homepage (no selected accounts), remaining == total across all eligible accounts
      return getPremiumColorTotalLimitAll(colorId);
    }
    function getSelectedPremiumColorIds(){
      const out = [];
      try {
        if (readyGlobalSelected && typeof readyGlobalSelected.forEach === 'function'){
          readyGlobalSelected.forEach(rec => { if (rec && isPremiumColorId(rec.colorId)) out.push(rec.colorId); });
        }
      } catch {}
      try {
        for (let i = 0; i < signItems.length; i++){
          const it = signItems[i];
          const map = getSelectedMap(it);
          if (!map) continue;
          map.forEach(rec => { if (rec && isPremiumColorId(rec.colorId)) out.push(rec.colorId); });
        }
      } catch {}
      return out;
    }
    function computePremiumAssignmentUsedPerAccount(){
      // Capacity only from selected accounts
      const selectedSet = new Set(readySelectedAccountIds || []);
      const capacity = new Map();
      const rows = Array.isArray(accountsData) ? accountsData : [];
      for (let i = 0; i < rows.length; i++){
        const r = rows[i];
        if (r && r.active !== false && r.token && selectedSet.has(r.id)){
          const cRaw = Number(r.pixelCount);
          const cap = Number.isFinite(cRaw) ? Math.max(0, Math.floor(cRaw)) : 0;
          capacity.set(r.id, cap);
        }
      }
      const used = new Map();
      const remainingOf = (accId) => (capacity.get(accId)||0) - (used.get(accId)||0);
      const list = getSelectedPremiumColorIds();
      for (let k = 0; k < list.length; k++){
        const colorId = list[k];
        const providers = getAccountsProvidingColor(colorId);
        let bestId = null, bestRemain = 0;
        for (let i = 0; i < providers.length; i++){
          const acc = providers[i];
          if (!capacity.has(acc.id)) continue;
          const rem = remainingOf(acc.id);
          if (rem > bestRemain){ bestRemain = rem; bestId = acc.id; }
        }
        if (bestId != null && bestRemain > 0){ used.set(bestId, (used.get(bestId)||0) + 1); }
      }
      return { capacity, used };
    }
    function getPremiumColorRemainingLimit(colorId){
      if (!isPremiumColorId(colorId)) return Infinity;
      const { capacity, used } = computePremiumAssignmentUsedPerAccount();
      const providers = getAccountsProvidingColor(colorId);
      let remain = 0;
      for (let i = 0; i < providers.length; i++){
        const acc = providers[i];
        if (!capacity.has(acc.id)) continue;
        const rem = Math.max(0, (capacity.get(acc.id)||0) - (used.get(acc.id)||0));
        remain += rem;
      }
      return Math.max(0, remain);
    }
    function setPaletteSwatchTitle(el, p){
      try {
        if (!el || !p) return;
        if (isPremiumColorId(p.id)){
          const hasSelected = Array.isArray(readySelectedAccountIds) && readySelectedAccountIds.length > 0;
          const inReady = isReadyOpen();
          if (hasSelected && inReady) {
            const total = getPremiumColorTotalLimit(p.id); // selected accounts total
            const remain = getPremiumColorRemainingLimit(p.id); // selected accounts remaining (subtracts used)
            el.title = t('palette.premiumColorTitle', { remain, total });
          } else {
            const total = getPremiumColorTotalLimitAll(p.id); // all accounts total
            const remain = getPremiumColorRemainingLimitAll(p.id); // equal to total across all
            el.title = t('palette.premiumColorTitle', { remain, total });
          }
        } else {
          el.title = t('palette.colorTitle', { id: p.id });
        }
      } catch {}
    }
    function refreshPaletteTooltips(){
      try {
        if (!colorPaletteEl) return;
        const swatches = Array.from(colorPaletteEl.querySelectorAll('.palette-swatch'));
        swatches.forEach(sw => {
          const idAttr = sw.getAttribute('data-id');
          if (idAttr == null) return;
          const id = Number(idAttr);
          const arr = (ACTIVE_PALETTE && Array.isArray(ACTIVE_PALETTE)) ? ACTIVE_PALETTE : PALETTE;
          const p = arr.find(x => x && x.id === id);
          if (p) setPaletteSwatchTitle(sw, p);
        });
      } catch {}
    }

    // Checks whether a given color id is available for the current shop account
    function hasShopColor(e) {
      if (e < 32) {
        return true;
      }
      const b = Number(shopExtraColorsBitmap) || 0;
      const colorMask = 1 << (e - 32);
      return (b & colorMask) !== 0;
    }
    function updatePremiumPaletteSelectionUi(){
      try {
        if (!shopPremiumPaletteWrap) return;
        const swatches = Array.from(shopPremiumPaletteWrap.querySelectorAll('.shop-palette-swatch'));
        swatches.forEach(sw => {
          const idAttr = sw.getAttribute('data-id');
          const id = idAttr == null ? null : Number(idAttr);
          const isSel = (id != null && id === shopSelectedPremiumColorId);
          sw.classList.toggle('selected', !!isSel);
          if (isSel) {
            sw.setAttribute('aria-selected', 'true');
          } else {
            sw.removeAttribute('aria-selected');
          }
        });
        try {
          const hasSelection = (shopSelectedPremiumColorId != null);
          if (shopPremiumBuyBtn) shopPremiumBuyBtn.setAttribute('aria-disabled', hasSelection ? 'false' : 'true');
        } catch {}
      } catch {}
    }

    function renderPremiumPalette(){
      try {
        if (!shopPremiumPaletteWrap) return;
        // Build once per open; simple re-render
        shopPremiumPaletteWrap.innerHTML = '';
        if (shopPremiumOwnedWrap) shopPremiumOwnedWrap.innerHTML = '';
        // Add filtered premium colors (show when bitmap says false, hide when true)
        const palette = SHOP_PREMIUM_PALETTE.filter(p => !hasShopColor(p.id));
        for (let i = 0; i < palette.length; i++) {
          const p = palette[i];
          const el = document.createElement('div');
          el.className = 'shop-palette-swatch';
          el.style.backgroundColor = 'rgb(' + p.rgb[0] + ',' + p.rgb[1] + ',' + p.rgb[2] + ')';
          el.title = p.label + ' (ID ' + p.id + ')';
          el.setAttribute('role', 'button');
          el.setAttribute('data-id', String(p.id));
          el.id = 'premium-color-' + String(p.id);
          el.addEventListener('click', () => {
            shopSelectedPremiumColorId = p.id;
            updatePremiumPaletteSelectionUi();
            try {
              window.dispatchEvent(new CustomEvent('premiumColorSelected', { detail: { id: p.id } }));
            } catch {}
          });
          shopPremiumPaletteWrap.appendChild(el);
        }
        // Owned section: show colors that current account already has (disabled)
        if (shopPremiumOwnedWrap) {
          const owned = SHOP_PREMIUM_PALETTE.filter(p => hasShopColor(p.id));
          for (let i = 0; i < owned.length; i++) {
            const p = owned[i];
            const el = document.createElement('div');
            el.className = 'shop-palette-swatch disabled';
            el.style.backgroundColor = 'rgb(' + p.rgb[0] + ',' + p.rgb[1] + ',' + p.rgb[2] + ')';
            el.title = p.label + ' (ID ' + p.id + ')';
            shopPremiumOwnedWrap.appendChild(el);
          }
        }
        updatePremiumPaletteSelectionUi();
      } catch {}
    }

    function openShopAccount(row) {
      if (!row) return;
      if (!accountsSection || !shopViewSection) return;
      shopCurrentAccount = row;
      accountsSection.hidden = true;
      if (accountFormSection) accountFormSection.hidden = true;
      shopViewSection.hidden = false;
      try { if (shopBackBtn) shopBackBtn.hidden = false; } catch {}
      try {
        if (shopDropletsInfo) {
          const dRaw = (row && row.droplets != null) ? Number(row.droplets) : null;
          const label = Number.isFinite(dRaw) ? String(Math.floor(dRaw)) : '-';
          shopDropletsInfo.textContent = '💧 Droplets: ' + label;
          shopDropletsInfo.hidden = false;
        }
      } catch {}
      try {
        const dRaw = (row && row.droplets != null) ? Number(row.droplets) : null;
        shopCurrentDroplets = Number.isFinite(dRaw) ? Math.floor(dRaw) : 0;
      } catch { shopCurrentDroplets = 0; }
      // initialize shop quantities/prices
      try {
        if (shopMaxQtyEl) shopMaxQtyEl.textContent = '1';
        if (shopRecQtyEl) shopRecQtyEl.textContent = '1';
        const unitMax = 500, unitRec = 500;
        if (shopMaxPriceEl) shopMaxPriceEl.textContent = '💧 ' + (unitMax * 1) + ' Droplets';
        if (shopRecPriceEl) shopRecPriceEl.textContent = '💧 ' + (unitRec * 1) + ' Droplets';
        const maxNameEl = document.getElementById('shop-max-name');
        if (maxNameEl) maxNameEl.textContent = t('shop.maxTitle');
        const recNameEl = document.getElementById('shop-rec-name');
        if (recNameEl) recNameEl.textContent = t('shop.recTitle');
      } catch {}
      // set account-specific premium colors bitmap for filtering
      try { shopExtraColorsBitmap = Number(row && row.extraColorsBitmap != null ? row.extraColorsBitmap : 0) || 0; } catch { shopExtraColorsBitmap = 0; }
      try { renderPremiumPalette(); } catch {}
      try { updateShopButtonsDisabled(); } catch {}
      try { shopSelectedPremiumColorId = null; updatePremiumPaletteSelectionUi(); } catch {}
      try { updateShopAutobuyUi(); } catch {}
      try {
        if (shopPremiumBuyBtn) {
          shopPremiumBuyBtn.setAttribute('aria-disabled', 'true');
          shopPremiumBuyBtn.onclick = null;
          shopPremiumBuyBtn.onclick = () => {
            const hasSelection = (shopSelectedPremiumColorId != null);
            if (!hasSelection) return;
            const account = shopCurrentAccount;
            const token = account && account.token ? String(account.token) : '';
            if (!token) return;
            // Premium color purchase: productId 100, amount 1, variant = selected color id
            const amount = 1;
            const variant = Number(shopSelectedPremiumColorId);
            (async () => {
              try {
                const res = await fetch('/api/purchase', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ productId: 100, amount, variant, j: token })
                });
                const data = await res.json();
                if (res.ok && data && data.success === true) {
                  showToast(t('messages.purchaseSuccess'), 'success', 2000);
                  try { await refreshAccountById(account.id); } catch {}
                  try {
                    if (shopDropletsInfo) {
                      const updated = Array.isArray(accountsData) ? accountsData.find(r => r && r.id === account.id) : null;
                      const dRaw = updated && updated.droplets != null ? Number(updated.droplets) : null;
                      const label = Number.isFinite(dRaw) ? String(Math.floor(dRaw)) : '-';
                      shopDropletsInfo.textContent = '💧 Droplets: ' + label;
                    }
                  } catch {}
                  try {
                    const updated = Array.isArray(accountsData) ? accountsData.find(r => r && r.id === account.id) : null;
                    const dRaw2 = updated && updated.droplets != null ? Number(updated.droplets) : null;
                    shopCurrentDroplets = Number.isFinite(dRaw2) ? Math.floor(dRaw2) : 0;
                    updateShopButtonsDisabled();
                  } catch {}
                  // Refresh premium palette based on updated extraColorsBitmap without page reload
                  try {
                    const updated = Array.isArray(accountsData) ? accountsData.find(r => r && r.id === account.id) : null;
                    if (updated) {
                      shopCurrentAccount = updated;
                      shopExtraColorsBitmap = Number(updated.extraColorsBitmap != null ? updated.extraColorsBitmap : 0) || 0;
                    }
                    shopSelectedPremiumColorId = null;
                    renderPremiumPalette();
                    updatePremiumPaletteSelectionUi();
                  } catch {}
                } else {
                  const msg = (data && data.error) ? String(data.error) : t('messages.purchaseFail');
                  showToast(msg, 'error', 2500);
                }
              } catch (e) {
                showToast(t('messages.purchaseFail'), 'error', 2500);
              }
            })();
          };
        }
      } catch {}
    }
    function showAccountList() {
      if (!accountsSection || !accountFormSection) return;
      accountFormSection.hidden = true;
      if (shopViewSection) shopViewSection.hidden = true;
      accountsSection.hidden = false;
      try { if (shopBackBtn) shopBackBtn.hidden = true; } catch {}
      try { if (shopDropletsInfo) shopDropletsInfo.hidden = true; } catch {}
      try { accountSaveBtn.textContent = t('buttons.add'); } catch {}
    }

    // Shop interactions
    const SHOP_PRICE_MAX = 500;
    const SHOP_PRICE_REC = 500;
    let shopCurrentDroplets = 0;

    function parseQty(el){
      const n = parseInt((el && el.textContent) ? el.textContent.trim() : '1', 10);
      return Number.isFinite(n) && n >= 1 ? n : 1;
    }
    function updatePrice(which){
      if (which === 'max') {
        const qty = parseQty(shopMaxQtyEl);
        if (shopMaxPriceEl) shopMaxPriceEl.textContent = '💧 ' + (SHOP_PRICE_MAX * qty) + ' Droplets';
        try {
          const nameEl = document.getElementById('shop-max-name');
          if (nameEl) nameEl.textContent = '+'+5*qty + ' Max. Charges';
        } catch {}
      } else {
        const qty = parseQty(shopRecQtyEl);
        if (shopRecPriceEl) shopRecPriceEl.textContent = '💧 ' + (SHOP_PRICE_REC * qty) + ' Droplets';
        try {
          const nameEl = document.getElementById('shop-rec-name');
          if (nameEl) nameEl.textContent = '+'+30*qty+ ' Paint Charges';
        } catch {}
      }
      try { updateShopButtonsDisabled(); } catch {}
    }
    function changeQty(which, delta){
      if (which === 'max') {
        const next = Math.max(1, parseQty(shopMaxQtyEl) + delta);
        if (shopMaxQtyEl) shopMaxQtyEl.textContent = String(next);
        updatePrice('max');
      } else {
        const next = Math.max(1, parseQty(shopRecQtyEl) + delta);
        if (shopRecQtyEl) shopRecQtyEl.textContent = String(next);
        updatePrice('rec');
      }
    }
    function setMaxAffordable(which){
      const unit = which === 'max' ? SHOP_PRICE_MAX : SHOP_PRICE_REC;
      const able = Math.max(1, Math.floor((shopCurrentDroplets || 0) / unit));
      if (which === 'max') {
        if (shopMaxQtyEl) shopMaxQtyEl.textContent = String(able);
        updatePrice('max');
      } else {
        if (shopRecQtyEl) shopRecQtyEl.textContent = String(able);
        updatePrice('rec');
      }
    }

    function updateShopButtonsDisabled(){
      try {
        const maxQty = parseQty(shopMaxQtyEl);
        const recQty = parseQty(shopRecQtyEl);
        const costMax = SHOP_PRICE_MAX * maxQty;
        const costRec = SHOP_PRICE_REC * recQty;
        if (shopMaxPriceEl) shopMaxPriceEl.setAttribute('aria-disabled', (shopCurrentDroplets < costMax) ? 'true' : 'false');
        if (shopRecPriceEl) shopRecPriceEl.setAttribute('aria-disabled', (shopCurrentDroplets < costRec) ? 'true' : 'false');
      } catch {}
      try {
        const disabled = !(shopSelectedPremiumColorId != null);
        if (shopSelectedPremiumColorId != null && shopPremiumBuyBtn) {
          const cost = 2000; // premium color price
          shopPremiumBuyBtn.setAttribute('aria-disabled', (shopCurrentDroplets < cost) ? 'true' : 'false');
        }
      } catch {}
    }

    function updateShopAutobuyUi(){
      const val = shopCurrentAccount && shopCurrentAccount.autobuy;
      try {
        const onMax = val === 'max';
        if (shopMaxAutoBtn) {
          shopMaxAutoBtn.setAttribute('aria-checked', onMax ? 'true' : 'false');
          shopMaxAutoBtn.classList.toggle('on', onMax);
        }
        const onRec = val === 'rec';
        if (shopRecAutoBtn) {
          shopRecAutoBtn.setAttribute('aria-checked', onRec ? 'true' : 'false');
          shopRecAutoBtn.classList.toggle('on', onRec);
        }
      } catch {}
    }

    async function toggleAutobuy(which){
      const account = shopCurrentAccount;
      if (!account) return;
      const newVal = account.autobuy === which ? null : which;
      try {
        const res = await fetch('/api/accounts/' + encodeURIComponent(String(account.id)), {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ autobuy: newVal })
        });
        const data = await res.json();
        if (res.ok && data) {
          shopCurrentAccount = data;
          const idx = Array.isArray(accountsData) ? accountsData.findIndex(a => a && a.id === data.id) : -1;
          if (idx !== -1) accountsData[idx] = data;
          updateShopAutobuyUi();
        }
      } catch {}
    }

    // Wire buttons
    if (shopMaxDecBtn) shopMaxDecBtn.addEventListener('click', () => changeQty('max', -1));
    if (shopMaxIncBtn) shopMaxIncBtn.addEventListener('click', () => changeQty('max', +1));
    if (shopMaxMaxBtn) shopMaxMaxBtn.addEventListener('click', () => setMaxAffordable('max'));
    if (shopMaxAutoBtn) shopMaxAutoBtn.addEventListener('click', () => toggleAutobuy('max'));
    if (shopMaxPriceEl) shopMaxPriceEl.addEventListener('click', async () => {
      // Make purchase for +5 Max. Charges using amount from qty
      try {
        const qty = parseQty(shopMaxQtyEl);
        const account = shopCurrentAccount;
        const token = account && account.token ? String(account.token) : '';
        if (!token) { showToast(t('messages.accountNotFound'), 'error', 2000); return; }
        const res = await fetch('/api/purchase', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ productId: 70, amount: Math.max(1, Number(qty || 1)), j: token })
        });
        const data = await res.json();
        if (res.ok && data && data.success === true) {
          showToast(t('messages.purchaseSuccess'), 'success', 2000);
          try { await refreshAccountById(account.id); } catch {}
          try {
            if (shopDropletsInfo) {
              const updated = Array.isArray(accountsData) ? accountsData.find(r => r && r.id === account.id) : null;
              const dRaw = updated && updated.droplets != null ? Number(updated.droplets) : null;
              const label = Number.isFinite(dRaw) ? String(Math.floor(dRaw)) : '-';
              shopDropletsInfo.textContent = '💧 Droplets: ' + label;
            }
          } catch {}
          // Ensure internal state is refreshed so affordability checks are correct
          try {
            const updated = Array.isArray(accountsData) ? accountsData.find(r => r && r.id === account.id) : null;
            const dRaw2 = updated && updated.droplets != null ? Number(updated.droplets) : null;
            shopCurrentDroplets = Number.isFinite(dRaw2) ? Math.floor(dRaw2) : 0;
            updateShopButtonsDisabled();
            if (shopMaxQtyEl) shopMaxQtyEl.textContent = '1';
            updatePrice('max');
          } catch {}
        } else {
          const msg = (data && data.error) ? String(data.error) : t('messages.purchaseFail');
          showToast(msg, 'error', 2500);
        }
      } catch {
        showToast(t('messages.purchaseFail'), 'error', 2500);
      }
    });
    if (shopRecDecBtn) shopRecDecBtn.addEventListener('click', () => changeQty('rec', -1));
    if (shopRecIncBtn) shopRecIncBtn.addEventListener('click', () => changeQty('rec', +1));
    if (shopRecMaxBtn) shopRecMaxBtn.addEventListener('click', () => setMaxAffordable('rec'));
    if (shopRecAutoBtn) shopRecAutoBtn.addEventListener('click', () => toggleAutobuy('rec'));
    if (shopRecPriceEl) shopRecPriceEl.addEventListener('click', async () => {
      // Purchase +30 Paint Charges (product id 80) using rec qty
      try {
        const qty = parseQty(shopRecQtyEl);
        const account = shopCurrentAccount;
        const token = account && account.token ? String(account.token) : '';
        if (!token) { showToast(t('messages.accountNotFound'), 'error', 2000); return; }
        const res = await fetch('/api/purchase', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ productId: 80, amount: Math.max(1, Number(qty || 1)), j: token })
        });
        const data = await res.json();
        if (res.ok && data && data.success === true) {
          showToast(t('messages.purchaseSuccess'), 'success', 2000);
          try { await refreshAccountById(account.id); } catch {}
          try {
            if (shopDropletsInfo) {
              const updated = Array.isArray(accountsData) ? accountsData.find(r => r && r.id === account.id) : null;
              const dRaw = updated && updated.droplets != null ? Number(updated.droplets) : null;
              const label = Number.isFinite(dRaw) ? String(Math.floor(dRaw)) : '-';
              shopDropletsInfo.textContent = '💧 Droplets: ' + label;
            }
          } catch {}
          // Ensure internal state is refreshed so affordability checks are correct
          try {
            const updated = Array.isArray(accountsData) ? accountsData.find(r => r && r.id === account.id) : null;
            const dRaw2 = updated && updated.droplets != null ? Number(updated.droplets) : null;
            shopCurrentDroplets = Number.isFinite(dRaw2) ? Math.floor(dRaw2) : 0;
            updateShopButtonsDisabled();
            if (shopRecQtyEl) shopRecQtyEl.textContent = '1';
            updatePrice('rec');
          } catch {}
        } else {
          const msg = (data && data.error) ? String(data.error) : t('messages.purchaseFail');
          showToast(msg, 'error', 2500);
        }
      } catch {
        showToast(t('messages.purchaseFail'), 'error', 2500);
      }
    });
    if (addAccountBtn) {
      addAccountBtn.addEventListener('click', async () => {
        showAccountForm();
      });
    }
    if (accountCancelBtn) {
      accountCancelBtn.addEventListener('click', showAccountList);
    }
    if (shopBackBtn) {
      shopBackBtn.addEventListener('click', showAccountList);
    }
    function renderAccountsTable(rows) {
      const sortedRows = Array.isArray(rows) ? rows.slice().sort((a, b) => {
        const aActive = a && a.active !== false;
        const bActive = b && b.active !== false;
        if (aActive === bActive) return 0;
        return aActive ? 1 : -1; // Inactive first
      }) : [];
      accountsData = sortedRows.slice();
      try { recomputeActivePalette(); } catch {}
      accountsTbody.innerHTML = '';
      sortedRows.forEach(row => {
        const tr = document.createElement('tr');
        const tdName = document.createElement('td'); tdName.textContent = row.name || '';
        const tdToken = document.createElement('td');
        const fullToken = row.token || '';
        const shortToken = (fullToken && fullToken.length > 12)
          ? (fullToken.slice(0, 6) + '…' + fullToken.slice(-6))
          : fullToken;
        tdToken.textContent = shortToken;
        tdToken.title = fullToken;
        const tdDroplets = document.createElement('td');
        const dRaw = (row && row.droplets != null) ? Number(row.droplets) : null;
        tdDroplets.textContent = Number.isFinite(dRaw) ? String(Math.floor(dRaw)) : '-';
        const tdPixel = document.createElement('td');
        const countRaw = (row.pixelCount == null ? null : Number(row.pixelCount));
        const maxRaw = (row.pixelMax == null ? null : Number(row.pixelMax));
        const count = (Number.isFinite(countRaw) ? Math.floor(countRaw) : null);
        const max = (Number.isFinite(maxRaw) ? Math.floor(maxRaw) : null);
        const isActive = row && row.active !== false;
        tdPixel.textContent = (count == null || max == null) ? '-' : (String(count) + ' / ' + String(max));
        const tdStatus = document.createElement('td');
        // Add a toggle switch for active status
        const toggleLabel = document.createElement('label');
        toggleLabel.className = 'toggle';
        const toggleInput = document.createElement('input');
        toggleInput.type = 'checkbox';
        toggleInput.checked = isActive;
        toggleInput.addEventListener('change', async (e) => {
          const newStatus = e.target.checked;
          try {
            const res = await fetch('/api/accounts/' + row.id, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ active: newStatus })
            });
            if (res.ok) {
              row.active = newStatus; // Update local state
              showToast(t('messages.statusUpdated'), 'success', 1500);
              loadAccounts(); // Re-render table to reflect changes
            } else {
              showToast(t('messages.statusUpdateFailed'), 'error', 2500);
              toggleInput.checked = !newStatus; // Revert toggle if update fails
            }
          } catch (err) {
            showToast(t('messages.statusUpdateFailed'), 'error', 2500);
            toggleInput.checked = !newStatus; // Revert toggle on network error
          }
        });
        const toggleSlider = document.createElement('span');
        toggleSlider.className = 'slider';
        toggleLabel.appendChild(toggleInput);
        toggleLabel.appendChild(toggleSlider);
        tdStatus.appendChild(toggleLabel);

        const tdActions = document.createElement('td');
        const actionsWrap = document.createElement('div');
        actionsWrap.className = 'table-actions';
        const rowTop = document.createElement('div');
        rowTop.className = 'table-actions-row';
        const rowBottom = document.createElement('div');
        rowBottom.className = 'table-actions-row';
        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.className = 'app-btn';
        editBtn.textContent = t('buttons.edit');
        editBtn.addEventListener('click', () => {
          openEditAccount(row);
        });
        const checkBtn = document.createElement('button');
        checkBtn.type = 'button';
        checkBtn.className = 'app-btn';
        checkBtn.textContent = t('buttons.checkPixels');
        checkBtn.addEventListener('click', async () => {
          try {
            const res = await fetch('/api/accounts/' + row.id + '/refresh', { method: 'POST' });
            if (!res.ok) return;
            const updated = await res.json();
            await loadAccounts();
          } catch {}
        });
        const shopBtn = document.createElement('button');
        shopBtn.type = 'button';
        shopBtn.className = 'app-btn';
        shopBtn.textContent = t('buttons.shop');
        // Disable shop for inactive accounts
        try { shopBtn.disabled = !isActive; } catch {}
        shopBtn.addEventListener('click', async () => {
          if (shopBtn.disabled) return;
          try { shopBtn.disabled = true; } catch {}
          try {
            const res = await fetch('/api/accounts/' + row.id + '/refresh', { method: 'POST' });
            
          } catch {}
          try { await loadAccounts(); } catch {}
          try {
            const updated = Array.isArray(accountsData) ? accountsData.find(r => r && r.id === row.id) : null;
            const isActive = updated && updated.active !== false;
            if (!isActive) { return; }
            openShopAccount(updated);
          } finally { try { shopBtn.disabled = false; } catch {} }
        });
        const delBtn = document.createElement('button');
        delBtn.type = 'button';
        delBtn.className = 'app-btn';
        delBtn.textContent = t('buttons.delete');
        delBtn.addEventListener('click', async () => {
          try {
            await fetch('/api/accounts/' + row.id, { method: 'DELETE' });
            await loadAccounts();
          } catch {}
        });
        rowTop.appendChild(editBtn);
        rowTop.appendChild(delBtn);
        rowBottom.appendChild(checkBtn);
        rowBottom.appendChild(shopBtn);
        actionsWrap.appendChild(rowTop);
        actionsWrap.appendChild(rowBottom);
        tdActions.appendChild(actionsWrap);
        tr.appendChild(tdName);
        tr.appendChild(tdToken);
        tr.appendChild(tdDroplets);
        tr.appendChild(tdPixel);
        tr.appendChild(tdStatus);
        tr.appendChild(tdActions);
        accountsTbody.appendChild(tr);
      });
      
      try {
        if (Array.isArray(sortedRows) && pixelPowerEl) {
          let totalCount = 0;
          let totalMax = 0;
          for (let i = 0; i < sortedRows.length; i++) {
            const r = sortedRows[i];
            const isActive = r && r.active !== false && !!r.token;
            if (!isActive) continue;
            const cRaw = Number(r.pixelCount);
            const mRaw = Number(r.pixelMax);
            const c = Number.isFinite(cRaw) ? Math.floor(cRaw) : null;
            const m = Number.isFinite(mRaw) ? Math.floor(mRaw) : null;
            if (c != null) totalCount += c;
            if (m != null) totalMax += m;
          }
          try { pixelPowerEl.setAttribute('data-count', String(totalCount)); pixelPowerEl.setAttribute('data-max', String(totalMax)); } catch {}
          pixelPowerEl.textContent = t('pixel.powerLabel', { count: totalCount, max: totalMax });
          try { checkFullnessNotify(); } catch {}
        }
      } catch {}
    }
    async function loadAccounts() {
      try {
        const res = await fetch('/api/accounts');
        const data = await res.json();
        if (Array.isArray(data)) renderAccountsTable(data);   
        updateTotalDropletsDisplay(); // Cập nhật tổng droplets sau khi render bảng tài khoản

        // Fetch settings and populate update interval input
        const settingsRes = await fetch('/api/settings');
        if (settingsRes.ok) {
          const settings = await settingsRes.json();
          if (settings && typeof settings.updateIntervalMinutes === 'number') {
            const updateIntervalInput = document.getElementById('update-interval-input');
            if (updateIntervalInput) {
              updateIntervalInput.value = String(settings.updateIntervalMinutes);
            }
          }
        }
      } catch {}
    }
    async function refreshAccountById(accountId){
      try {
        await fetch('/api/accounts/' + encodeURIComponent(String(accountId)) + '/refresh', { method: 'POST' });
      } catch {}
      try { await loadAccounts(); } catch {}
    }
    const BULK_REFRESH_PERIOD_MS = 90 * 1000;
    let lastBulkRefreshAt = 0;
    let bulkRefreshInFlight = false;
    async function refreshAllAccounts(){
      const now = Date.now();
      if (bulkRefreshInFlight) return;
      if (now - lastBulkRefreshAt < BULK_REFRESH_PERIOD_MS - 500) return;
      bulkRefreshInFlight = true;
      try {
        const res = await fetch('/api/accounts');
        const rows = await res.json();
        if (Array.isArray(rows)) {
      updateTotalDropletsDisplay(); // Cập nhật tổng droplets sau khi load accounts
          for (let i = 0; i < rows.length; i++) {
            const r = rows[i];
            const id = r && r.id != null ? String(r.id) : '';
            if (!id) continue;
            try { await fetch('/api/accounts/' + encodeURIComponent(id) + '/refresh', { method: 'POST' }); } catch {}
            
            try { await new Promise(resolve => setTimeout(resolve, 1000)); } catch {}
          }
        }
      } catch {}
      try { await loadAccounts(); } catch {}
      try { reloadCurrentBackground(); } catch {}
      finally {
        lastBulkRefreshAt = Date.now();
        bulkRefreshInFlight = false;
      }
    }

    if (checkAllBtn) {
      checkAllBtn.addEventListener('click', async () => {
        if (bulkRefreshInFlight) return;
        try { checkAllBtn.classList.add('spinning'); } catch {}
        try { checkAllBtn.disabled = true; } catch {}
        try {
          await refreshAllAccounts();
        } finally {
          try { checkAllBtn.classList.remove('spinning'); } catch {}
          try { checkAllBtn.disabled = false; } catch {}
        }
      });
    }
    if (accountSaveBtn && accountsTbody) {
      accountSaveBtn.addEventListener('click', async () => {
        const id = (accountIdInput.value || '').trim();
        const name = (accountNameInput.value || '').trim();
        const token = (accountTokenInput.value || '').trim();
        const cf_clearance = (accountCfInput && accountCfInput.value) ? accountCfInput.value.trim() : '';
        const active = (document.getElementById('account-active-toggle').checked); // Get active status
        if (!name || !token || !cf_clearance || cf_clearance.length < 30) {
          showToast('cf_clearance zorunlu (min 30 karakter).', 'error', 2500);
          return;
        }
        try {
          try { await loadAccounts(); } catch {}
          try {
            const dup = Array.isArray(accountsData) && accountsData.find(row => {
              if (!row) return false;
              const sameId = (id && String(row.id) === id);
              return !sameId && String(row.token || '') === token;
            });
            if (dup) {
              showToast(t('messages.tokenAlreadyExists'), 'error', 2500);
              return;
            }
          } catch {}
          if (id) {
            const res = await fetch('/api/accounts/' + id, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name, token, cf_clearance, active })
            });
            if (!res.ok) return;
            try { await fetch('/api/accounts/' + id + '/refresh', { method: 'POST' }); } catch {}
          } else {
            const res = await fetch('/api/accounts', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name, token, cf_clearance, active })
            });
            if (!res.ok) return;
            try {
              const created = await res.json();
              if (created && created.id != null) {
                try { await fetch('/api/accounts/' + String(created.id) + '/refresh', { method: 'POST' }); } catch {}
              }
            } catch {}
          }
          await loadAccounts();
          showAccountList();
        } catch {}
      });
    }
    let accountTokenInputDebounce = null;
    if (accountTokenInput) {
      accountTokenInput.addEventListener('input', () => {
        const id = (accountIdInput && accountIdInput.value) ? accountIdInput.value.trim() : '';
        if (!id) return; 
        const name = (accountNameInput && accountNameInput.value) ? accountNameInput.value.trim() : '';
        const token = (accountTokenInput && accountTokenInput.value) ? accountTokenInput.value.trim() : '';
        try { if (accountTokenInputDebounce) clearTimeout(accountTokenInputDebounce); } catch {}
        accountTokenInputDebounce = setTimeout(async () => {
          try {
            if (!token) return;
            try { await loadAccounts(); } catch {}
            try {
              const dup = Array.isArray(accountsData) && accountsData.find(row => {
                if (!row) return false;
                const sameId = (id && String(row.id) === id);
                return !sameId && String(row.token || '') === token;
              });
              if (dup) {
                showToast(t('messages.tokenAlreadyExists'), 'error', 2500);
                return;
              }
            } catch {}
            await fetch('/api/accounts/' + id, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name, token })
            });
            await fetch('/api/accounts/' + id + '/refresh', { method: 'POST' });
            await loadAccounts();
          } catch {}
        }, 800);
      });
    }
    
    accountsClose.addEventListener('click', () => {
      accountsModal.hidden = true;
    });
    accountsModal.addEventListener('click', (e) => {
      if (e.target === accountsModal) accountsModal.hidden = true;
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') accountsModal.hidden = true;
    });

    function fetchTile(area, no) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = buildUrl(area, no) + '?t=' + Date.now();
      });
    }

    

    
    sign.addEventListener('load', () => {});

    
    uploadBtn.addEventListener('click', () => {
      try { signFileInput.value = ''; } catch {}
      signFileInput.click();
    });
    const imgPreviewModal = document.getElementById('img-preview-modal');
    const imgPreviewCanvas = document.getElementById('img-preview-canvas');
    const imgPreviewClose = document.getElementById('img-preview-close');
    const imgPreviewCancel = document.getElementById('img-preview-cancel');
    const imgPreviewApply = document.getElementById('img-preview-apply');
    const imgScaleInput = document.getElementById('img-scale');
    const imgKeepRatioInput = document.getElementById('img-keep-ratio');
    const imgWidthInput = document.getElementById('img-width');
    const imgHeightInput = document.getElementById('img-height');
    const imgFillToggle = document.getElementById('img-fill-toggle');
    const imgFillColorWrap = document.getElementById('img-fill-color');
    const imgAlphaInput = document.getElementById('img-alpha-input');
    const imgColorMetricSelect = document.getElementById('img-color-metric');
    const imgDitherToggle = document.getElementById('img-dither-toggle');
    const imgTemplateXInput = document.getElementById('img-template-x'); // Updated
    const imgTemplateYInput = document.getElementById('img-template-y'); // Updated
    const imgColorConversionToggle = document.getElementById('img-color-conversion-toggle'); // New element
    let imgDitherEnabled = false;
    let imgColorConversionEnabled = true; // Default to true
    let imgFillColorId = null; // null => none, number => palette id
    let previewSourceImage = null;
 
    function updateColorConversionButtonUi() {
      if (!imgColorConversionToggle) return;
      const key = imgColorConversionEnabled ? 'preview.colorConversionOn' : 'preview.colorConversionOff';
      imgColorConversionToggle.textContent = t(key);
      imgColorConversionToggle.dataset.state = imgColorConversionEnabled ? 'on' : 'off';
    }

    function updateDitherButtonUi(){
      if (!imgDitherToggle) return;
      const key = imgDitherEnabled ? 'preview.ditheringOn' : 'preview.ditheringOff';
      imgDitherToggle.textContent = t(key);
      imgDitherToggle.dataset.state = imgDitherEnabled ? 'on' : 'off';
    }

    if (imgColorConversionToggle) imgColorConversionToggle.addEventListener('click', () => {
      imgColorConversionEnabled = !imgColorConversionEnabled;
      try { localStorage.setItem('img.colorConversionEnabled', imgColorConversionEnabled ? '1' : '0'); } catch {}
      updateColorConversionButtonUi();
      drawPreview();
    });

    function openImagePreview(image, filename, isTemplate = false){
      previewSourceImage = image;
      imgPreviewApply._isTemplate = isTemplate;
      const w = image.naturalWidth|0;
      const h = image.naturalHeight|0;
      try { imgWidthInput.value = String(w); } catch {}
      try { imgHeightInput.value = String(h); } catch {}
      try { imgScaleInput.value = '100'; } catch {}
      try { if (imgFillToggle) imgFillToggle.checked = false; } catch {}
      imgFillColorId = null;
      buildFillPaletteUi();
      try { if (imgFillColorWrap) imgFillColorWrap.setAttribute('aria-disabled', 'true'); } catch {}
      try { imgAlphaInput.value = '5'; } catch {}
      try { imgColorMetricSelect.value = 'oklab'; } catch {}
      imgDitherEnabled = false;
      updateDitherButtonUi();
      drawPreview();
      imgPreviewModal.hidden = false;
      try {
        document.body.classList.add('no-scroll');
        if (colorPaletteEl) colorPaletteEl.hidden = true;
        if (paletteModeEl) paletteModeEl.hidden = true;
      } catch {}
      imgPreviewApply._filename = filename || 'image.png';
    }
    function drawPreview(){
      if (!imgPreviewCanvas || !previewSourceImage) return;
      const ctxp = imgPreviewCanvas.getContext('2d');
      ctxp.imageSmoothingEnabled = false;
      ctxp.clearRect(0,0,imgPreviewCanvas.width,imgPreviewCanvas.height);
      const targetW = Math.max(1, parseInt(imgWidthInput.value||'1', 10));
      const targetH = Math.max(1, parseInt(imgHeightInput.value||'1', 10));
      const off = document.createElement('canvas'); off.width = targetW; off.height = targetH;
      const octx = off.getContext('2d', { willReadFrequently: true });
      octx.imageSmoothingEnabled = false;
      octx.drawImage(previewSourceImage, 0, 0, previewSourceImage.naturalWidth, previewSourceImage.naturalHeight, 0, 0, targetW, targetH);
      try {
        // If it's a template, skip all image processing (alpha, dithering, palette quantization)
        if (imgColorConversionEnabled) { // Only apply color conversion if enabled
          // Existing image processing logic for non-template images
          const id = octx.getImageData(0, 0, targetW, targetH);
          const data = id.data;
          const alphaTh = imgAlphaInput ? parseInt(imgAlphaInput.value||'0',10) : 0;
          for (let i = 0; i < data.length; i += 4) {
            data[i+3] = (data[i+3] <= alphaTh) ? 0 : 255;
          }
          const metric = imgColorMetricSelect ? imgColorMetricSelect.value : 'oklab';
          if (imgDitherEnabled) {
            const w2 = targetW + 2;
            const errCurrR = new Float32Array(w2), errCurrG = new Float32Array(w2), errCurrB = new Float32Array(w2);
            const errNextR = new Float32Array(w2), errNextG = new Float32Array(w2), errNextB = new Float32Array(w2);
            for (let y = 0; y < targetH; y++) {
              const leftToRight = (y % 2 === 0);
              for (let i = 0; i < w2; i++) { errCurrR[i] += 0; errCurrG[i] += 0; errCurrB[i] += 0; }
              if (leftToRight) {
                for (let x = 0; x < targetW; x++) {
                  const idx = (y * targetW + x) * 4;
                  if (data[idx + 3] === 0) continue;
                  let r = data[idx] + errCurrR[x+1];
                  let g = data[idx+1] + errCurrG[x+1];
                  let b = data[idx+2] + errCurrB[x+1];
                  r = r < 0 ? 0 : (r > 255 ? 255 : r);
                  g = g < 0 ? 0 : (g > 255 ? 255 : g);
                  b = b < 0 ? 0 : (b > 255 ? 255 : b);
                  const nn = nearestPaletteColor(r, g, b, metric);
                  data[idx] = nn[0]; data[idx+1] = nn[1]; data[idx+2] = nn[2];
                  const er = r - nn[0];
                  const eg = g - nn[1];
                  const eb = b - nn[2];
                  errCurrR[x+2] += er * (7/16); errCurrG[x+2] += eg * (7/16); errCurrB[x+2] += eb * (7/16);
                  errNextR[x  ] += er * (3/16); errNextG[x  ] += eg * (3/16); errNextB[x  ] += eb * (3/16);
                  errNextR[x+1] += er * (5/16); errNextG[x+1] += eg * (5/16); errNextB[x+1] += eb * (5/16);
                  errNextR[x+2] += er * (1/16); errNextG[x+2] += eg * (1/16); errNextB[x+2] += eb * (1/16);
                }
              } else {
                for (let x = targetW - 1; x >= 0; x--) {
                  const idx = (y * targetW + x) * 4;
                  if (data[idx + 3] === 0) continue;
                  let r = data[idx] + errCurrR[x+1];
                  let g = data[idx+1] + errCurrG[x+1];
                  let b = data[idx+2] + errCurrB[x+1];
                  r = r < 0 ? 0 : (r > 255 ? 255 : r);
                  g = g < 0 ? 0 : (g > 255 ? 255 : g);
                  b = b < 0 ? 0 : (b > 255 ? 255 : b);
                  const nn = nearestPaletteColor(r, g, b, metric);
                  data[idx] = nn[0]; data[idx+1] = nn[1]; data[idx+2] = nn[2];
                  const er = r - nn[0];
                  const eg = g - nn[1];
                  const eb = b - nn[2];
                  errCurrR[x  ] += er * (7/16); errCurrG[x  ] += eg * (7/16); errCurrB[x  ] += eb * (7/16);
                  errNextR[x+2] += er * (3/16); errNextG[x+2] += eg * (3/16); errNextB[x+2] += eb * (3/16);
                  errNextR[x+1] += er * (5/16); errNextG[x+1] += eg * (5/16); errNextB[x+1] += eb * (5/16);
                  errNextR[x  ] += er * (1/16); errNextG[x  ] += eg * (1/16); errNextB[x  ] += eb * (1/16);
                }
              }
              for (let i = 0; i < w2; i++) { errCurrR[i] = errNextR[i]; errCurrG[i] = errNextG[i]; errCurrB[i] = errNextB[i]; errNextR[i]=0; errNextG[i]=0; errNextB[i]=0; }
            }
          } else {
            for (let y = 0; y < targetH; y++) {
              for (let x = 0; x < targetW; x++) {
                const idx = (y * targetW + x) * 4;
                if (data[idx + 3] === 0) continue;
                const nn = nearestPaletteColor(data[idx], data[idx+1], data[idx+2], metric);
                data[idx] = nn[0]; data[idx+1] = nn[1]; data[idx+2] = nn[2];
              }
            }
          }
          octx.putImageData(id, 0, 0);
        }
      } catch {}
      // Compose optional background fill for display
      let disp = off;
      if (imgFillToggle && imgFillToggle.checked && imgFillColorId != null) {
        const bg = document.createElement('canvas');
        bg.width = targetW; bg.height = targetH;
        const bctx = bg.getContext('2d', { willReadFrequently: true });
        const rgb = getPaletteRgbById(imgFillColorId);
        bctx.fillStyle = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';
        bctx.fillRect(0,0,targetW,targetH);
        bctx.drawImage(off, 0, 0);
        disp = bg;
      }
      const scale = Math.min(imgPreviewCanvas.width/targetW, imgPreviewCanvas.height/targetH);
      const drawW = Math.floor(targetW * scale);
      const drawH = Math.floor(targetH * scale);
      const dx = Math.floor((imgPreviewCanvas.width - drawW)/2);
      const dy = Math.floor((imgPreviewCanvas.height - drawH)/2);
      ctxp.drawImage(disp, 0, 0, targetW, targetH, dx, dy, drawW, drawH);
    }
    const MAX_DIM = 1000;
    function clampDim(v){ return Math.max(1, Math.min(MAX_DIM, v|0)); }
    function updateSizeFromScale(){
      const pct = Math.max(1, Math.min(800, parseInt(imgScaleInput.value||'100',10)));
      if (!previewSourceImage) return;
      const w0 = previewSourceImage.naturalWidth|0, h0 = previewSourceImage.naturalHeight|0;
      let nw = Math.round(w0 * pct / 100);
      let nh = Math.round(h0 * pct / 100);
      if (nw > MAX_DIM || nh > MAX_DIM) {
        const s = Math.min(MAX_DIM / nw, MAX_DIM / nh);
        nw = Math.max(1, Math.round(nw * s));
        nh = Math.max(1, Math.round(nh * s));
        try { showToast(t('preview.maxSizeExceeded'), 'error', 2000); } catch {}
      }
      imgWidthInput.value = String(nw);
      imgHeightInput.value = String(nh);
      drawPreview();
    }
    function updateHeightFromWidth(){
      if (!previewSourceImage) { drawPreview(); return; }
      let nw = clampDim(parseInt(imgWidthInput.value||'1',10));
      imgWidthInput.value = String(nw);
      if (!imgKeepRatioInput.checked) { drawPreview(); return; }
      const w0 = previewSourceImage.naturalWidth|0, h0 = previewSourceImage.naturalHeight|0;
      let nh = Math.round(nw * h0 / w0);
      if (nh > MAX_DIM) { nh = MAX_DIM; nw = Math.round(nh * w0 / h0); imgWidthInput.value = String(nw); try { showToast(t('preview.maxSizeExceeded'), 'error', 2000); } catch {} }
      imgHeightInput.value = String(nh);
      const pct = Math.round(nw / w0 * 100);
      imgScaleInput.value = String(pct);
      drawPreview();
    }
    function updateWidthFromHeight(){
      if (!previewSourceImage) { drawPreview(); return; }
      let nh = clampDim(parseInt(imgHeightInput.value||'1',10));
      imgHeightInput.value = String(nh);
      if (!imgKeepRatioInput.checked) {
        const w0 = previewSourceImage.naturalWidth|0, h0 = previewSourceImage.naturalHeight|0;
        const pct = Math.round(nh / (h0||1) * 100);
        imgScaleInput.value = String(pct);
        drawPreview();
        return;
      }
      const w0 = previewSourceImage.naturalWidth|0, h0 = previewSourceImage.naturalHeight|0;
      let nw = Math.round(nh * w0 / h0);
      if (nw > MAX_DIM) { nw = MAX_DIM; nh = Math.round(nw * h0 / w0); imgHeightInput.value = String(nh); try { showToast(t('preview.maxSizeExceeded'), 'error', 2000); } catch {} }
      imgWidthInput.value = String(nw);
      const pct = Math.round(nh / h0 * 100);
      imgScaleInput.value = String(pct);
      drawPreview();
    }
    if (imgScaleInput) imgScaleInput.addEventListener('input', updateSizeFromScale);
    if (imgWidthInput) imgWidthInput.addEventListener('change', updateHeightFromWidth);
    if (imgHeightInput) imgHeightInput.addEventListener('change', updateWidthFromHeight);
    if (imgKeepRatioInput) imgKeepRatioInput.addEventListener('change', () => { drawPreview(); });
    if (imgAlphaInput) {
      imgAlphaInput.addEventListener('input', () => {
        let v = parseInt(imgAlphaInput.value || '0', 10);
        if (isNaN(v)) v = 0;
        if (v < 0) v = 0; else if (v > 255) v = 255;
        imgAlphaInput.value = String(v);
        drawPreview();
      });
    }
    if (imgColorMetricSelect) imgColorMetricSelect.addEventListener('change', () => { drawPreview(); });
    if (imgDitherToggle) imgDitherToggle.addEventListener('click', () => { imgDitherEnabled = !imgDitherEnabled; updateDitherButtonUi(); drawPreview(); });
    function buildFillPaletteUi(){
      if (!imgFillColorWrap) return;
      try { imgFillColorWrap.innerHTML = ''; } catch {}
      // Transparent option (none)
      const swNone = document.createElement('div');
      swNone.className = 'palette-swatch modal-palette-swatch transparent selected';
      swNone.title = t('palette.transparentTitle');
      swNone.setAttribute('role','button');
      swNone.addEventListener('click', () => {
        imgFillColorId = null;
        updateFillPaletteSelectionUi();
        drawPreview();
        try { localStorage.removeItem('img.fillColorId'); } catch {}
      });
      imgFillColorWrap.appendChild(swNone);
      const arr = (ACTIVE_PALETTE && Array.isArray(ACTIVE_PALETTE)) ? ACTIVE_PALETTE : PALETTE;
      for (let i = 0; i < arr.length; i++){
        const p = arr[i];
        const el = document.createElement('div');
        el.className = 'palette-swatch modal-palette-swatch';
        el.style.backgroundColor = 'rgb(' + p.rgb[0] + ',' + p.rgb[1] + ',' + p.rgb[2] + ')';
        setPaletteSwatchTitle(el, p);
        el.setAttribute('data-id', String(p.id));
        el.setAttribute('role','button');
        el.addEventListener('click', () => {
          imgFillColorId = p.id;
          updateFillPaletteSelectionUi();
          drawPreview();
          try { localStorage.setItem('img.fillColorId', String(p.id)); } catch {}
        });
        imgFillColorWrap.appendChild(el);
      }
      updateFillPaletteSelectionUi();
      // Restore last chosen fill color if exists
      try {
        const savedFill = localStorage.getItem('img.fillColorId');
        if (savedFill != null) {
          imgFillColorId = Number(savedFill);
          updateFillPaletteSelectionUi();
          drawPreview();
        }
      } catch {}
    }
    function updateFillPaletteSelectionUi(){
      if (!imgFillColorWrap) return;
      const swatches = Array.from(imgFillColorWrap.querySelectorAll('.modal-palette-swatch'));
      swatches.forEach(sw => {
        const idAttr = sw.getAttribute('data-id');
        const id = idAttr == null ? null : Number(idAttr);
        const isSelected = (idAttr == null && imgFillColorId == null) || (idAttr != null && id === imgFillColorId);
        sw.classList.toggle('selected', !!isSelected);
      });
    }
    if (imgFillToggle) imgFillToggle.addEventListener('change', () => {
      try { imgFillColorWrap.setAttribute('aria-disabled', imgFillToggle.checked ? 'false' : 'true'); } catch {}
      drawPreview();
    });
    function closeImgPreview(){
      try {
        document.body.classList.remove('no-scroll');
        if (colorPaletteEl) colorPaletteEl.hidden = false;
        if (paletteModeEl) paletteModeEl.hidden = false;
      } catch {}
      imgPreviewModal.hidden = true;
    }
    if (imgPreviewClose) imgPreviewClose.addEventListener('click', closeImgPreview);
    if (imgPreviewCancel) imgPreviewCancel.addEventListener('click', closeImgPreview);
    if (imgPreviewApply) imgPreviewApply.addEventListener('click', async () => {
      try {
        if (!previewSourceImage) return;
        let targetW = clampDim(parseInt(imgWidthInput.value||'1', 10));
        let targetH = clampDim(parseInt(imgHeightInput.value||'1', 10));
        if (targetW > MAX_DIM || targetH > MAX_DIM) { try { showToast(t('preview.maxSizeExceeded'), 'error', 2000); } catch {} }
        const off = document.createElement('canvas');
        off.width = targetW; off.height = targetH;
        const octx = off.getContext('2d', { willReadFrequently: true });
        octx.imageSmoothingEnabled = false;
        if (imgFillToggle && imgFillToggle.checked && imgFillColorId != null) {
          const rgb = getPaletteRgbById(imgFillColorId);
          octx.fillStyle = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')';
          octx.fillRect(0, 0, targetW, targetH);
        }
        octx.drawImage(previewSourceImage, 0, 0, previewSourceImage.naturalWidth, previewSourceImage.naturalHeight, 0, 0, targetW, targetH);
        const blob = await new Promise((resolve)=>{ off.toBlob((b)=>resolve(b), 'image/png'); });
        const url0 = URL.createObjectURL(blob);
        const tmpImg = new Image();
        tmpImg.onload = async () => {
          URL.revokeObjectURL(url0);
          let finalBlob = blob;
          // Apply quantization (template feature removed)
          finalBlob = await quantizeImageToPalette(tmpImg);
          // Persist quantized image as data URL for future sessions
          try {
            const reader = new FileReader();
            reader.onloadend = () => {
              try { localStorage.setItem('last.image.dataUrl', String(reader.result || '')); } catch {}
            };
            reader.readAsDataURL(finalBlob);
          } catch {}

          const url = URL.createObjectURL(finalBlob);
          const imageEl = new Image();
          imageEl.onload = () => {
            const pixelCount = countNonTransparentPixels(imageEl);
            const item = { url, name: imgPreviewApply._filename || 'image.png', image: imageEl, originalImage: imageEl, worldX: 0, worldY: 0, el: null, locked: false, pixelCount };
            
            if (imgPreviewApply._isTemplate) {
              // For templates, use the X, Y coordinates from the inputs
              item.worldX = parseInt(imgTemplateXInput.value || '0', 10);
              item.worldY = parseInt(imgTemplateYInput.value || '0', 10);
            } else {
              // For non-templates, place at the center of the viewport, clamped by image bounds
              const centerPx = getContentCenterPx();
              const centerWorldX = (centerPx.x - state.translateX) / state.scale;
              const centerWorldY = (centerPx.y - state.translateY) / state.scale;
              item.worldX = centerWorldX - imageEl.naturalWidth / 2;
              item.worldY = centerWorldY - imageEl.naturalHeight / 2;
              
              if (img) { // Clamp to existing image bounds if a base image is present
                const maxX = Math.max(0, img.width - imageEl.naturalWidth);
                const maxY = Math.max(0, img.height - imageEl.naturalHeight);
                item.worldX = Math.min(Math.max(0, item.worldX), maxX);
                item.worldY = Math.min(Math.max(0, item.worldY), maxY);
              }
            }

            signItems.push(item);
            selectedIndex = signItems.length - 1;
            addThumbForItem(item, signItems.length - 1);
            updateCounter();
            try { saveImagesToStorage(); } catch {}
            // Always focus newly added image at current viewport center
            pendingZoomToSelected = true;
            render();
            if (pendingZoomToSelected) { pendingZoomToSelected = false; zoomToSign(item); }
            try { localStorage.setItem('last.image.url', url); localStorage.setItem('last.image.name', item.name || 'image.png'); } catch {}
            closeImgPreview();
          };
          imageEl.src = url;
        };
        tmpImg.src = url0;
      } catch {}
    });

    signFileInput.addEventListener('change', () => {
      const files = Array.from(signFileInput.files || []);
      if (!files.length) return;
      const file = files[0];
      const tmpUrl = URL.createObjectURL(file);
      const tmpImg = new Image();
      tmpImg.onload = () => {
        URL.revokeObjectURL(tmpUrl);
        openImagePreview(tmpImg, file.name, false);
      };
      tmpImg.src = tmpUrl;
    });

    <!-- Các phần liên quan đến templateFileInput và uploadTemplateBtn đã được loại bỏ -->
 
    
 
    try {
      const savedArea = localStorage.getItem('area code');
      const savedNo = localStorage.getItem('no');
      if (savedArea) areaInput.value = savedArea;
      if (savedNo) noInput.value = savedNo;
    } catch {}
    const readyBtn = document.getElementById('btn-ready');
    const readyPopup = document.getElementById('ready-popup');
    const autoSelectBtn = document.getElementById('btn-auto-select');
    const autoSelectAccountsBtn = document.getElementById('btn-auto-select-accounts');
    const startBtn = document.getElementById('start');
    const readyPixelEl = document.getElementById('ready-pixel');
    const readyAccountBtn = document.getElementById('btn-ready-account');
    const readyAccountList = document.getElementById('ready-account-list');
    const readyTokenInput = document.getElementById('ready-token-input');
    
    // --- Range Overlay V2 ---
    const rangeOverlay = document.getElementById('range-overlay');
    const btnAddOverlay = document.getElementById('btn-add-overlay');
    const overlayListEl = document.getElementById('overlay-list');
    const dimOverlay = document.getElementById('dim-overlay'); /* Lấy phần tử dim-overlay */
    const dimCtx = dimOverlay ? dimOverlay.getContext('2d') : null; /* Lấy context của dim-overlay */

    let isDrawingOverlay = false; // Controls if drawing mode is active (set by button click)
    let isDraggingOverlay = false; // Controls if a drag operation for overlay is in progress
    let overlayStartX = 0, overlayStartY = 0;
    let savedOverlays = [];
    let selectedOverlayIndex = -1;

    function renderOverlayList() {
        if (!overlayListEl) return;
        overlayListEl.innerHTML = '';
        savedOverlays.forEach((overlay, index) => {
            const item = document.createElement('div');
            item.className = 'overlay-item';
            // Add a class to indicate if it's the currently selected overlay for drawing/editing
            item.classList.toggle('selected', index === selectedOverlayIndex);
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = overlay.name || `Overlay ${index + 1}`;
            item.appendChild(nameSpan);

            const coordsSpan = document.createElement('span');
            coordsSpan.style.fontSize = '10px';
            coordsSpan.style.opacity = '0.7';
            coordsSpan.textContent = `(${overlay.rect.x}, ${overlay.rect.y}) - ${overlay.rect.w}x${overlay.rect.h}`;
            item.appendChild(coordsSpan);

            const actions = document.createElement('div');
            actions.className = 'overlay-item-actions';
            
            const toggleInput = document.createElement('input');
            toggleInput.type = 'checkbox';
            toggleInput.checked = overlay.isVisible !== false; // Default to true if not set
            toggleInput.title = 'Toggle visibility';
            toggleInput.onchange = (e) => {
                overlay.isVisible = e.target.checked;
                saveOverlaysToStorage();
                updateRangeOverlayPosition(); // Update display immediately
            };
            actions.appendChild(toggleInput);

            const selectBtn = document.createElement('button');
            selectBtn.textContent = t('buttons.selectOverlay');
            selectBtn.title = 'Select for drawing/editing';
            selectBtn.onclick = (e) => {
                e.stopPropagation();
                // Toggle selection: if already selected, deselect; otherwise, select this one
                selectedOverlayIndex = (selectedOverlayIndex === index) ? -1 : index;
                saveOverlaysToStorage(); // Save selection state
                renderOverlayList(); // Re-render to update selected class
                updateRangeOverlayPosition(); // Update range overlay display
            };
            actions.appendChild(selectBtn);

            const saveBtn = document.createElement('button');
            saveBtn.textContent = overlay.isSaved ? t('buttons.unsave') : t('buttons.save');
            saveBtn.title = overlay.isSaved ? 'Unsave overlay' : 'Save overlay';
            saveBtn.onclick = (e) => {
                e.stopPropagation();
                overlay.isSaved = !overlay.isSaved;
                saveOverlaysToStorage();
                renderOverlayList(); // Re-render to update button text
                updateRangeOverlayPosition(); // Update style
            };
            actions.appendChild(saveBtn);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = t('buttons.delete');
            deleteBtn.title = 'Delete overlay';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                savedOverlays.splice(index, 1);
                // Adjust selectedOverlayIndex if the deleted item was selected or before the selected one
                if (selectedOverlayIndex === index) {
                    selectedOverlayIndex = -1;
                } else if (selectedOverlayIndex > index) {
                    selectedOverlayIndex--;
                }
                saveOverlaysToStorage();
                renderOverlayList();
                updateRangeOverlayPosition();
            };
            actions.appendChild(deleteBtn);
            item.appendChild(actions);
            overlayListEl.appendChild(item);
        });
    }

    function updateRangeOverlayPosition() {
        if (!rangeOverlay || !img) return;
        // Clear previous overlays
        rangeOverlay.hidden = true; // Hide the main overlay element

        // Render all visible overlays from savedOverlays
        // This requires dynamically creating/managing multiple overlay elements or drawing on a canvas.
        // For simplicity, let's assume we'll manage a single visible overlay at selectedOverlayIndex
        // and if multiple are needed, we'd draw them onto a dedicated canvas.
        // For now, only the selected one will be drawn by this function.
        if (selectedOverlayIndex !== -1 && savedOverlays[selectedOverlayIndex] && savedOverlays[selectedOverlayIndex].isVisible !== false) {
            const rect = savedOverlays[selectedOverlayIndex].rect;
            const p = worldToScreen(rect.x, rect.y);
            const sizeW = rect.w * state.scale;
            const sizeH = rect.h * state.scale;
            rangeOverlay.style.left = p.x + 'px';
            rangeOverlay.style.top = p.y + 'px';
            rangeOverlay.style.width = sizeW + 'px';
            rangeOverlay.style.height = sizeH + 'px';
            rangeOverlay.hidden = false;
            rangeOverlay.classList.toggle('saved-overlay', savedOverlays[selectedOverlayIndex].isSaved);
        }
        updateDimOverlay(); // Always update dim overlay
    }

    function updateDimOverlay() {
        if (!dimOverlay || !dimCtx) return;
        
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;

        dimOverlay.width = Math.floor(viewportWidth * dpr);
        dimOverlay.height = Math.floor(viewportHeight * dpr);
        dimOverlay.style.width = viewportWidth + 'px';
        dimOverlay.style.height = viewportHeight + 'px';
        
        let anyOverlayVisible = false;
        // Check if any of the "saved overlays" are visible
        savedOverlays.forEach(overlay => {
            if (overlay.isVisible !== false) {
                anyOverlayVisible = true;
            }
        });

        // Also check if any of the main modals are visible
        const isAccountsModalVisible = !accountsModal.hidden;
        const isImgPreviewModalVisible = !imgPreviewModal.hidden;
        const isFavoritesModalVisible = !favoritesModal.hidden;
        const isSaveFavModalVisible = !saveFavModal.hidden;
        const isReadyPopupVisible = !readyPopup.hidden;

        const anyModalOrOverlayVisible = anyOverlayVisible || isAccountsModalVisible || isImgPreviewModalVisible || isFavoritesModalVisible || isSaveFavModalVisible || isReadyPopupVisible;

        if (anyModalOrOverlayVisible) {
            document.body.classList.add('no-scroll');
            dimOverlay.hidden = false;
            dimCtx.clearRect(0, 0, dimOverlay.width, dimOverlay.height);
            dimCtx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Màu làm mờ
            dimCtx.fillRect(0, 0, dimOverlay.width, dimOverlay.height);

            // Clear areas for all visible overlays drawn on the dim overlay
            savedOverlays.forEach(overlay => {
                if (overlay.isVisible !== false) {
                    const rect = overlay.rect;
                    const p = worldToScreen(rect.x, rect.y);
                    const sizeW = rect.w * state.scale;
                    const sizeH = rect.h * state.scale;

                    const clearX = Math.floor(p.x * dpr);
                    const clearY = Math.floor(p.y * dpr);
                    const clearW = Math.floor(sizeW * dpr);
                    const clearH = Math.floor(sizeH * dpr);

                    dimCtx.clearRect(clearX, clearY, clearW, clearH);
                }
            });
        } else {
            document.body.classList.remove('no-scroll');
            dimOverlay.hidden = true;
            dimCtx.clearRect(0, 0, dimOverlay.width, dimOverlay.height);
        }
    }
    
    function captureOverlayImageData(overlay) {
        if (!overlay || !img || !canvas || !ctx) return;

        const rect = overlay.rect;
        const tempCanvas = document.createElement('canvas');
        // Set temporary canvas dimensions to match the overlay's world dimensions
        tempCanvas.width = rect.w;
        tempCanvas.height = rect.h;
        const tempCtx = tempCanvas.getContext('2d');

        // Draw the relevant portion of the main canvas onto the temporary canvas
        // This captures the current state of the map/tiles in that region
        // The source coordinates for drawImage should be relative to the main canvas's world coordinates
        // which means the overlay's worldX and worldY.
        tempCtx.drawImage(
            canvas,
            rect.x, // Source X (world coordinate of overlay)
            rect.y, // Source Y (world coordinate of overlay)
            rect.w, // Source Width
            rect.h, // Source Height
            0, 0, // Destination X, Y (on the temp canvas)
            rect.w, // Destination Width
            rect.h // Destination Height
        );

        // Store the image data as a data URL
        overlay.imageData = tempCanvas.toDataURL();
    }

    function saveOverlaysToStorage() {
      try {
        const serializableOverlays = savedOverlays.map(ov => {
            // We need to store imageData if it exists, as it's the visual representation
            // The previous diff was incorrect in excluding it.
            // If imageData is too large for localStorage, we might need a different strategy (e.g., IndexedDB)
            // For now, let's include it and see. If it causes issues, we'll revisit.
            return {
                id: ov.id,
                name: ov.name,
                rect: ov.rect,
                isVisible: ov.isVisible,
                isSaved: ov.isSaved,
                imageData: ov.imageData // Include imageData
            };
        });
        localStorage.setItem('savedOverlays', JSON.stringify(serializableOverlays));
        localStorage.setItem('selectedOverlayIndex', selectedOverlayIndex);
      } catch {}
    }

    function loadOverlaysFromStorage() {
      try {
        const saved = localStorage.getItem('savedOverlays');
        const savedIndex = localStorage.getItem('selectedOverlayIndex');
        if (saved) {
          const loadedOverlays = JSON.parse(saved);
          savedOverlays = loadedOverlays.map(ov => {
              // Ensure isSaved property exists for old saved overlays
              if (typeof ov.isSaved === 'undefined') {
                  ov.isSaved = false;
              }
              // Re-create Image object from imageData URL if available
              if (ov.imageData) {
                  const imgEl = new Image();
                  imgEl.src = ov.imageData;
                  ov._imageEl = imgEl; // Store the Image object
              }
              return ov;
          });
        }
        if (savedIndex != null) {
          selectedOverlayIndex = parseInt(savedIndex, 10);
        }
        renderOverlayList();
        updateRangeOverlayPosition();
      } catch {}
    }

    if (btnAddOverlay) {
        btnAddOverlay.addEventListener('click', () => {
            if (isDrawingOverlay) { // If already in drawing mode, cancel it
                isDrawingOverlay = false;
                isDraggingOverlay = false;
                canvas.style.cursor = '';
                rangeOverlay.hidden = true;
                showToast(t('messages.overlayDrawingCancelled'), 'info', 1500);
            } else { // Enter drawing mode (waiting for drag)
                isDrawingOverlay = true; // Enable drawing mode
                canvas.style.cursor = 'crosshair';
                if(readyPopup) readyPopup.hidden = true; // Hide popup to draw
                selectedOverlayIndex = -1; // Deselect any old overlay
                rangeOverlay.hidden = true; // Hide the old range overlay
                rangeOverlay.classList.remove('saved-overlay'); // Remove saved style
                showToast(t('messages.dragToDrawOverlay'), 'info', 2000);
            }
        });
    }


    // Listen for token events from local server (extension posts here)
    (function initTokenSse(){
      try {
        const es = new EventSource('/api/events');
        es.addEventListener('token', async (ev) => {
          try {
            const data = ev && ev.data ? JSON.parse(ev.data) : null;
            const token = data && data.token ? String(data.token) : '';
            if (!token) return;
            const rp = document.getElementById('ready-popup');
            const isOpen = rp && !rp.hidden;
            if (isOpen && readyTokenInput) {
              readyTokenInput.value = token;
              try { updateStartEnabled(); } catch {}
              showToast(t('messages.tokenPastedFromExtension'), 'success', 1200);
              // Auto start on token if enabled
              try {
                const startBtn = document.getElementById('start');
                const canStart = startBtn && !startBtn.disabled;
                if (autoStart && canStart) {
                  await new Promise(r => setTimeout(r, 50));
                  startBtn.click();
                }
              } catch {}
            } else {
              try { localStorage.setItem('last.captured.token', token); } catch {}
            }
          } catch {}
        });
      } catch {}
    })();
    const autoModeTrack = document.getElementById('auto-mode-toggle');
    const autoModeLabelLeft = document.getElementById('auto-mode-label-left');
    const autoModeLabelRight = document.getElementById('auto-mode-label-right');
    // Removed duplicate declaration from here, as they are handled in the previous diff block
    // If they were truly meant to be separate variables, this change would be problematic.
    // Given the "Cannot access ... before initialization" error, this indicates
    // an issue with how they were being used without proper declaration.
const autoStartTrack = document.getElementById('auto-start-toggle');
    const autoStartLabelLeft = document.getElementById('auto-start-label-left');
    const autoStartLabelRight = document.getElementById('auto-start-label-right');
    const selectModeTrack = document.getElementById('select-mode-toggle');
    const selectModeLabelLeft = document.getElementById('select-mode-label-left');
    const selectModeLabelRight = document.getElementById('select-mode-label-right');
    const advancedPaintToggle = document.getElementById('advanced-paint-toggle');
    const advancedPaintLabelLeft = document.getElementById('advanced-paint-label-left');
    const advancedPaintLabelRight = document.getElementById('advanced-paint-label-right');
    let selectMode = 'multi';
    let autoMode = false;
    let autoStart = false;
    let advancedPaintEnabled = false;

    // Auto Paint state variables moved here for global scope
    let brokenPixelPaintEnabled = false;
    let priorityColorPaintEnabled = false;
    let priorityColors = [7]; // Stores color IDs
    let brokenPixelPriorityColors = [7]; // Stores broken pixel priority color IDs
    let minizineToDetectThreshold = 4; // Default value
    let isPickingColorMode = false; // New state for pick color tool
    let isPickingBrokenPixelColorMode = false; // New state for broken pixel pick color tool
    let premiumPaintPixelEnabled = false; // State for enabling/disabling premium paint pixel logic
    let freePaintPixelEnabled = false; // State for enabling/disabling free paint pixel logic
    let chessPaintEnabled = false;
    let limitToOverlayArea = false;


    function updateSelectModeUi(){
      try { if (selectModeTrack) selectModeTrack.classList.toggle('on', selectMode === 'frame'); } catch {}
      try { if (selectModeTrack) selectModeTrack.setAttribute('aria-checked', selectMode === 'frame' ? 'true' : 'false'); } catch {}
      try { if (selectModeLabelLeft) selectModeLabelLeft.classList.toggle('active', selectMode === 'multi'); } catch {}
      try { if (selectModeLabelRight) selectModeLabelRight.classList.toggle('active', selectMode === 'frame'); } catch {}
    }
    function setSelectMode(mode){
      selectMode = (mode === 'frame') ? 'frame' : 'multi';
      updateSelectModeUi();
    }
    function updateAutoModeUi(){
      try { if (autoModeTrack) autoModeTrack.classList.toggle('on', !!autoMode); } catch {}
      try { if (autoModeTrack) autoModeTrack.setAttribute('aria-checked', autoMode ? 'true' : 'false'); } catch {}
      try { if (autoModeLabelLeft) autoModeLabelLeft.classList.toggle('active', !autoMode); } catch {}
      try { if (autoModeLabelRight) autoModeLabelRight.classList.toggle('active', !!autoMode); } catch {}
    }
    function updateAutoStartUi(){
      try { if (autoStartTrack) autoStartTrack.classList.toggle('on', !!autoStart); } catch {}
      try { if (autoStartTrack) autoStartTrack.setAttribute('aria-checked', autoStart ? 'true' : 'false'); } catch {}
      try { if (autoStartLabelLeft) autoStartLabelLeft.classList.toggle('active', !autoStart); } catch {}
      try { if (autoStartLabelRight) autoStartLabelRight.classList.toggle('active', !!autoStart); } catch {}
    }
    function updateAdvancedPaintUi(){
      try { if (advancedPaintToggle) advancedPaintToggle.classList.toggle('on', !!advancedPaintEnabled); } catch {}
      try { if (advancedPaintToggle) advancedPaintToggle.setAttribute('aria-checked', advancedPaintEnabled ? 'true' : 'false'); } catch {}
      try { if (advancedPaintLabelLeft) advancedPaintLabelLeft.classList.toggle('active', !advancedPaintEnabled); } catch {}
      try { if (advancedPaintLabelRight) advancedPaintLabelRight.classList.toggle('active', !!advancedPaintEnabled); } catch {}
    }

    // Auto Paint UI update functions
    function updatePremiumPaintPixelUi(){
        // Implement as needed
    }
    function updateFreePaintPixelUi(){
        // Implement as needed
    }
    function updateBrokenPixelPaintUi(){
      try { if (brokenPixelPaintToggle) brokenPixelPaintToggle.classList.toggle('on', !!brokenPixelPaintEnabled); } catch {}
      try { if (brokenPixelPaintToggle) brokenPixelPaintToggle.setAttribute('aria-checked', brokenPixelPaintEnabled ? 'true' : 'false'); } catch {}
    }

    function updatePriorityColorPaintUi(){
      try { if (priorityColorPaintToggle) priorityColorPaintToggle.classList.toggle('on', !!priorityColorPaintEnabled); } catch {}
      try { if (priorityColorPaintToggle) priorityColorPaintToggle.setAttribute('aria-checked', priorityColorPaintEnabled ? 'true' : 'false'); } catch {}
    }

    function updateChessPaintUi(){
      try { if (chessPaintToggle) chessPaintToggle.classList.toggle('on', !!chessPaintEnabled); } catch {}
      try { if (chessPaintToggle) chessPaintToggle.setAttribute('aria-checked', chessPaintEnabled ? 'true' : 'false'); } catch {}
    }

    function updateLimitOverlayUi(){
      try { if (limitOverlayToggle) limitOverlayToggle.classList.toggle('on', !!limitToOverlayArea); } catch {}
      try { if (limitOverlayToggle) limitOverlayToggle.setAttribute('aria-checked', limitToOverlayArea ? 'true' : 'false'); } catch {}
    }

    // Initialization block for various settings from localStorage
    try {
      const savedAuto = localStorage.getItem('ready.autoMode');
      autoMode = (savedAuto === '1' || savedAuto === 'true');
      updateAutoModeUi();
      const savedAutoStart = localStorage.getItem('ready.autoStart');
      autoStart = (savedAutoStart === '1' || savedAutoStart === 'true');
      updateAutoStartUi();

      premiumPaintPixelEnabled = (localStorage.getItem('premiumPaintPixel.enabled') === '1' || localStorage.getItem('premiumPaintPixel.enabled') === 'true');
      // No updatePremiumPaintPixelUi() here as it's not implemented yet
      // updatePremiumPaintPixelUi();

      freePaintPixelEnabled = (localStorage.getItem('freePaintPixel.enabled') === '1' || localStorage.getItem('freePaintPixel.enabled') === 'true');
      // No updateFreePaintPixelUi() here as it's not implemented yet
      // updateFreePaintPixelUi();

      brokenPixelPaintEnabled = (localStorage.getItem('brokenPixelPaint.enabled') === '1' || localStorage.getItem('brokenPixelPaint.enabled') === 'true');
      updateBrokenPixelPaintUi();

      priorityColorPaintEnabled = (localStorage.getItem('priorityColorPaint.enabled') === '1' || localStorage.getItem('priorityColorPaint.enabled') === 'true');
      updatePriorityColorPaintUi();

      const savedChessPaint = localStorage.getItem('chessPaint.enabled');
      chessPaintEnabled = (savedChessPaint === '1' || savedChessPaint === 'true');
      updateChessPaintUi();

      const savedLimitOverlay = localStorage.getItem('limitOverlay.enabled');
      limitToOverlayArea = (savedLimitOverlay === '1' || savedLimitOverlay === 'true');
      updateLimitOverlayUi();
      
      const savedMinizine = localStorage.getItem('minizineToDetect.threshold');
      if (savedMinizine != null && !isNaN(Number(savedMinizine))) {
        minizineToDetectThreshold = Math.max(1, Math.min(100, Number(savedMinizine)));
        if (minizineToDetectInput) minizineToDetectInput.value = String(minizineToDetectThreshold);
      }
      const savedAdvancedPaint = localStorage.getItem('advancedPaint.enabled');
      advancedPaintEnabled = (savedAdvancedPaint === '1' || savedAdvancedPaint === 'true');
      updateAdvancedPaintUi();
    } catch {}

    if (premiumPaintPixelToggle) premiumPaintPixelToggle.addEventListener('click', () => {
      premiumPaintPixelEnabled = !premiumPaintPixelEnabled;
      try { localStorage.setItem('premiumPaintPixel.enabled', premiumPaintPixelEnabled ? '1' : '0'); } catch {}
      updatePremiumPaintPixelUi();
    });

    if (freePaintPixelToggle) freePaintPixelToggle.addEventListener('click', () => {
      freePaintPixelEnabled = !freePaintPixelEnabled;
      try { localStorage.setItem('freePaintPixel.enabled', freePaintPixelEnabled ? '1' : '0'); } catch {}
      updateFreePaintPixelUi();
    });

    if (brokenPixelPaintToggle) brokenPixelPaintToggle.addEventListener('click', () => {
      brokenPixelPaintEnabled = !brokenPixelPaintEnabled;
      try { localStorage.setItem('brokenPixelPaint.enabled', brokenPixelPaintEnabled ? '1' : '0'); } catch {}
      updateBrokenPixelPaintUi();
    });

    if (priorityColorPaintToggle) priorityColorPaintToggle.addEventListener('click', () => {
      priorityColorPaintEnabled = !priorityColorPaintEnabled;
      try { localStorage.setItem('priorityColorPaint.enabled', priorityColorPaintEnabled ? '1' : '0'); } catch {}
      updatePriorityColorPaintUi();
    });

    if (chessPaintToggle) chessPaintToggle.addEventListener('click', () => {
      chessPaintEnabled = !chessPaintEnabled;
      try { localStorage.setItem('chessPaint.enabled', chessPaintEnabled ? '1' : '0'); } catch {}
      updateChessPaintUi();
    });

    if (limitOverlayToggle) limitOverlayToggle.addEventListener('click', () => {
      limitToOverlayArea = !limitToOverlayArea;
      try { localStorage.setItem('limitOverlay.enabled', limitToOverlayArea ? '1' : '0'); } catch {}
      updateLimitOverlayUi();
      // Render to show/hide range-overlay if it's selected
      render();
      updateRangeOverlayPosition();
    });


    if (minizineToDetectInput) {
      minizineToDetectInput.addEventListener('change', () => {
        let value = parseInt(minizineToDetectInput.value, 10);
        if (isNaN(value) || value < 1) value = 1;
        if (value > 100) value = 100;
        minizineToDetectThreshold = value;
        minizineToDetectInput.value = String(minizineToDetectThreshold);
        try { localStorage.setItem('minizineToDetect.threshold', String(minizineToDetectThreshold)); } catch {}
      });
    }


    if (autoModeTrack) autoModeTrack.addEventListener('click', () => {
      autoMode = !autoMode;
      try { localStorage.setItem('ready.autoMode', autoMode ? '1' : '0'); } catch {}
      updateAutoModeUi();
    });
    if (autoStartTrack) autoStartTrack.addEventListener('click', () => {
      autoStart = !autoStart;
      try { localStorage.setItem('ready.autoStart', autoStart ? '1' : '0'); } catch {}
      updateAutoStartUi();
    });
    if (autoModeLabelLeft) autoModeLabelLeft.addEventListener('click', () => { autoMode = false; try { localStorage.setItem('ready.autoMode','0'); } catch {}; updateAutoModeUi(); });
    if (autoModeLabelRight) autoModeLabelRight.addEventListener('click', () => { autoMode = true; try { localStorage.setItem('ready.autoMode','1'); } catch {}; updateAutoModeUi(); });
    if (autoStartLabelLeft) autoStartLabelLeft.addEventListener('click', () => { autoStart = false; try { localStorage.setItem('ready.autoStart','0'); } catch {}; updateAutoStartUi(); });
    if (autoStartLabelRight) autoStartLabelRight.addEventListener('click', () => { autoStart = true; try { localStorage.setItem('ready.autoStart','1'); } catch {}; updateAutoStartUi(); });
    if (advancedPaintToggle) advancedPaintToggle.addEventListener('click', () => {
      advancedPaintEnabled = !advancedPaintEnabled;
      try { localStorage.setItem('advancedPaint.enabled', advancedPaintEnabled ? '1' : '0'); } catch {}
      updateAdvancedPaintUi();
    });
    if (advancedPaintLabelLeft) advancedPaintLabelLeft.addEventListener('click', () => { advancedPaintEnabled = false; try { localStorage.setItem('advancedPaint.enabled','0'); } catch {}; updateAdvancedPaintUi(); });
    if (advancedPaintLabelRight) advancedPaintLabelRight.addEventListener('click', () => { advancedPaintEnabled = true; try { localStorage.setItem('advancedPaint.enabled','1'); } catch {}; updateAdvancedPaintUi(); });
    if (selectModeTrack) selectModeTrack.addEventListener('click', () => setSelectMode(selectMode === 'frame' ? 'multi' : 'frame'));
    if (selectModeLabelLeft) selectModeLabelLeft.addEventListener('click', () => setSelectMode('multi'));
    if (selectModeLabelRight) selectModeLabelRight.addEventListener('click', () => setSelectMode('frame'));

    function getAccountById(id) {
      const idStr = String(id);
      for (let i = 0; i < accountsData.length; i++) {
        const a = accountsData[i];
        if (String(a.id) === idStr) return a;
      }
      return null;
    }

    function getReadySelectedCount() {
      const sel = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
      const map = getSelectedMap(sel);
      return map ? map.size : 0;
    }

    function getReadySelectionLimit() {
      if (!Array.isArray(readySelectedAccountIds) || readySelectedAccountIds.length === 0) return 0;
      let total = 0;
      for (let i = 0; i < readySelectedAccountIds.length; i++) {
        const a = getAccountById(readySelectedAccountIds[i]);
        if (!a || a.active === false || !a.token) continue;
        const c = Number.isFinite(Number(a.pixelCount)) ? Number(a.pixelCount) : 0;
        total += Math.max(0, Math.floor(c));
      }
      return total;
    }

    function updateReadySelectionLabel() {
      if (!readyPixelEl) return;
      const selected = readyGlobalMode ? readyGlobalSelected.size : getReadySelectedCount();
      const limit = Math.max(0, Number(getReadySelectionLimit()) || 0);
      const count = selected;
      try { readyPixelEl.setAttribute('data-count', String(count)); readyPixelEl.setAttribute('data-max', String(limit)); } catch {}
      readyPixelEl.textContent = t('pixel.powerLabel', { count, max: limit });
      try { updateAutoSelectButtonLabel(); } catch {}
    }

    function updateAutoSelectButtonLabel(){
      if (!autoSelectBtn) return;
      const selected = readyGlobalMode ? readyGlobalSelected.size : getReadySelectedCount();
      const limit = Math.max(0, Number(getReadySelectionLimit()) || 0);
      const shouldDelete = (limit > 0 && selected >= limit);
      autoSelectDeleteMode = !!shouldDelete;
      try {
        autoSelectBtn.textContent = shouldDelete ? t('ready.deleteAllSelected') : t('ready.autoSelect');
      } catch {
        autoSelectBtn.textContent = shouldDelete ? 'Delete all selected' : 'Auto select';
      }
    }

    function updateReadyPixelForSelectedAccounts() {
      updateReadySelectionLabel();
      try { updateStartEnabled(); } catch {}
    }

    function renderReadyAccountList() {
      if (!readyAccountList) return;
      readyAccountList.innerHTML = '';
      // Sort by fill ratio (count/max) desc, then count desc, then max desc
      const sortedRows = [];
      accountsData.forEach(row => {
        const isActive = row && row.active !== false;
        const hasToken = !!(row && row.token);
        if (!isActive || !hasToken) return;
        const count = Number.isFinite(Number(row.pixelCount)) ? Number(row.pixelCount) : 0;
        const max = Number.isFinite(Number(row.pixelMax)) ? Number(row.pixelMax) : 0;
        const ratio = (max > 0 ? (count / max) : -1);
        sortedRows.push({ row, count, max, ratio });
      });
      sortedRows.sort((a, b) => {
        if (b.ratio !== a.ratio) return b.ratio - a.ratio;
        if (b.count !== a.count) return b.count - a.count;
        return b.max - a.max;
      });
      sortedRows.forEach(({ row, count, max }) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'app-btn';
        const isSelected = readySelectedAccountIds.indexOf(row.id) !== -1;
        btn.textContent = (isSelected ? '✓ ' : '') + (row.name || t('ready.accountLabelDefault')) + ' — ' + String(count) + ' / ' + String(max);
        btn.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
        btn.addEventListener('click', () => {
          const isSelectedNow = readySelectedAccountIds.indexOf(row.id) !== -1;
          if (isSelectedNow) {
            readySelectedAccountIds = [];
          } else {
            readySelectedAccountIds = [row.id];
          }
          try { renderReadyAccountList(); } catch {}
          try { if (readyPixelEl) readyPixelEl.hidden = false; } catch {}
          updateReadyPixelForSelectedAccounts();
          try { refreshPaletteTooltips(); } catch {}
        });
        readyAccountList.appendChild(btn);
      });
      try { updateAutoSelectButtonLabel(); } catch {}
    }

    function autoSelectTopAccountsByRatio(){
      try {
        const candidates = Array.isArray(accountsData) ? accountsData.filter(row => {
          const isActive = row && row.active !== false && !!row.token;
          const countRaw = Number(row && row.pixelCount);
          const maxRaw = Number(row && row.pixelMax);
          const valid = Number.isFinite(countRaw) && Number.isFinite(maxRaw) && maxRaw > 0;
          return isActive && valid;
        }).map(row => {
          const count = Math.floor(Number(row.pixelCount));
          const max = Math.floor(Number(row.pixelMax));
          const ratio = (max > 0 ? (count / max) : -1);
          return { id: row.id, ratio, count, max };
        }) : [];
        candidates.sort((a, b) => {
          if (b.ratio !== a.ratio) return b.ratio - a.ratio;
          if (b.count !== a.count) return b.count - a.count;
          return b.max - a.max;
        });
        const top = candidates.slice(0, MAX_READY_ACCOUNTS).map(x => x.id);
        readySelectedAccountIds = top;
        try { renderReadyAccountList(); } catch {}
        try { if (readyPixelEl) readyPixelEl.hidden = false; } catch {}
        updateReadyPixelForSelectedAccounts();
      } catch {}
    }

    function pickNextBestAccountId(excludeIds = []){
      try {
        const excludeSet = new Set((excludeIds||[]).map(x => String(x)));
        const list = [];
        accountsData.forEach(row => {
          const isActive = row && row.active !== false && !!row.token;
          const countRaw = Number(row && row.pixelCount);
          const maxRaw = Number(row && row.pixelMax);
          const valid = Number.isFinite(countRaw) && Number.isFinite(maxRaw) && maxRaw > 0;
          if (!isActive || !valid) return;
          const idStr = String(row.id);
          const ratio = (maxRaw > 0 ? (countRaw / maxRaw) : -1);
          list.push({ id: row.id, idStr, ratio, count: Math.floor(countRaw), max: Math.floor(maxRaw) });
        });
        list.sort((a, b) => {
          if (b.ratio !== a.ratio) return b.ratio - a.ratio;
          if (b.count !== a.count) return b.count - a.count;
          return b.max - a.max;
        });
        for (let i = 0; i < list.length; i++) {
          if (!excludeSet.has(list[i].idStr)) return list[i].id;
        }
        return null;
      } catch { return null; }
    }

    // Single-account mode: we no longer auto-select on open; user picks explicitly.

    if (readyAccountBtn) {
      readyAccountBtn.addEventListener('click', () => {
        try { renderReadyAccountList(); } catch {}
        if (readyAccountList) readyAccountList.hidden = !readyAccountList.hidden;
      });
    }
    if (autoSelectAccountsBtn) {
      autoSelectAccountsBtn.addEventListener('click', async () => {
        try { await loadAccounts(); } catch {}
        autoSelectTopAccountsByRatio();
      });
    }

    function resetReadyNow(){
      try { if (readyPopup) readyPopup.hidden = true; } catch {}
      try {
        if (readyLockedItem) { readyLockedItem.lockedByReady = false; updateItemLockUi(readyLockedItem); readyLockedItem = null; }
      } catch {}
      readySelectedAccountIds = [];
      readyShouldReset = true;
      readyHoverPixel = { x: null, y: null };
      
      // Ensure no stale drag/ready state remains when resetting
      try { readyMouseDownPt = null; } catch {}
      try { readyMouseMoved = false; } catch {}
      try { state.dragging = false; } catch {}
      try { signDragging = false; } catch {}
      try { document.body.classList.remove('dragging'); } catch {}
      
      try {
        if (readyAccountBtn) readyAccountBtn.hidden = true;
        if (readyPixelEl) readyPixelEl.hidden = true;
        if (readyAccountList) readyAccountList.hidden = true;
      } catch {}
      try { updateAutoSelectButtonLabel(); } catch {}
      try { updatePixelMarkers(); } catch {}
      render();
    }
    if (readyBtn && readyPopup) {
      readyBtn.addEventListener('click', async () => {
        try {
          await loadAccounts();
          
          // Clear any leftover drag/ready state before toggling the popup
          try { readyMouseDownPt = null; } catch {}
          try { readyMouseMoved = false; } catch {}
          try { state.dragging = false; } catch {}
          try { signDragging = false; } catch {}
          try { document.body.classList.remove('dragging'); } catch {}
          
          try {
            
            if (readyShouldReset) {
              readyShouldReset = false;
              readySelectedAccountIds = [];
              try { clearAllReadySelections(); } catch {}
              try {
                if (readyAccountBtn) readyAccountBtn.hidden = false;
                if (readyPixelEl) readyPixelEl.hidden = true;
                if (readyAccountList) readyAccountList.hidden = true;
              } catch {}
            }
            // Enforce single account if pre-existing selection had multiple
            if (Array.isArray(readySelectedAccountIds) && readySelectedAccountIds.length > 1) {
              readySelectedAccountIds = [readySelectedAccountIds[0]];
              updateReadyPixelForSelectedAccounts();
            }
            if (readyPixelEl) readyPixelEl.hidden = false;
            if (readyAccountList) readyAccountList.hidden = true;
          } catch {}
          // Always close movement popup when toggling Ready
          try { if (movementPopup) movementPopup.hidden = true; } catch {}
          readyPopup.hidden = !readyPopup.hidden;
          
          try {
            if (!readyPopup.hidden) {
              
              readyGlobalMode = !((selectedIndex >= 0 && selectedIndex < signItems.length)) && (selectedOverrideColorId != null);
              if (selectedIndex >= 0 && selectedIndex < signItems.length) {
                const it = signItems[selectedIndex];
                it.lockedByReady = true;
                readyLockedItem = it;
                try { updateItemLockUi(it); } catch {}
                
                readyHoverPixel = { x: null, y: null };
                ensureRenderedSelectedForItem(it);
                updatePixelMarkers();
                updateReadySelectionLabel();
              } else if (readyGlobalMode) {
                
                try { clearAllReadySelections(); } catch {}
                readyHoverPixel = { x: null, y: null };
                updatePixelMarkers();
                updateReadySelectionLabel();
              }
            } else {
              readyGlobalMode = false;
              if (readyLockedItem) {
                readyLockedItem.lockedByReady = false;
                try { updateItemLockUi(readyLockedItem); } catch {}
                readyLockedItem = null;
              }
              
              try { pixelHoverEl.hidden = true; if (pixelSelectedList) pixelSelectedList.hidden = true; } catch {}
              
              try { if (readyAccountList) readyAccountList.hidden = true; } catch {}
            }
          } catch {}
          try { updateAutoSelectButtonLabel(); } catch {}
          render();
        } catch {}
      });
    }
    if (autoSelectBtn) {
      autoSelectBtn.addEventListener('click', () => {
        if (autoSelectDeleteMode) {
          // Delete all selected pixels
          if (readyGlobalMode) {
            try {
              readyGlobalSelected.forEach(rec => {
                try { if (rec && rec.el && rec.el.parentNode) rec.el.parentNode.removeChild(rec.el); } catch {}
                try { if (rec && rec.fillEl && rec.fillEl.parentNode) rec.fillEl.parentNode.removeChild(rec.fillEl); } catch {}
              });
              readyGlobalSelected.clear();
            } catch {}
          } else {
            const selItem = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
            if (selItem) {
              try { clearSelectionsForItem(selItem); } catch {}
            }
          }
          try { updateReadySelectionLabel(); updateStartEnabled(); updatePixelMarkers(); render(); } catch {}
          try { refreshPaletteTooltips(); } catch {}
          return;
        }

        // Force auto-select to act as Transparent (no override color)
        selectedOverrideColorId = null;
        try { updatePaletteSelectionUi(); } catch {}

        if (!Array.isArray(readySelectedAccountIds) || readySelectedAccountIds.length === 0) {
          showToast(t('messages.selectAccountFirst'), 'error', 2000);
          return;
        }
        
        if (!(selectedIndex >= 0 && selectedIndex < signItems.length)) {
          if (signItems.length > 0) selectSign(0, false); 
        }
        const selItem = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
        if (!selItem || !selItem.image || !selItem.image.complete) return;
      
        const limit = Math.max(0, Number(getReadySelectionLimit()) || 0);
        const map = getSelectedMap(selItem);
        const already = map ? map.size : 0;
        if (already >= limit) return;
        const start = (selItem._lastManualSelected && Number.isFinite(selItem._lastManualSelected.x) && Number.isFinite(selItem._lastManualSelected.y))
          ? { x: selItem._lastManualSelected.x, y: selItem._lastManualSelected.y }
          : { x: 0, y: 0 };
        const w = selItem.image.naturalWidth|0;
        const h = selItem.image.naturalHeight|0;
        const need = limit - already;
        let addedCount = 0;
        
        if (selectMode === 'frame') {
          const prev = autoSelectDeleteMode; // unused placeholder
          addedCount = autoSelectFrameFirst(selItem, need);
        } else {
        let sx = start.x|0, sy = start.y|0;
        const totalCells = w * h;
        let traversed = 0;
        while (addedCount < need && traversed < totalCells) {
          // Apply Chess Pattern Paint logic
          if (chessPaintEnabled && ((sx + sy) % 2 !== 0)) { // Skip if not on a "black" square
              // Move to the next pixel in the current scanline without adding
              sx += 1;
              if (sx >= w) { sx = 0; sy += 1; }
              if (sy >= h) { sy = 0; }
              traversed++;
              continue; // Skip to the next iteration
          }

          // Apply Limit to Overlay Area logic
          if (limitToOverlayArea && selectedOverlayIndex !== -1 && savedOverlays[selectedOverlayIndex] && savedOverlays[selectedOverlayIndex].isVisible) {
              const overlayRect = savedOverlays[selectedOverlayIndex].rect;
              const wx = Math.round((selItem.worldX || 0) + sx);
              const wy = Math.round((selItem.worldY || 0) + sy);
              if (wx < overlayRect.x || wx >= (overlayRect.x + overlayRect.w) ||
                  wy < overlayRect.y || wy >= (overlayRect.y + overlayRect.h)) {
                  // Move to the next pixel if outside the overlay area
                  sx += 1;
                  if (sx >= w) { sx = 0; sy += 1; }
                  if (sy >= h) { sy = 0; }
                  traversed++;
                  continue; // Skip to the next iteration
              }
          }

/*          // Check if pixel is opaque and needs painting (color differs from base or override color is set)
            if (isOpaquePixel(selItem, p.x, p.y)) {
                let colorDiffers = true;
                if (selectedOverrideColorId != null) {
                    const overrideRgb = getPaletteRgbById(selectedOverrideColorId);
                    const worldX = Math.round((selItem.worldX || 0) + p.x);
                    const worldY = Math.round((selItem.worldY || 0) + p.y);
                    const currentWorldColor = getCompositeColorAtWorld(worldX, worldY);

                    if (selectedOverrideColorId !== 0 && overrideRgb && currentWorldColor &&
                        currentWorldColor.r === overrideRgb[0] &&
                        currentWorldColor.g === overrideRgb[1] &&
                        currentWorldColor.b === overrideRgb[2] &&
                        currentWorldColor.a > 0) {
                        colorDiffers = false;
                    } else if (selectedOverrideColorId === 0 && (!currentWorldColor || currentWorldColor.a === 0)) {
                        colorDiffers = false;
                    }
                } else {
                    colorDiffers = !isSamePaletteIdAsBase(selItem, p.x, p.y);
                }

                if (colorDiffers) { */
          // Tính toán isActuallyBroken và isCurrentPixelMatched cho pixel hiện tại
          const targetPixelColorId = getItemPixelPaletteId(selItem, sx, sy);
          const currentWorldX = Math.round((selItem.worldX || 0) + sx); // World X cho tính toán
          const currentWorldY = Math.round((selItem.worldY || 0) + sy); // World Y cho tính toán
          const worldPixelColor = getCompositeColorAtWorld(currentWorldX, currentWorldY);
          const worldPixelColorId = worldPixelColor ? rgbToPaletteId(worldPixelColor.r, worldPixelColor.g, worldPixelColor.b) : null;

          const isPixelOpaqueInSign = isOpaquePixel(selItem, sx, sy);
          const isCurrentPixelMatched = isPixelOpaqueInSign && (worldPixelColorId === targetPixelColorId) && (worldPixelColor && worldPixelColor.a > 0);
          
          const targetRgb = getPaletteRgbById(targetPixelColorId);
          const currentRgb = worldPixelColor ? [worldPixelColor.r, worldPixelColor.g, worldPixelColor.b] : null;

          const isActuallyBroken = isPixelOpaqueInSign && targetRgb && currentRgb &&
              areColorsSignificantlyDifferent(
                  {r: targetRgb[0], g: targetRgb[1], b: targetRgb[2]},
                  {r: currentRgb[0], g: currentRgb[1], b: currentRgb[2]},
                  COLOR_DIFFERENCE_THRESHOLD
              );

          if (isPixelOpaqueInSign && (selectedOverrideColorId != null || !isSamePaletteIdAsBase(selItem, sx, sy))) {
            const pid = (selectedOverrideColorId != null && selectedOverrideColorId !== 0)
              ? selectedOverrideColorId
              : getItemPixelPaletteId(selItem, sx, sy);
                    
            if (pid != null && pid !== 0 && isPremiumColorId(pid)){
              const remainNow = getPremiumColorRemainingLimit(pid);
              if (remainNow > 0) {
                const didAdd = addPixelSelection(selItem, sx, sy, selectedOverrideColorId != null ? selectedOverrideColorId : null, isActuallyBroken, isCurrentPixelMatched);
                if (didAdd) addedCount++;
              }
            } else {
              const didAdd = addPixelSelection(selItem, sx, sy, selectedOverrideColorId != null ? selectedOverrideColorId : null, isActuallyBroken, isCurrentPixelMatched);
              if (didAdd) addedCount++;
            }
          }
          sx += 1;
          if (sx >= w) { sx = 0; sy += 1; }
          if (sy >= h) { sy = 0; }
          traversed++;
          }
        }
        updateReadySelectionLabel();
        updatePixelMarkers();
        render();
        try { updateStartEnabled(); } catch {}
        try { refreshPaletteTooltips(); } catch {}
      });
    }

    function autoSelectFrameFirst(selItem, need){
      if (!selItem || !selItem.image) return 0;
      const w = selItem.image.naturalWidth|0;
      const h = selItem.image.naturalHeight|0;
      if (!(w && h)) return 0;

      let minX = 0, minY = 0, maxX = w, maxY = h;
      if (limitToOverlayArea && selectedOverlayIndex !== -1 && savedOverlays[selectedOverlayIndex] && savedOverlays[selectedOverlayIndex].isVisible) {
          const overlayRect = savedOverlays[selectedOverlayIndex].rect;
          // Convert overlay world coordinates to item-local coordinates
          minX = Math.max(0, overlayRect.x - (selItem.worldX || 0));
          minY = Math.max(0, overlayRect.y - (selItem.worldY || 0));
          maxX = Math.min(w, overlayRect.x + overlayRect.w - (selItem.worldX || 0));
          maxY = Math.min(h, overlayRect.y + overlayRect.h - (selItem.worldY || 0));
      }

      const size = w * h;
      const idxOf = (x, y) => y * w + x;
      const mask = new Uint8Array(size);
      for (let y = minY; y < maxY; y++) {
        for (let x = minX; x < maxX; x++) {
          if (isOpaquePixel(selItem, x, y)) {
            mask[idxOf(x,y)] = 1;
          }
        }
      }
      const layer = new Int32Array(size);
      for (let i = 0; i < size; i++) layer[i] = -1;
      const qx = new Int32Array(size);
      const qy = new Int32Array(size);
      let qh = 0, qt = 0;
      function push(x, y, l){
        const i = idxOf(x,y);
        layer[i] = l;
        qx[qt] = x; qy[qt] = y; qt++;
      }
      for (let y = minY; y < maxY; y++) {
        for (let x = minX; x < maxX; x++) {
          const i = idxOf(x,y);
          if (!mask[i]) continue;
          if (x === minX || x === maxX-1 || y === minY || y === maxY-1 ||
              !mask[idxOf(x-1,y)] || !mask[idxOf(x+1,y)] ||
              !mask[idxOf(x,y-1)] || !mask[idxOf(x,y+1)]) {
            push(x, y, 0);
          }
        }
      }
      while (qh < qt) {
        const x = qx[qh];
        const y = qy[qh];
        const l = layer[idxOf(x,y)];
        qh++;
        const nl = l + 1;
        if (x > minX) {
          const i = idxOf(x-1,y);
          if (mask[i] && layer[i] === -1) push(x-1, y, nl);
        }
        if (x < maxX-1) {
          const i = idxOf(x+1,y);
          if (mask[i] && layer[i] === -1) push(x+1, y, nl);
        }
        if (y > minY) {
          const i = idxOf(x,y-1);
          if (mask[i] && layer[i] === -1) push(x, y-1, nl);
        }
        if (y < maxY-1) {
          const i = idxOf(x,y+1);
          if (mask[i] && layer[i] === -1) push(x, y+1, nl);
        }
      }
      const buckets = [];
      for (let i = 0; i < size; i++) {
        const l = layer[i];
        if (l >= 0) {
          if (!buckets[l]) buckets[l] = [];
          buckets[l].push({ x: i % w, y: (i / w) | 0 });
        }
      }
      const order = [];
      for (let i = 0; i < buckets.length; i++) {
        const b = buckets[i];
        if (b) for (let j = 0; j < b.length; j++) order.push(b[j]);
      }
      const map = getSelectedMap(selItem);
      let added = 0;
      for (let i = 0; i < order.length && added < need; i++) {
        const p = order[i];
        // Only consider pixels within the selected overlay's bounds
        if (p.x < minX || p.x >= maxX || p.y < minY || p.y >= maxY) continue;

        // Apply Chess Pattern Paint logic
        if (chessPaintEnabled && ((p.x + p.y) % 2 !== 0)) { // Skip if not on a "black" square
            continue;
        }

        if (map && map.has(keyFor(p.x, p.y))) continue;
        if (selectedOverrideColorId == null && isSamePaletteIdAsBase(selItem, p.x, p.y)) continue;
        if (selectedOverrideColorId != null && selectedOverrideColorId !== 0 && isPremiumColorId(selectedOverrideColorId)) {
          const remain = getPremiumColorRemainingLimit(selectedOverrideColorId);
          if (!(remain > 0)) break;
        }
        const did = addPixelSelection(selItem, p.x, p.y, selectedOverrideColorId != null ? selectedOverrideColorId : null);
        if (did) added++;
      }
      return added;
    }
    function getSelectedAccountsSortedByCapacityDesc() {
      const rows = [];
      for (let i = 0; i < readySelectedAccountIds.length; i++) {
        const a = getAccountById(readySelectedAccountIds[i]);
        if (a && typeof a.token === 'string' && a.token && a.active !== false) rows.push(a);
      }
      rows.sort((a, b) => (Number(b.pixelCount)||0) - (Number(a.pixelCount)||0));
      return rows;
    }

    async function postBatch(area, no, colors, coords, t, jToken) {
      try {
        const res = await fetch('/api/pixel/' + encodeURIComponent(area) + '/' + encodeURIComponent(no), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ colors, coords, t, j: jToken })
        });
        const text = await res.text();
        let payload = null;
        try { payload = JSON.parse(text); } catch {}
        
        return { ok: res.status < 500 && !!(payload && Object.prototype.hasOwnProperty.call(payload, 'painted')), payload, text, status: res.status };
      } catch (e) {
        return { ok: false, error: e && e.message ? e.message : String(e) };
      }
    }

    function updateStartEnabled() {
      try {
        if (!startBtn) return;
        const hasToken = !!(readyTokenInput && readyTokenInput.value && readyTokenInput.value.trim().length > 0);
        const hasAccounts = getSelectedAccountsSortedByCapacityDesc().length > 0;
        const hasAnyPixel = readyGlobalMode ? (readyGlobalSelected.size > 0) : (getReadySelectedCount() > 0);
        startBtn.disabled = !(hasToken && hasAccounts && hasAnyPixel);
      } catch {}
    }
    function updateEraserButtonUi() {
        isEraserMode = (selectedOverrideColorId === -1); // Tính toán isEraserMode động
        if (eraserButton) {
            eraserButton.classList.toggle('active', isEraserMode);
        }
        // Đảm bảo nút transparent trong palette cũng được highlight khi ở chế độ tẩy
        const transparentSwatch = colorPaletteEl.querySelector('.palette-swatch.transparent');
        if (transparentSwatch) {
            transparentSwatch.classList.toggle('selected', isEraserMode);
        }
        // Đảm bảo không có màu nào khác được chọn khi ở chế độ tẩy
        if (isEraserMode) {
             const swatches = Array.from(colorPaletteEl.querySelectorAll('.palette-swatch:not(.transparent)'));
             swatches.forEach(sw => sw.classList.remove('selected'));
        }
    }

    function groupPixelsByTile(colors, coords) {
      const tileWidth = currentTileW || (img ? img.width : 0);
      const tileHeight = currentTileH || (img ? img.height : 0);
      const cols = currentMosaicCols || 1;
      const map = new Map();
      for (let i = 0; i < colors.length; i++) {
        const wx = coords[i * 2];
        const wy = coords[i * 2 + 1];
        const col = Math.floor(wx / tileWidth);
        const row = Math.floor(wy / tileHeight);
        const index = row * cols + col;
        const tile = currentTiles[index] || currentTiles[0] || { x: 0, y: 0 };
        const localX = wx - col * tileWidth;
        const localY = wy - row * tileHeight;
        const key = tile.x + ',' + tile.y;
        let g = map.get(key);
        if (!g) {
          g = { area: tile.x, no: tile.y, coords: [], colors: [] };
          map.set(key, g);
        }
        g.coords.push(localX, localY);
        g.colors.push(colors[i]);
      }
      return Array.from(map.values());
    }

if (startBtn) {
  startBtn.addEventListener('click', () => {
    console.log("Start button clicked, initiating paint process.");

    const hasToken = !!(readyTokenInput && readyTokenInput.value && readyTokenInput.value.trim().length > 0);
    const hasAccounts = getSelectedAccountsSortedByCapacityDesc().length > 0;
    const hasAnyPixel = readyGlobalMode ? (readyGlobalSelected.size > 0) : (getReadySelectedCount() > 0);
    if (!(hasToken && hasAccounts && hasAnyPixel)) {
      try {
        showToast(t('messages.startRequirementsMissing'), 'error', 2500);
      } catch (e) { console.error('Error calling showToast:', e); }
      try { updateStartEnabled(); } catch {}
      return;
    }
    const sel = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
    if (!readyGlobalMode && !sel) {
      try {
        showToast(t('messages.noSelectedImage'), 'error', 2000);
      } catch (e) { console.error('Error calling showToast:', e); }
      return;
    }
    const data = buildSelectedExportForItem(sel);
    // Gọi hàm báo cáo mới ngay sau khi data được tạo
    try {
      getRemainingPaintablePixelSummary(data.filteredPixels); // Truyền filteredPixels để phân tích
    } catch (e) { console.error('Error calling getRemainingPaintablePixelSummary:', e); }

    const authToken = (readyTokenInput && readyTokenInput.value) ? String(readyTokenInput.value) : '';

  //const pixelsToPaint = dataExport.filteredPixels; // Use the already sorted and filtered pixels

    // Her durumda (tek tile veya değil) pikselleri world koordinata göre area/no bazında gruplandır
  const groups = (function(){
    try {
      const w = img ? (img.width|0) : 0, h = img ? (img.height|0) : 0;
      const base = getCurrentTileCoords();
      const m = new Map();
      for (let i = 0; i < data.colors.length; i++) {
        const wx = data.coords[i*2]|0;
        const wy = data.coords[i*2+1]|0;
        const col = Math.floor(wx / Math.max(1, w));
        const row = Math.floor(wy / Math.max(1, h));
        const area = Number(base.x||0) + col;
        const no = Number(base.y||0) + row;
        let lx = wx - col * w;
        let ly = wy - row * h;
        // Clamp just in case of rounding anomalies at tile seams
        if (w > 0) { if (lx < 0) lx = 0; else if (lx >= w) lx = w - 1; }
        if (h > 0) { if (ly < 0) ly = 0; else if (ly >= h) ly = h - 1; }
        const key = String(area)+","+String(no);
        let g = m.get(key);
        if (!g) { g = { area, no, coords: [], colors: [] }; m.set(key, g); }
        g.coords.push(lx, ly);
        g.colors.push(data.colors[i]);
      }
        return Array.from(m.values());
    } catch { return [{ area: (areaInput && areaInput.value) ? Number(areaInput.value) : 0, no: (noInput && noInput.value) ? Number(noInput.value) : 0, colors: data.colors.slice(), coords: data.coords.slice() }]; }
    })();

    (async () => {
      isPainting = true;
      clearTimeout(refreshTimer);
      const tileW = currentTileW || (img ? (img.width|0) : 0);
      const tileH = currentTileH || (img ? (img.height|0) : 0);
      const baseTile = getCurrentTileCoords();
      try {
        // If selected image crosses into neighbors, ensure overlays are loaded before grouping
        try { if (!readyGlobalMode && sel) await ensureOverlaysForItemLoaded(sel); } catch {}
        let paintedAny = false;
        let missingTotal = 0;
        let usedIds = [];
        let hadRequestError = false;
        let didReload = false;
        for (const g of groups) {
          const total = g.colors.length | 0;
          const selectedAccounts = getSelectedAccountsSortedByCapacityDesc();
          let offset = 0;
          for (let i = 0; i < selectedAccounts.length && offset < total; i++) {
            const acc = selectedAccounts[i];
            const cap = Math.max(0, Math.floor(Number(acc.pixelCount) || 0));
            if (cap <= 0) continue;
            const take = Math.min(cap, total - offset);
            if (take <= 0) continue;
            const colorsSlice = g.colors.slice(offset, offset + take);
            const coordsSlice = g.coords.slice(offset * 2, (offset + take) * 2);
            const r = await postBatch(String(g.area), String(g.no), colorsSlice, coordsSlice, authToken, String(acc.token || ''));
            if (r && r.status === 429) {
              hadRequestError = true;
              try { showToast(t('messages.cfClearanceChange'), 'error', 3500); } catch { showToast('Please change cf_clearance.', 'error', 3500); }
              break;
            }
            if (!r.ok) {
              if (r.status >= 500) {
                try { await loadAccounts(); } catch {}
                continue;
              } else {
                hadRequestError = true;
                showToast(r.payload ? JSON.stringify(r.payload) : (r.text || r.error || t('messages.errorGeneric')), 'error', 3000);
                break;
              }
            } else {
              addRecentPaintBatch(g, coordsSlice, colorsSlice, tileW, tileH, baseTile);
            }
            offset += take;
            usedIds.push(acc.id);
            try { await refreshAccountById(acc.id); } catch {}
          }
          if (offset > 0) paintedAny = true;
          if (offset < total && !hadRequestError) missingTotal += (total - offset);
        }
        if (paintedAny) {
          showToast(t('messages.painted'), 'success', 1800);
          try { clearAllReadySelections(); } catch {}
          try { readyGlobalMode = false; } catch {}
          if (!autoMode) {
            try { resetReadyNow(); } catch {}
          }
          try { updateStartEnabled(); } catch {}
        }
        if (missingTotal > 0) {
          showToast(t('messages.insufficientPixelPower', { n: missingTotal }), 'error', 3000);
        }
        try { await loadAccounts(); } catch {}
        try { updateReadySelectionLabel(); } catch {}
        render();
        // Auto mode: después de pintar, selecciona la siguiente cuenta y auto selecciona píxeles
        if (autoMode && paintedAny && !hadRequestError) {
          try {
            await loadAccounts();
            try { renderReadyAccountList(); } catch {}
            updateReadyPixelForSelectedAccounts();
            const nextId = pickNextBestAccountId(usedIds);
            if (nextId != null) {
              readySelectedAccountIds = [nextId];
              try { renderReadyAccountList(); } catch {}
              updateReadyPixelForSelectedAccounts();
              try { await new Promise(resolve => setTimeout(resolve, didReload ? 50 : 300)); } catch {}
              if (autoSelectBtn) { autoSelectDeleteMode = false; autoSelectBtn.click(); }
            }
          } catch {}
        }
      } finally {
        isPainting = false;
        scheduleBackgroundRefresh();
      }
    })();
/* else {
      // Si no hay mosaico, usa la lógica de xacter (asignación individual)
      const area = (areaInput && areaInput.value) ? String(areaInput.value).trim() : '';
      const no = (noInput && noInput.value) ? String(noInput.value).trim() : '';
      const total = data.colors.length|0;
      const selectedAccounts = getSelectedAccountsSortedByCapacityDesc();
      const tasks = [];
      for (let i = 0; i < data.colors.length; i++) {
        const c = data.colors[i];
        const x = data.coords[i * 2];
        const y = data.coords[i * 2 + 1];
        tasks.push({ c, x, y });
      }
      const assigned = new Array(tasks.length).fill(false);
      (async () => {
        let assignedCount = 0;
        const usedIds = [];
        let hadRequestError = false;
        let didReload = false;
        for (let i = 0; i < selectedAccounts.length && assignedCount < total; i++) {
          const acc = selectedAccounts[i];
          const cap = Math.max(0, Math.floor(Number(acc.pixelCount) || 0));
          if (cap <= 0) continue;
          const colorsSlice = [];
          const coordsSlice = [];
          for (let j = 0; j < tasks.length && colorsSlice.length < cap; j++) {
            if (assigned[j]) continue;
            const tsk = tasks[j];
            let ok = true;
            if (tsk.c != null && tsk.c !== 0 && isPremiumColorId(tsk.c)) {
              const idx = Number(tsk.c) - 32;
              const mask = idx >= 0 ? (1 << idx) : 0;
              const bm = Number(acc.extraColorsBitmap || 0);
              ok = (mask !== 0) && ((bm & mask) !== 0);
            }
            if (!ok) continue;
            colorsSlice.push(tsk.c);
            coordsSlice.push(tsk.x, tsk.y);
            assigned[j] = true;
          }
          if (colorsSlice.length === 0) continue;
          const r = await postBatch(area, no, colorsSlice, coordsSlice, authToken, String(acc.token || ''));
          if (r && r.status === 429) {
            hadRequestError = true;
            try { showToast(t('messages.cfClearanceChange'), 'error', 3500); } catch { showToast('Please change cf_clearance.', 'error', 3500); }
            break;
          }
          if (!r.ok) {
            if (r.status >= 500) {
              try { await loadAccounts(); } catch {}
              continue;
            } else {
              hadRequestError = true;
              showToast(r.payload ? JSON.stringify(r.payload) : (r.text || r.error || t('messages.errorGeneric')), 'error', 3000);
              break;
            }
          }
          usedIds.push(acc.id);
          assignedCount += colorsSlice.length;
          try { await refreshAccountById(acc.id); } catch {}
        }
        if (assignedCount > 0) {
          showToast(t('messages.painted'), 'success', 1800);
          try { clearAllReadySelections(); } catch {}
          try { readyGlobalMode = false; } catch {}
          if (!autoMode) {
            try { resetReadyNow(); } catch {}
          }
          try { updateStartEnabled(); } catch {}
        }
        if (assignedCount < total && !hadRequestError) {
          showToast(t('messages.insufficientPixelPower', { n: (total - assignedCount) }), 'error', 3000);
        }
        try { await loadAccounts(); } catch {}
        try { updateReadySelectionLabel(); } catch {}
        render();
        // Auto mode: después de pintar, selecciona la siguiente cuenta y auto selecciona píxeles
if (autoMode && assignedCount > 0 && !hadRequestError) {
  try {
    await loadAccounts();
    try { renderReadyAccountList(); } catch {}
    updateReadyPixelForSelectedAccounts();
    const nextId = pickNextBestAccountId(usedIds);
    if (nextId != null) {
      readySelectedAccountIds = [nextId];
      try { renderReadyAccountList(); } catch {}
      updateReadyPixelForSelectedAccounts();
      try { await new Promise(resolve => setTimeout(resolve, didReload ? 50 : 300)); } catch {}
      if (autoSelectBtn) { autoSelectDeleteMode = false; autoSelectBtn.click(); }
    }
  } catch {}
}
      })();
    } */
  });
}

    // Periodically refresh base tile and all unlocked overlays (neighborOverlays)
    const MAP_REFRESH_PERIOD_MS = 60000;
    function refreshBaseTilePreserveView(){
      try {
        if (!img) return;
        const base = getCurrentTileCoords();
        const url = buildUrl(base.x, base.y) + '?t=' + Date.now();
        const next = new Image();
        next.onload = () => {
          img = next;
          try { baseImageData = null; } catch {}
          try { currentTiles = [{ x: Number(base.x), y: Number(base.y) }]; } catch {}
          try { currentTileW = next.width; currentTileH = next.height; } catch {}
          render();
          try { updatePixelMarkers(); } catch {}
        };
        next.onerror = () => {};
        next.src = url;
      } catch {}
    }
    function refreshAllUnlockedOverlays(){
      try {
        if (!neighborOverlays || neighborOverlays.size === 0) return;
        neighborOverlays.forEach((ov, key) => {
          try {
            if (!ov || ov.col == null || ov.row == null || ov.area == null || ov.no == null) return;
            const imgEl = new Image();
            imgEl.onload = () => {
              try { neighborOverlays.set(key, { ...ov, image: imgEl }); } catch {}
              overlayVersion++;
              render();
              try { saveOverlaysToStorage(); } catch {}
            };
            imgEl.onerror = () => {};
            imgEl.src = buildUrl(ov.area, ov.no) + '?t=' + Date.now();
          } catch {}
        });
      } catch {}
    }
    function startMapAutoRefresh(){
      try {
        if (window._mapRefreshTimer) return;
        window._mapRefreshTimer = setInterval(() => {
          try { refreshBaseTilePreserveView(); } catch {}
          try { refreshAllUnlockedOverlays(); } catch {}
        }, MAP_REFRESH_PERIOD_MS);
      } catch {}
    }
    try { startMapAutoRefresh(); } catch {}

    // Space-to-paint: press/hold Space to add selection at hover pixel (like left-click)
    let spacePaintHeld = false;
    let spacePaintLastKey = null;
    let spacePaintLimitWarned = false;
    let spacePaintAccountWarned = false;

    function showMaxReachedToastOnceForSpace(limit){
      if (spacePaintHeld) {
        if (spacePaintLimitWarned) return;
        spacePaintLimitWarned = true;
      }
      showToast(t('messages.maxPixelsReached', { limit }), 'error', 2000);
    }

    function maybeAddSelectionAtHover(){
      if (!isReadyOpen()) return false;
      if (!readyHoverPixel || readyHoverPixel.x == null || readyHoverPixel.y == null) return false;
      if (!img) return false;
      if (readyGlobalMode) {
        const hasAccounts = Array.isArray(readySelectedAccountIds) && readySelectedAccountIds.length > 0;
        if (!hasAccounts) {
          if (spacePaintHeld) {
            if (!spacePaintAccountWarned) { showToast(t('messages.selectAccountFirst'), 'error', 2000); spacePaintAccountWarned = true; }
          } else {
            showToast(t('messages.selectAccountFirst'), 'error', 2000);
          }
          return false;
        }
        const wx = readyHoverPixel.x|0;
        const wy = readyHoverPixel.y|0;
        if (wx < 0 || wy < 0 || wx >= img.width || wy >= img.height) return false;
        const limit = Math.max(0, Number(getReadySelectionLimit()) || 0);
        if (limit > 0 && readyGlobalSelected.size >= limit) { showMaxReachedToastOnceForSpace(limit); return false; }
        const key = String(wx) + ',' + String(wy);
        if (readyGlobalSelected.has(key)) return false;
        const rec = { wx, wy, el: null, fillEl: null, colorId: selectedOverrideColorId };
        // Enforce premium capacity both for override color and base pixel color
        let checkColorId = null;
        if (selectedOverrideColorId != null && selectedOverrideColorId !== 0) {
          checkColorId = selectedOverrideColorId;
        } else {
          const base = getBasePixelColorAtWorld(wx, wy);
          if (base && base.a !== 0) {
            try { checkColorId = rgbToPaletteId(base.r, base.g, base.b); } catch { checkColorId = null; }
          }
        }
        if (checkColorId != null && isPremiumColorId(checkColorId)){
          const remain = getPremiumColorRemainingLimit(checkColorId);
          if (!(remain > 0)) { showMaxReachedToastOnceForSpace(remain || 0); return false; }
        }
        if (selectedOverrideColorId != null) {
          const f = document.createElement('img'); f.className = 'pixel-marker'; f.alt = 'fill';
          try {}
          catch {}
        }
        readyGlobalSelected.set(key, rec);
        if (pixelSelectedList) pixelSelectedList.hidden = false;
        try { updateReadySelectionLabel(); updateStartEnabled(); } catch {}
        try { refreshPaletteTooltips(); } catch {}
        drawSelectionOverlay();
        return true;
      } else {
        const selItem = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
        if (!selItem || !selItem.image || !selItem.image.complete) return false;
        const lx = readyHoverPixel.x|0;
        const ly = readyHoverPixel.y|0;
        if (lx < 0 || ly < 0 || lx >= selItem.image.naturalWidth || ly >= selItem.image.naturalHeight) return false;
        // Trì hoãn tính toán chính xác: sử dụng so sánh RGB đơn giản cho kiểm tra nhanh tạm thời
        // Duy trì isOpaquePixel để kiểm tra xem pixel có trong suốt hay không
        if (!isOpaquePixel(selItem, lx, ly)) return false;
        
        let colorDiffers = true;
        // Nếu có màu override được chọn
        if (selectedOverrideColorId != null) {
            const overrideRgb = getPaletteRgbById(selectedOverrideColorId);
            const worldX = Math.round((selItem.worldX || 0) + lx);
            const worldY = Math.round((selItem.worldY || 0) + ly);
            const currentWorldColor = getCompositeColorAtWorld(worldX, worldY);

            // Kiểm tra nếu màu override (không trong suốt) trùng với màu hiện tại trên bản đồ
            if (selectedOverrideColorId !== 0 && overrideRgb && currentWorldColor &&
                currentWorldColor.r === overrideRgb[0] &&
                currentWorldColor.g === overrideRgb[1] &&
                currentWorldColor.b === overrideRgb[2] &&
                currentWorldColor.a > 0) {
                colorDiffers = false;
            } else if (selectedOverrideColorId === 0 && (!currentWorldColor || currentWorldColor.a === 0)) {
                // Nếu override là trong suốt (ID 0) và pixel trên bản đồ cũng trong suốt
                colorDiffers = false;
            }
        } else {
            // Nếu không có màu override, so sánh trực tiếp màu của ảnh với màu trên bản đồ
            colorDiffers = !isSamePaletteIdAsBase(selItem, lx, ly);
        }

        if (!colorDiffers) return false;

        // Kiểm tra điều kiện sớm: giới hạn pixel
        const limit = Math.max(0, Number(getReadySelectionLimit()) || 0);
        const map = getSelectedMap(selItem);
        const already = map ? map.size : 0;
        if (limit > 0 && already >= limit) { showMaxReachedToastOnceForSpace(limit); return false; }
        
        // Xác định colorId hiệu quả cho việc kiểm tra dung lượng (override hoặc màu pixel thực tế)
        let checkColorId = null;
        if (selectedOverrideColorId != null && selectedOverrideColorId !== 0) {
          checkColorId = selectedOverrideColorId;
        } else {
          // Tính toán getItemPixelPaletteId chỉ khi cần thiết
          try { checkColorId = getItemPixelPaletteId(selItem, lx, ly); } catch { checkColorId = null; }
        }
        
        // Kiểm tra điều kiện sớm: dung lượng premium color
        if (checkColorId != null && isPremiumColorId(checkColorId)){
          const remain = getPremiumColorRemainingLimit(checkColorId);
          if (!(remain > 0)) { showMaxReachedToastOnceForSpace(remain || 0); return false; }
        }
        
        // Thêm pixel vào lựa chọn (sử dụng addPixelSelection hiện có)
        const didAdd = addPixelSelection(selItem, lx, ly, selectedOverrideColorId != null ? selectedOverrideColorId : null);
        if (didAdd) {
          try { updateReadySelectionLabel(); updateStartEnabled(); updatePixelMarkers(); render(); } catch {}
          try { refreshPaletteTooltips(); } catch {}
          return true;
        }
        return false;
      }
    }

    function maybeRemoveSelectionAtHover(){
      if (!isReadyOpen()) return false;
      if (!readyHoverPixel || readyHoverPixel.x == null || readyHoverPixel.y == null) return false;
      if (!img) return false;
      if (readyGlobalMode) {
        const wx = readyHoverPixel.x|0;
        const wy = readyHoverPixel.y|0;
        if (wx < 0 || wy < 0 || wx >= img.width || wy >= img.height) return false;
        const key = String(wx) + ',' + String(wy);
        if (!readyGlobalSelected.has(key)) return false;
        const rec = readyGlobalSelected.get(key);
        readyGlobalSelected.delete(key);
        try { updateReadySelectionLabel(); updateStartEnabled(); } catch {}
        try { refreshPaletteTooltips(); } catch {}
        drawSelectionOverlay();
        return true;
      } else {
        const selItem = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
        if (!selItem || !selItem.image || !selItem.image.complete) return false;
        const lx = readyHoverPixel.x|0;
        const ly = readyHoverPixel.y|0;
        if (lx < 0 || ly < 0 || lx >= selItem.image.naturalWidth || ly >= selItem.image.naturalHeight) return false;
        const removed = removePixelSelection(selItem, lx, ly);
        if (removed) {
          try { updateReadySelectionLabel(); updateStartEnabled(); updatePixelMarkers(); render(); } catch {}
          return true;
        }
        return false;
      }
    }
    function isTypingTarget(target){
      const tag = (target && target.tagName) ? target.tagName.toLowerCase() : '';
      return tag === 'input' || tag === 'textarea' || tag === 'select' || (target && target.isContentEditable);
    }
    function currentHoverKey(){
      if (!readyHoverPixel || readyHoverPixel.x == null || readyHoverPixel.y == null) return null;
      return (readyGlobalMode ? 'g:' : 'l:') + String(readyHoverPixel.x) + ',' + String(readyHoverPixel.y);
    }
    window.addEventListener('keydown', (e) => {
      const key = e.code || e.key || '';
      if (key !== 'Space' && key !== ' ') return;
      if (!isReadyOpen() || isTypingTarget(e.target)) return;
      if (spacePaintHeld) { try { e.preventDefault(); e.stopPropagation(); } catch {} return; }
      spacePaintHeld = true;
      spacePaintLimitWarned = false;
      spacePaintAccountWarned = false;
      try { e.preventDefault(); e.stopPropagation(); } catch {}
      maybeAddSelectionAtHover();
      spacePaintLastKey = currentHoverKey();
    });
    window.addEventListener('mousemove', () => {
      if (!spacePaintHeld || !isReadyOpen()) return;
      if (spacePaintLastKey === currentHoverKey()) return;
      if (maybeAddSelectionAtHover()) {
        spacePaintLastKey = currentHoverKey();
      }
    });
    window.addEventListener('keyup', (e) => {
      const key = e.code || e.key || '';
      if (key === 'Space' || key === ' ') { spacePaintHeld = false; spacePaintLastKey = null; spacePaintLimitWarned = false; spacePaintAccountWarned = false; }
    });

 (async () => {
  loadPriorityColors(); // Call load on startup
  renderPriorityColors(); // Call render on startup
  loadBrokenPixelColors(); // Call load on startup for broken pixels
  renderBrokenPixelColors(); // Call render on startup for broken pixels

  // TẠM THỜI: Ghi đè brokenPixelPriorityColors và priorityColors để debug
  renderBrokenPixelColors(); // Render lại sau khi ghi đè
  renderPriorityColors(); // Render lại sau khi ghi đè

  try {
    // Restore last view position
    try {
      const sx = parseFloat(localStorage.getItem('view.translateX') || '');
      const sy = parseFloat(localStorage.getItem('view.translateY') || '');
      const sc = parseFloat(localStorage.getItem('view.scale') || '');
      if (!isNaN(sx)) state.translateX = sx;
      if (!isNaN(sy)) state.translateY = sy;
      if (!isNaN(sc)) state.scale = Math.min(state.maxScale, Math.max(state.minScale, sc));
      render();
      updatePixelMarkers();
    } catch {}
    // Restore last looked world coordinates
    try {
      const wx = localStorage.getItem('view.worldX');
      const wy = localStorage.getItem('view.worldY');
      if (wx && wy) { areaInput.value = String(wx); noInput.value = String(wy); }
    } catch {}
    const saved = JSON.parse(localStorage.getItem('lastFetch') || 'null');
    if (saved && saved.mode === 'single') {
      areaInput.value = String(saved.coords[0].x);
      noInput.value = String(saved.coords[0].y);
      await loadImage(areaInput.value, noInput.value, true);
    } else if (areaInput.value && noInput.value) {
      await loadImage(areaInput.value, noInput.value, true);
    }
    // Restore images (supports multiple); falls back to legacy single image if list is empty
    try { restoreImagesFromStorage(); } catch {}
  } catch {}
    updateCounter();
    loadAccounts();
})();
    updateTotalDropletsDisplay(); // Ensure this is called here as well
    updatePixelPowerPosition(); // Gọi hàm này sau khi loadAccounts hoàn tất


    // Load overlays from storage on startup
    try { loadOverlaysFromStorage(); } catch {}

    const CANVAS_REFRESH_MS = 30 * 1000;
    setInterval(() => {
      try {
        const saved = JSON.parse(localStorage.getItem('lastFetch') || 'null');
        if (!saved) return;
        if (saved.mode === 'single') {
          loadImage(saved.coords[0].x, saved.coords[0].y, true);
        }
      } catch {}
    }, CANVAS_REFRESH_MS);
    
    
    try { setupColorPalette(); } catch {}
    if (paletteModeEl && paletteModeToggle && paletteModeLabelLeft && paletteModeLabelRight) {
      const updateToggleUi = () => {
        try {
          const isPremium = (paletteMode === 'premium');
          paletteModeToggle.classList.toggle('on', !isPremium ? true : false);
          paletteModeToggle.setAttribute('aria-checked', isPremium ? 'true' : 'false');
          paletteModeLabelLeft.classList.toggle('active', isPremium);
          paletteModeLabelRight.classList.toggle('active', !isPremium);
        } catch {}
      };
      const setMode = (mode) => { paletteMode = (mode === 'free') ? 'free' : 'premium'; try { localStorage.setItem('palette.mode', paletteMode); } catch {} recomputeActivePalette(); updateToggleUi(); };
      // Initialize using saved mode BEFORE making control visible
      try {
        const savedMode = localStorage.getItem('palette.mode');
        if (savedMode === 'free' || savedMode === 'premium') {
          paletteMode = savedMode;
        }
      } catch {}
      recomputeActivePalette();
      updateToggleUi();
      try { paletteModeEl.style.visibility = 'visible'; } catch {}
      // Wire events
      paletteModeToggle.addEventListener('click', () => setMode(paletteMode === 'premium' ? 'free' : 'premium'));
      paletteModeLabelLeft.addEventListener('click', () => setMode('premium'));
      paletteModeLabelRight.addEventListener('click', () => setMode('free'));
      // Always start with Transparent selected (no cache)
      try { localStorage.removeItem('palette.selectedColorId'); } catch {}
      selectedOverrideColorId = null;
      try { updatePaletteSelectionUi(); } catch {}
      // Ensure overlay drawing mode is off when palette changes or is loaded/reset
      isDrawingOverlay = false;
      isDraggingOverlay = false;
      canvas.style.cursor = '';
      rangeOverlay.hidden = true;
    }

    function getItemPixelPaletteId(item, sx, sy){
      const c = getItemPixelColor(item, sx, sy);
      if (!c || c.a === 0) return null;
      return rgbToPaletteId(c.r, c.g, c.b);
    }

    function buildSelectedExportForItem(item){
      console.log('--- Debugging buildSelectedExportForItem ---');
      console.log(`Broken Paint Enabled: ${brokenPixelPaintEnabled}, Priority Paint Enabled: ${priorityColorPaintEnabled}, Chess Paint Enabled: ${chessPaintEnabled}, Limit to Overlay Area: ${limitToOverlayArea}, Advanced Paint Enabled: ${advancedPaintEnabled}, Threshold: ${minizineToDetectThreshold}`);
      console.log('Broken Priority Colors:', brokenPixelPriorityColors);
      console.log('General Priority Colors:', priorityColors);

      const colors = [];
      const coords = [];
      const map = getSelectedMap(item);
      
      // Function to check if a pixel is a priority color
      const isPriorityColor = (colorId) => priorityColors.includes(colorId);
      // Function to check if a pixel is a broken pixel priority color
      const isBrokenPixelPriorityColor = (colorId) => brokenPixelPriorityColors.includes(colorId);

      // Helper to create pixel objects
      const createPixelObj = (cId, x, y, options = {}) => ({
          c: cId,
          x: x,
          y: y,
          premium: (cId != null && cId !== 0 && isPremiumColorId(cId)),
          isPriority: isPriorityColor(cId),
          isBrokenPixelPriority: isBrokenPixelPriorityColor(cId),
          isBroken: options.isBroken || false,
          isMatched: options.isMatched || false
      });

      let allPixels = [];

      if (readyGlobalMode) {
        readyGlobalSelected.forEach((rec) => {
          const wx = rec.wx;
          const wy = rec.wy;

          // Điều kiện mới để lọc pixel theo limitToOverlayArea khi ở chế độ Global
          if (limitToOverlayArea && selectedOverlayIndex !== -1 && savedOverlays[selectedOverlayIndex] && savedOverlays[selectedOverlayIndex].isVisible !== false) {
              const overlayRect = savedOverlays[selectedOverlayIndex].rect;
              if (wx < overlayRect.x || wx >= (overlayRect.x + overlayRect.w) ||
                  wy < overlayRect.y || wy >= (overlayRect.y + overlayRect.h)) {
                  return; // Bỏ qua pixel nếu nằm ngoài vùng overlay
              }
          }

          const targetColor = getPaletteRgbById(rec.c); // Dùng rec.c vì rec.colorId có thể là null
          const currentColor = getCompositeColorAtWorld(wx, wy);

          const pixelMatched = (targetColor && currentColor &&
                                 targetColor[0] === currentColor.r &&
                                 targetColor[1] === currentColor.g &&
                                 targetColor[2] === currentColor.b &&
                                 currentColor.a > 0);
          const broken = (targetColor && currentColor && areColorsSignificantlyDifferent(
            {r: targetColor[0], g: targetColor[1], b: targetColor[2]},
            currentColor,
            COLOR_DIFFERENCE_THRESHOLD
          ));
          allPixels.push(createPixelObj(rec.colorId, rec.wx, rec.wy, { isBroken: rec.isBroken, isMatched: rec.isMatched }));
        });
      } else if (map) {
        map.forEach((rec) => {
          const lx = rec.x;
          const ly = rec.y;
          const wx = Math.round((item.worldX || 0) + lx);
          const wy = Math.round((item.worldY || 0) + ly);

          // Điều kiện mới để lọc pixel theo limitToOverlayArea khi ở chế độ Map (tức là theo hình ảnh sign)
          if (limitToOverlayArea && selectedOverlayIndex !== -1 && savedOverlays[selectedOverlayIndex] && savedOverlays[selectedOverlayIndex].isVisible !== false) {
              const overlayRect = savedOverlays[selectedOverlayIndex].rect;
              if (wx < overlayRect.x || wx >= (overlayRect.x + overlayRect.w) ||
                  wy < overlayRect.y || wy >= (overlayRect.y + overlayRect.h)) {
                  return; // Bỏ qua pixel nếu nằm ngoài vùng overlay
              }
          }
          allPixels.push(createPixelObj(rec.colorId, wx, wy, { isBroken: rec.isBroken, isMatched: rec.isMatched }));
        });
      }
      
      console.log('Total pixels collected (allPixels):', allPixels.length, allPixels.slice(0, 5));
      let filteredPixels = [];
      const pixelMap = new Map(); // Dùng để loại bỏ trùng lặp nếu có

      // Filtering logic: Remove duplicate pixels (based on x,y coordinates)
      allPixels.forEach(p => {
          const key = `${p.x},${p.y}`;
          if (!pixelMap.has(key)) {
              filteredPixels.push(p);
              pixelMap.set(key, p);
          }
      });
      
      // Sorting Logic (Only if Advanced Paint is Enabled)
      if (advancedPaintEnabled) {
        // --- START: Logic to calculate if the broken color priority threshold is met ---
        let brokenPriorityColorCounts = new Map();
        if (brokenPixelPaintEnabled) {
            for (const p of filteredPixels) {
                if (p.isBroken && p.isBrokenPixelPriority) {
                    brokenPriorityColorCounts.set(p.c, (brokenPriorityColorCounts.get(p.c) || 0) + 1);
                }
            }
        }

        let brokenAndPriorityColorThresholdMet = new Map();
        for (let [colorId, count] of brokenPriorityColorCounts) {
            if (count >= minizineToDetectThreshold) {
                brokenAndPriorityColorThresholdMet.set(colorId, true);
            }
        }
        let brokenCountsMsg = 'Broken Priority Counts: ' + JSON.stringify(Array.from(brokenPriorityColorCounts.entries()));
        console.log(brokenCountsMsg);

        let thresholdMetMsg = 'Threshold Met: ' + JSON.stringify(Array.from(brokenAndPriorityColorThresholdMet.entries()));
        console.log(thresholdMetMsg);
        // --- END: Threshold Calculation ---

        // --- START: Filtering Logic (re-apply filtering based on advanced options) ---
        // This logic now correctly handles not removing matched pixels if they are part of a priority group that needs painting.
        let finalFilteredPixels = [];
        const finalPixelMap = new Map();
        filteredPixels.forEach(p => {
            const key = `${p.x},${p.y}`;
            if (finalPixelMap.has(key)) return;

            let shouldBeRemoved = false;
            // Nếu pixel đã khớp màu và không phải là pixel broken ưu tiên đạt ngưỡng, hoặc pixel ưu tiên chung khi tính năng đó bật
            if (p.isMatched) {
                // Giữ lại nếu là pixel ưu tiên bị hỏng và màu đó đã đạt ngưỡng.
                if (brokenPixelPaintEnabled && p.isBroken && p.isBrokenPixelPriority && brokenAndPriorityColorThresholdMet.has(p.c)) {
                    shouldBeRemoved = false;
                }
                // Hoặc là pixel ưu tiên chung và tính năng đó đang bật.
                else if (priorityColorPaintEnabled && p.isPriority) {
                    shouldBeRemoved = false;
                }
                else {
                    shouldBeRemoved = true; // Loại bỏ các pixel đã khớp màu nếu không thuộc các trường hợp ưu tiên trên
                }
            }
            
            if (!shouldBeRemoved) {
                finalFilteredPixels.push(p);
                finalPixelMap.set(key, p);
            }
        });
        filteredPixels = finalFilteredPixels; // Cập nhật filteredPixels sau khi lọc lại

        console.log(`Pixels after advanced filtering: ${filteredPixels.length} pixels. Details: ${JSON.stringify(filteredPixels.slice(0,5))}`);
        // --- END: Filtering Logic ---

        // --- START: Sorting Logic for Advanced Paint ---
        filteredPixels.sort((a, b) => {
            const getPriorityIndex = (colorId, list) => {
                const index = list.indexOf(colorId);
                return index === -1 ? Infinity : index;
            };

            const aBrokenPixelPriorityIndex = getPriorityIndex(a.c, brokenPixelPriorityColors);
            const bBrokenPixelPriorityIndex = getPriorityIndex(b.c, brokenPixelPriorityColors);
            const aPriorityIndex = getPriorityIndex(a.c, priorityColors);
            const bPriorityIndex = getPriorityIndex(b.c, priorityColors);

             // Ưu tiên 1: Broken Pixel Priority Colors VÀ màu đó đã đạt ngưỡng (nếu brokenPixelPaintEnabled)
             if (brokenPixelPaintEnabled) {
                 const aIsThresholdMetForColor = a.isBroken && a.isBrokenPixelPriority && brokenAndPriorityColorThresholdMet.has(a.c);
                 const bIsThresholdMetForColor = b.isBroken && b.isBrokenPixelPriority && brokenAndPriorityColorThresholdMet.has(b.c);

                 if (aIsThresholdMetForColor && !bIsThresholdMetForColor) return -1;
                 if (!aIsThresholdMetForColor && bIsThresholdMetForColor) return 1;
                 if (aIsThresholdMetForColor && bIsThresholdMetForColor) {
                     return aBrokenPixelPriorityIndex - bBrokenPixelPriorityIndex; // Sắp xếp theo thứ tự trong list
                 }
             }

             // Ưu tiên 2: General broken pixels (nếu brokenPixelPaintEnabled)
             if (brokenPixelPaintEnabled) {
                 if (a.isBroken && !b.isBroken) return -1;
                 if (!a.isBroken && b.isBroken) return 1;
             }

             // Ưu tiên 3: General priority colors (nếu priorityColorPaintEnabled)
             if (priorityColorPaintEnabled) {
                 if (a.isPriority && !b.isPriority) return -1;
                 if (!a.isPriority && b.isPriority) return 1;
                 if (a.isPriority && b.isPriority) {
                     return aPriorityIndex - bPriorityIndex;
                 }
             }

            // Ưu tiên 4: Premium colors
            if (a.premium && !b.premium) return -1;
            if (!a.premium && b.premium) return 1;
            
            // Ưu tiên 5: Chess Pattern (nếu chessPaintEnabled)
            if (chessPaintEnabled) {
                const aIsChessPattern = ((a.x + a.y) % 2 === 0); // Ví dụ: pixel ở ô chẵn
                const bIsChessPattern = ((b.x + b.y) % 2 === 0);
                if (aIsChessPattern && !bIsChessPattern) return -1;
                if (!aIsChessPattern && bIsChessPattern) return 1;
            }

            return 0; // Default: maintain original order
        });

        console.log(`Pixels after advanced sorting. Details: ${JSON.stringify(filteredPixels.slice(0,10))}`);
        // --- END: Sorting Logic for Advanced Paint ---
        
        // Final Output Logic (when advancedPaintEnabled is true)
        // Ensure pixels adhere to limitToOverlayArea and chessPaintEnabled
        let finalAdvancedColors = [];
        let finalAdvancedCoords = [];
        filteredPixels.forEach(p => {
            let shouldAdd = true;


            // Apply limit to overlay area filtering if enabled (already filtered when collecting pixels, but double check for robustness)
            if (limitToOverlayArea && selectedOverlayIndex !== -1 && savedOverlays[selectedOverlayIndex] && savedOverlays[selectedOverlayIndex].isVisible !== false) {
                const overlayRect = savedOverlays[selectedOverlayIndex].rect;
                if (p.x < overlayRect.x || p.x >= (overlayRect.x + overlayRect.w) ||
                    p.y < overlayRect.y || p.y >= (overlayRect.y + overlayRect.h)) {
                    shouldAdd = false;
                }
            }
            
            if (shouldAdd) {
                finalAdvancedColors.push(p.c);
                finalAdvancedCoords.push(p.x, p.y);
            }
        });
        console.log(`Final output (Advanced Paint Enabled): ${finalAdvancedColors.length} colors, ${finalAdvancedCoords.length} coords.`);
        console.log('--- End Debug ---');
        return { colors: finalAdvancedColors, coords: finalAdvancedCoords, filteredPixels };
      } else {
        // ELSE block for advancedPaintEnabled is false
        // Normal behavior: only remove pixels that are already the correct color on the canvas
        // This is primarily for the non-Advanced Paint scenario.
        allPixels.forEach(p => {
            const wx = p.x;
            const wy = p.y;
            const targetColorRgb = getPaletteRgbById(p.c);
            const currentColorRgb = getCompositeColorAtWorld(wx, wy);

            // Chỉ thêm vào nếu pixel CẦN được tô (màu hiện tại khác với màu mục tiêu)
            if (!targetColorRgb || !currentColorRgb ||
                targetColorRgb[0] !== currentColorRgb.r ||
                targetColorRgb[1] !== currentColorRgb.g ||
                targetColorRgb[2] !== currentColorRgb.b ||
                currentColorRgb.a === 0 // Nếu pixel trên bản đồ trong suốt, thì chắc chắn cần tô
            ) {
                colors.push(p.c);
                coords.push(p.x, p.y);
            }
        });
        console.log(`Final output (Advanced Paint Disabled): ${colors.length} colors, ${coords.length} coords.`);
        console.log('--- End Debug ---');
        return { colors, coords, filteredPixels: allPixels }; // Trả về allPixels vì không có lọc/sắp xếp nâng cao
      }
    }

    // Hàm mới để báo cáo số lượng pixel cần tô còn lại theo màu
    function getRemainingPaintablePixelSummary(filteredPixels) {
        const remainingPixelSummary = new Map();

        for (const p of filteredPixels) {
            // Chúng ta chỉ quan tâm đến các pixel isBroken (pixel bị sai)
            if (p.isBroken) {
                remainingPixelSummary.set(p.c, (remainingPixelSummary.get(p.c) || 0) + 1);
            }
        }

        let summaryMessage = '--- Remaining Paintable Pixel Summary (by ColorId) ---\n';
        if (remainingPixelSummary.size === 0) {
            summaryMessage += 'No remaining broken pixels to paint.';
        } else {
            for (let [colorId, count] of remainingPixelSummary) {
                summaryMessage += `Color ID ${colorId}: ${count} pixels remaining.\n`;
            }
        }
        summaryMessage += '----------------------------------------------------';
        console.log(summaryMessage);
    }

    function logSelectedPixelsCurrentItem(){
      try {
        const sel = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;
        if (!sel) return;
        const data = buildSelectedExportForItem(sel);
        const t = (readyTokenInput && readyTokenInput.value) ? readyTokenInput.value : '';
        console.log({ colors: data.colors, coords: data.coords, t });
      } catch {}
    }

    if (readyTokenInput) {
      readyTokenInput.addEventListener('input', () => {
        updateStartEnabled();
      });
    }

    if (removeDuplicatesBtn) {
      removeDuplicatesBtn.addEventListener('click', () => {
        const selItem = (selectedIndex >= 0 && selectedIndex < signItems.length) ? signItems[selectedIndex] : null;

        if (readyGlobalMode) {
          const keysToRemove = [];
          readyGlobalSelected.forEach((rec, key) => {
            const currentWorldColor = getCompositeColorAtWorld(rec.wx, rec.wy);
            const selectedColor = getPaletteRgbById(rec.colorId);

            // Loại bỏ nếu màu đã trùng khớp trên bản đồ hoặc trong suốt
            if (currentWorldColor && selectedColor &&
                currentWorldColor.r === selectedColor[0] &&
                currentWorldColor.g === selectedColor[1] &&
                currentWorldColor.b === selectedColor[2] &&
                currentWorldColor.a > 0) {
              keysToRemove.push(key);
            }
          });
          keysToRemove.forEach(key => readyGlobalSelected.delete(key));
        } else if (selItem) {
          const map = getSelectedMap(selItem);
          if (!map) return;

          const keysToRemove = [];
          map.forEach((rec, key) => {
            const lx = rec.x;
            const ly = rec.y;
            const wx = Math.round((selItem.worldX || 0) + lx);
            const wy = Math.round((selItem.worldY || 0) + ly);
            const currentWorldColor = getCompositeColorAtWorld(wx, wy);
            const selectedColor = getPaletteRgbById(rec.colorId);

            // Loại bỏ nếu màu đã trùng khớp trên bản đồ hoặc trong suốt
            if (currentWorldColor && selectedColor &&
                currentWorldColor.r === selectedColor[0] &&
                currentWorldColor.g === selectedColor[1] &&
                currentWorldColor.b === selectedColor[2] &&
                currentWorldColor.a > 0) {
              keysToRemove.push(key);
            }
          });
          keysToRemove.forEach(key => removePixelSelection(selItem, rec.x, rec.y));
        }
        updateReadySelectionLabel();
        updatePixelMarkers();
        render();
        showToast(t('messages.duplicatesRemoved'), 'success', 2000);
      });
    }

    if (addPriorityColorBtn) {
      addPriorityColorBtn.addEventListener('click', () => {
        // Just add currently selected color as priority if a color is selected
        if (selectedOverrideColorId != null && selectedOverrideColorId !== 0) {
          if (!priorityColors.includes(selectedOverrideColorId)) {
            priorityColors.push(selectedOverrideColorId);
            savePriorityColors();
            renderPriorityColors();
            showToast(t('messages.colorAddedToPriorityList'), 'success', 2000);
          } else {
            showToast(t('messages.colorAlreadyInPriorityList'), 'info', 2000);
          }
        } else {
          showToast(t('messages.noColorSelected'), 'error', 2000);
        }
      });
    }


    function savePriorityColors() {
      try {
        localStorage.setItem(PRIORITY_COLORS_STORAGE_KEY, JSON.stringify(priorityColors));
      } catch {}
    }

    function loadPriorityColors() {
      priorityColors = [7]; // Ghi đè cho mục đích debug
      // try {
      //   const saved = localStorage.getItem(PRIORITY_COLORS_STORAGE_KEY);
      //   if (saved) {
      //     priorityColors = JSON.parse(saved);
      //   }
      // } catch {
      //   priorityColors = [];
      // }
    }

    function renderPriorityColors() {
      if (!colorPriorityListEl) return;
      colorPriorityListEl.innerHTML = '';
      priorityColors.forEach((colorId, index) => {
        const swatch = document.createElement('div');
        swatch.className = 'palette-swatch';
        const rgb = getPaletteRgbById(colorId);
        swatch.style.backgroundColor = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
        swatch.title = `Palette ID: ${colorId}`;
        swatch.style.position = 'relative';
        swatch.style.margin = '2px';
        swatch.style.width = '24px';
        swatch.style.height = '24px';

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.style.position = 'absolute';
        deleteBtn.style.top = '-8px';
        deleteBtn.style.right = '-8px';
        deleteBtn.style.background = 'rgba(255,0,0,0.7)';
        deleteBtn.style.color = 'white';
        deleteBtn.style.border = 'none';
        deleteBtn.style.borderRadius = '50%';
        deleteBtn.style.width = '16px';
        deleteBtn.style.height = '16px';
        deleteBtn.style.fontSize = '10px';
        deleteBtn.style.lineHeight = '1';
        deleteBtn.style.padding = '0';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          priorityColors.splice(index, 1);
          savePriorityColors();
          renderPriorityColors();
        };
        swatch.appendChild(deleteBtn);
        colorPriorityListEl.appendChild(swatch);
      });
    }

    if (clearPriorityListBtn) {
      clearPriorityListBtn.addEventListener('click', () => {
        priorityColors = [];
        savePriorityColors();
        renderPriorityColors();
        showToast(t('messages.priorityListCleared'), 'success', 2000);
      });
    }

    // New Pick Color button logic
    if (pickColorToolBtn) {
      pickColorToolBtn.addEventListener('click', () => {
        isPickingColorMode = !isPickingColorMode;
        if (isPickingColorMode) {
          canvas.style.cursor = 'crosshair';
          showToast(t('messages.pickColorModeOn'), 'info', 3000);
        } else {
          canvas.style.cursor = '';
          showToast(t('messages.pickColorModeOff'), 'info', 2000);
        }
      });
    }

    // Handle clicks on canvas in picking color mode
    // Handle clicks on canvas in picking color mode (consolidated from mousedown)
    // Removed direct canvas.addEventListener('click', ...) as the logic is now in mousedown and returns early.
    // This block is effectively removed by the previous diff.

    function saveBrokenPixelColors() {
      try {
        localStorage.setItem(BROKEN_PIXEL_COLORS_STORAGE_KEY, JSON.stringify(brokenPixelPriorityColors));
      } catch {}
    }

    function loadBrokenPixelColors() {
      brokenPixelPriorityColors = [7]; // Ghi đè cho mục đích debug
      // try {
      //   const saved = localStorage.getItem(BROKEN_PIXEL_COLORS_STORAGE_KEY);
      //   if (saved) {
      //     brokenPixelPriorityColors = JSON.parse(saved);
      //   }
      // } catch {
      //   brokenPixelPriorityColors = [];
      // }
    }

    function renderBrokenPixelColors() {
      if (!brokenPixelPriorityListEl) return;
      brokenPixelPriorityListEl.innerHTML = '';
      brokenPixelPriorityColors.forEach((colorId, index) => {
        const swatch = document.createElement('div');
        swatch.className = 'palette-swatch';
        const rgb = getPaletteRgbById(colorId);
        swatch.style.backgroundColor = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
        swatch.title = `Palette ID: ${colorId}`;
        swatch.style.position = 'relative';
        swatch.style.margin = '2px';
        swatch.style.width = '24px';
        swatch.style.height = '24px';

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.style.position = 'absolute';
        deleteBtn.style.top = '-8px';
        deleteBtn.style.right = '-8px';
        deleteBtn.style.background = 'rgba(255,0,0,0.7)';
        deleteBtn.style.color = 'white';
        deleteBtn.style.border = 'none';
        deleteBtn.style.borderRadius = '50%';
        deleteBtn.style.width = '16px';
        deleteBtn.style.height = '16px';
        deleteBtn.style.fontSize = '10px';
        deleteBtn.style.lineHeight = '1';
        deleteBtn.style.padding = '0';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          brokenPixelPriorityColors.splice(index, 1);
          saveBrokenPixelColors();
          renderBrokenPixelColors();
        };
        swatch.appendChild(deleteBtn);
        brokenPixelPriorityListEl.appendChild(swatch);
      });
    }

    if (addBrokenPixelColorBtn) {
      addBrokenPixelColorBtn.addEventListener('click', () => {
        // Just add currently selected color as broken pixel priority if a color is selected
        if (selectedOverrideColorId != null && selectedOverrideColorId !== 0) {
          if (!brokenPixelPriorityColors.includes(selectedOverrideColorId)) {
            brokenPixelPriorityColors.push(selectedOverrideColorId);
            saveBrokenPixelColors();
            renderBrokenPixelColors();
            showToast(t('messages.colorAddedToBrokenPixelList'), 'success', 2000);
          } else {
            showToast(t('messages.colorAlreadyInBrokenPixelList'), 'info', 2000);
          }
        } else {
          showToast(t('messages.noColorSelected'), 'error', 2000);
        }
      });
    }

    const pickBrokenPixelColorToolBtn = document.getElementById('pick-broken-pixel-color-tool-btn');
    if (pickBrokenPixelColorToolBtn) {
      pickBrokenPixelColorToolBtn.addEventListener('click', () => {
        isPickingBrokenPixelColorMode = !isPickingBrokenPixelColorMode;
        if (isPickingBrokenPixelColorMode) {
          canvas.style.cursor = 'crosshair';
          showToast(t('messages.pickBrokenPixelColorModeOn'), 'info', 3000);
        } else {
          canvas.style.cursor = '';
          showToast(t('messages.pickBrokenPixelColorModeOff'), 'info', 2000);
        }
      });
    }

    if (clearBrokenPixelListBtn) {
      clearBrokenPixelListBtn.addEventListener('click', () => {
        brokenPixelPriorityColors = [];
        saveBrokenPixelColors();
        renderBrokenPixelColors();
        showToast(t('messages.brokenPixelListCleared'), 'success', 2000);
      });
    }
  </script>
</body>
</html> 




